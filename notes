Summary - Chapter 3

There are 8 basic data types in JavaScript.

number: for numbers of any kind: integer or floating-point, integers are limited by ±(253-1).
bigint: is for integer numbers of arbitrary length.
string: for strings. A string may have zero or more characters, there’s no separate single-character type.
boolean: for true/false.
null: for unknown values – a standalone type that has a single value null.
undefined: for unassigned values – a standalone type that has a single value undefined.
object: for more complex data structures.
symbol: for unique identifiers.

The typeof operator allows us to see which type is stored in a variable.
Two forms: typeof x or typeof(x).
Returns a string with the name of the type, like "string".

For null returns "object" – this is an error in the language, it’s not actually an object.

In the next chapters, we’ll concentrate on primitive values and once we’re familiar with them, we’ll move on to objects.

########################################################################################################################

Summary - Chapter 4

We covered 3 browser-specific functions to interact with visitors:

alert: shows a message.
prompt: shows a message asking the user to input text. It returns the text or, if Cancel button or Esc is clicked, null.
confirm: shows a message and waits for the user to press “OK” or “Cancel”. It returns true for OK and false for Cancel/Esc.

All these methods are modal: they pause script execution and don’t allow the visitor to interact with the rest of the page until the window has been dismissed.

There are two limitations shared by all the methods above:

The exact location of the modal window is determined by the browser. Usually, it’s in the center.
The exact look of the window also depends on the browser. We can’t modify it.

That is the price for simplicity. There are other ways to show nicer windows and richer interaction with the visitor, but if “bells and whistles” do not matter much, these methods work just fine.

########################################################################################################################

Summary - Chapter 5

The three most widely used type conversions are to string, to number, to boolean

String Conversion - Occurs when we output something. Can be performed with String(value). The conversion to string is usually obvious for primitive values.

Numeric Conversion - Ocrurs in math operations. Can be performed with Number(value).

The conversion follow the rules:

Value                  Becomes
undefined              NaN
null                   0
true/false             1/0
string                 The string is read 'as is', whitespaces from both sides are ignored
                       An empty string becomes 0. An error gives NaN.


Boolean Conversion - Occurs in logical operations. Can be performed with Boolean(value).

Follows the rules:

Value                                   Becomes...
0, null, undefined, Nan, ""             false
any other value                         true


Most of these rules are easy to understand and memorize. The notable exceptions where people usually make mistakes are:

undefined is NaN as a number, not 0
"0" and space-only strings like " " are true as boolean

Objects aren't covered here. We'll return to them later in the chapter that is devoted exclusively to objects after we learn more about JavaScript.

#########################################################################################################################

Summary - Chapter 6 Comparisons

* Comparison operators returs a boolean value (true or false)
* Strings are compared letter-by-letter in the 'dictionary' order (unicode: a > A)
* When values of different types are compared, they get converter to numbers (not counting '===' - strict equality check)
* null and undefined equal each other but do not equal any other value
* be careful when using comparisons like > or < with variables that can occasionally be null/undefined. Checking for null/undefined separately is a good idea.

#########################################################################################################################

Summary - Chapter 7 - IFs, ELSES, ELSE IFS and ?

if (condition) { <code to be executed if condition is true>}
else if { <code to be executed if another condition is true>}
.
.
.
else { <code to be executed if nothing is true> }

? ternary operator, for quick ifs - should not be used to execute code

let variable = (condition) ? <if true> : <if false>

#########################################################################################################################

OR "||" finds the first truthy value

result = value1 || value2 || value3;
evaluates from left to right, for each operand converts it to boolean, if the result is true, stops and returns the original value of that operand
if all operands are false, then returns the last operand

AND "&&" finds the first falsy value 

result = value1 && value2 && value3;
evaluates from left to right, for each operand converts it to boolean, if the result is false, stops and returns the original value of that operand, if all operands have been evaluated and are truthy, returns the last operand

it is important to notice that the && operator has ahigher precedence than ||.
the expression:

a && b || c && d is executed as if the && are in parenthesis: (a && b) || (c && d)

Do not replace IF with || and &&. use the operator that you are meant to use.
if if we need an if and && if we want an AND.

NOT "!" 

result = !value
converts the operand to boolean (true/false), returns the inverse value
for instance:

alert(!true) //false
alert(!0) //true

tip: sometimes double ! is used to convert something to boolean type:

alert(!!"non-empty string"); //true
it is the same as using the Boolean function

alert(Boolean(null)); //false

#########################################################################################################################

Nullish Coalescing Operator '??'

When a expression is neither null or undefined, it is called a 'defined' expression.

for instance:

result of a ?? b is:

if a is defined, then a
if a isn't defined, then b

in other words, ?? returns the first argumentif it is not null/undefined. otherwise the second one is returned. it is a simpler way of the original form, like this:

result = (a !== null && a !== undefined) ? a : b - Original syntax

the common use is to provide a default value for a potentially undefined variable

for instance:

let user;

alert(user ?? "Anonymous"); //if user is not defined, it will receive "Anonymous"

let user = "John";

alert(user ?? "Anonymous"); // John (because user is 'defined')

a sequence of ?? xcan be used to select the first value from a list that is not null/undefined:

let firstName = null;
let lastName = null;
let nickName = "Supercoder";

alert(firstName ?? lastName ?? nickName ?? "Anonymous"); //Supercoder will be alerted

historically the usage of || was the same as ?? is now. however, it returns the first truthy value whereas ?? returns the first defined. it is specifically important for situations where
we may want to use default values only when the variable is really unknown / not set, not when it is 0, false or an empty string.

for instance, consider this:

let height = 0;
alert(height || 100); // 100
alert(height ?? 100); // 0

in the first case, the value of height is 0, which is false as a boolean, so the result is 100 because it is the first truthy value

however, in the second case, height is still 0, which is false as a boolean, but the ?? operator checks if it is 'defined', and it is, so it's truthy, and it is returned by the expression, instead of 100. 

there is a clear difference between falsy and not 'defined'

precedence of a ||, but a little bit lower. it is evaluated before = and ? but after most
operations like +,- and * - this means it might be necesasry to use parentheses in longer expressions, like the following:

let height = null;
let width = null;

let area = (height ?? 100) * (width ?? 50);
alert(area) //5000

this is the correct usage. for instance, check this:

let area = height ?? 100 * width ?? 50; 
which means something like this:

let area = height ?? ( 100 * width) ?? 50; because of precedence. which usually is not what we want.

It’s forbidden to use it with || or && without explicit parentheses, it was created so people
wouldn't mess up with the addition of ?? to substitute ||.


#########################################################################################################################

LOOPING - While and For - When we need to repeat stuff

while (condition) {
	//code
	//so-called "loop body"
}

while the condition is truthy, the loop body is executed

for instance

let i = 0
while (i < 3) {
	alert( i );
	i++
}

//shows 0, then 1, then 2

a single execution is called an iteration, the loop in the example above makes three iterations
while turns any variable into boolean for execution, a shorter way to write (i != 0) is while(i)

let i = 3;
while (i) {
	alert(i);
	i--;
}

//shows 3, then 2, then 1
for a single line body you don't need curly braces;

if you want the body to be executed at least once, you can use do while loop:

let i = 0;
do {
	alert(i);
	i++;
} while (i < 3);

but usually people use while.

FOR LOOP

for (begin; condition; step){
	// ... loop body ...
}

begin: i = 0; executes once upon entering the loop
condition: i < 3; checked before every loop iteration, if false, the loop stops
body: alert(i); runs again and again while the condition is truthy
step: ì++; executes after the body on each iteration

something like:

Run begin
-> (if condition -> run body and run step)
-> (if condition -> run body and run step)
-> (if condition -> run body and run step)
-> ...

the i variable can be declared inline so it exists only whitin the loop

we can skip parts of the loop, like the begin, the condition or the step.
We just can't miss the two ;; inside the for otherwise it is a syntax error.

BREAKING THE LOOP

let sum = 0;
while(true) {
	let value = +prompt("Enter a number", '');
	if (!value) break; 
	sum += value;
}
alert('Sum: ' + sum);

if the user enters an empty line or cancels the input, the loop immediately stops.
passing control to the first line after the loop, namely, alert.

the combination 'infinite loop + break as needed' is great for checking a condition not in the
beginning or end but during the loop

CONTINUE TO NEXT ITERATION

Continue is a lighter version of break. it stops the iteration and goes to the next one if the conditions apply. it doesnt stop the loop itself. 

for instance:

for (let i = 0; i < 10; i ++) {
	//if true, skip the remaning part of the body
	if (i % 2 == 0) continue;

	alert(i); // 1, then 3, 5, 7, 9
}

usually continue can be used to reduce nesting, improving readability;
it can't be used with ternary operator, because it should not be used as an if statement

LABELS - sometimes inside multiple loops, we need to break out of an specific one
for that we use labels. it is a interesting concept, see:

outer: for (let i = 0; i < 3; i++) {
	
	for (let j = 0; j < 3; j++) {

		let input = prompt(`Value at coords (${i}), ${j})`, '');

		if (!input) break outer
	}
}

alert('Done!');

in this case, the label 'outer' will look above for the loop that it is named by and break
out of that loop. same thing can be done with continue, but in this case the code skips just the iteration and goes to the next one of said loop.

Summary - 

while - condition is checked before iteration
do .. while - the condition is checked after each iteration
for (;;) - the condition is checked before each iteration, additional settings available

to make an 'infinite' loop, usually the while(true) construct is used. Such loop, just like any other, can be stopped with the break directive - and if we just want to skip the actual iteration, we can use continue directive.

break / continue supports labels before the loop, so nested loops can be escaped

#############################################################################################

a Switch Statement can replace multiple if checks
it gives a more descriptive way to compare a value with multiple variants

switch(x) {
	case 'value1':   // if (x === 'value1')
	...
	[break]

	case 'value2':   // if (x === 'value2')
	...
	[break]

	default:
	...
	[break]

}

the value of x is checked for a strict equality to the value from the first case.
then, to second value and so on.
if the equality is found, switch starts to execute the code starting from the corresponding case, until nearest break or until the end of the switch
if no case is matched then the default code is executed (if it exists)

an example

let a = 2 + 2;

switch(a) {
	case 3:
		alert( 'Too small' );
		break;
	case 4:
		alert( 'Exactly!' );
		break;
	case 5:
		alert( 'Too big' );
		break;
	default:
		alert( "I don't know such values" );

}

here the switch starts to compare a from the first case variant and that is 3. the match fails.
then 4. that's a match, so the execution starts from case 4 until nearest break

if there is no BREAK then the execution continues with the next CASE without any checks.

you can use expressions for switch and case statements.

Grouping of 'case': several variants of case which share the same code can be grouped
for example, if we want the same code to run for case 3 and case 5:

let a = 3;

switch (a) {
	case 4:
		alert('Right!');
		break;

	case 3:
	case 5:
		alert('Wrong!');
		alert("why don't you take a math class?");
		break;

	default:
		alert('The result is strange. Really');

}

now both 3 and 5 show the same message.

the ability to 'group' cases is a side-effect of how switch / case works.
without break, the execution of case 3 starts from the line and goes through case 5 because there is no break.

type matters

let's emphasize that the equality check is always strict. the values must be of the same type to match. for example let's consider the code:

let arg = prompt("enter a value?");
switch (arg) {
	case '0':
	case '1':
		alert( 'One or zero' );
		break;

	case '2':
		alert( 'Two' );
		break;

	case 3:
		alert( 'Never executes!');
		break;

	default:
		alert( 'an unknown value' );
}

here case 3 is a dead code, because the result of the prompt is a string and the comparison for case is a strict comparison

#############################################################################################

FUNCTIONS: HERE IT GOES

When we want to perform similar actions in many places of the script

example: showing a nice looking message when someone logs in, out or to somewhere else

they are like building blocks of the program, allowing code to be called several times without repetition.

to create a function we use a function declaration

it is something like this:

function showMessage() {
	alert('Hello!');
}

the keyword function goes first, then the name of the function then a list of parameters between commas, and finally the code of the function, called the function body. the structure should be something like this:

function name(parameters) {
	... body ...
}

main work is to avoid code duplication

Local variables

A variable declared inside a function is only visible inside that function

Outer variables a function can access an outer variable as well, for example
it can even modify the outer variable, but it is only used if there is no local one

If same-named variable is declared, inside the function, then it SHADOWS the outer one, for instance, in the code below, the cunftion uses the local userName, the outer one is ignored

Variables declared outside of any function, such as the outer userName, in the code above, are called global, global variables are visible from any function, unless shadowed by locals.

it is a good practice to minimize the use of global variables, modern code has few or no globals, most variables reside in their functions, sometimes, though, they cab be useful to store project-level data

Parameters

we can pass arbitrary data to functions using parameters (also called function arguments)

example:

function showMessage(from, text) {
	alert(from + ": " + text);
}

the given values for from and text are copied to local variables then the function uses them

if there is a change in the value inside the function, it is not made outside, because it is a copy of the data

Default Values

if a parameter is not provided, then its value becomes undefined.
for instance, the aforementioned function showMessage(from, text) can be called with a single argument

we can pass another function as default value, it is often used, it will be called all the time the function is executed

Alternative Default Parameters

Sometimes it makes sense to set default values for parameters not in the function declaration, but at a later stage, during its execution.

function showMessage(text) {
	if (text === undefined) {
	text = 'empty message';
	}

alert(text);
}

showMessage();

alternatively:

function showMessage(text) {
	text = text || 'empty';
}

also alternatively:

function showCount(count) {
	alert(count ?? "unknown");
}

showCount(0);
showCount(null);
showCount();

Returning a Value:

a function can return a value back into the calling code as the result.
the simplest example would be a function that sums two values:

function sum(a, b) {
	return a + b;
}

let result = sum(1, 2);
alert(result)

the directive return can be in any place of the function, when the execution reaches it, the function stops. and the value is returned to the calling code (assigned to the result variable)

there may be many occurrences of return in a single function, for instance:

function checkAge(age) {
	if(age >= 18) {
	return true;
	} else {
	return confirm('Do you?')
	}
}

let age = prompt('how old are you?', 18);

if (checkAge(age)) {
	alert ('go on');
} else {
	alert ( 'access denied');
}

it is possible to use return without a value, that causes the function to exit immediately

for example:

function showMovie(age) {
	if( !checkAge(age)) {
	return;
	}

	alert( "Showing you the movie" );
}

in the code above, if checkAge(age) returns false, then showMovie won't proceed to the alert.

a function with an empty return, or without it, returns undefined

never add new line between 'return' and the value. for a long expression in return it might be tempting to put it on a separate line, like this:

return
	(some + long + expression + or + whatever)

it will be an empty return, because JS assumes a semicolon after return
it should be done with a  open parenthesis right after return then opening it in new lines.

Naming a Function

functions are actions, so their name is usually a verb. it should be brief and as accurate as possible, and describe what the function does. so that someone reading the code gets an indication of what the function does

it is a widespread practice to start a function with a verbal prefix which vaguely describes the action, there must an agreement within the team on the meaning of the prefixes

for instance, functions that start with 'show' usually show something

functions that start with

get - return a value
calc - calculate something
create - create something
check - check something and return a boolean or something

examples:

showMessage()
getAge()
calcSum()
createForm()
checkPermission()

with prefixes in place, a glance at a function name gives an understanding what kind of work it does and what kind of value it returns

One function - one action

a function should do exactly what is suggested by its name, no more
two independent action usually deserver two functions, even if they are usually together (in that case, we can mae a 3rd function that calls those two)

a few examples of breaking this rule:

getAge - would be bad if it shows an alert with the age (should only get)
createForm - would be bad if it modifies the document, adding a form to it (should only create and return)
checkPermission - would be bad if it displays the access granted / denied message (should only perform the check and return the result)

these examples assume common meanings of prefixes, you and your team are free to agree on other meanings, but usually they're not much different, in any case, you should have a firm understanding of what a prefix means, what a prefixed function can and cannot do. all same-prefixed functions should obey the rules, and the eam should share the knowledge

Ultrashort function names

functions that are used VERY OFTEN, sometimes have ultrashort names. For example, the jQuery framework defines a function with $, the LODASH library has its core function named _.

the are exceptions, generally function names shouldbe concise and descriptive.

functions == comments

functions should be short and do exactly one thing, if that thing is big, maybe it's worth it to split the function into a few smaller functions. sometimes following this rule may not be that easy, but it's definitely a good thing

a separate function is not only easier o test and debug, its very existence is a great comment.

for instance, compare the two functions showPrimes(n) below. each one outputs prime numbers up to N

function showPrimes(n) {
	nextPrime: for (let i = 2; i < n; i++) {

		for (let j = 2; j < i; j++) {
			if (i%j == 0) continue nextPrime;
		}

		alert(i);
	}
}

<><><><><><><><><><><><><><><><><><><><><><><><><>

function showPrimes(n) {
	for (let i = 2; i < n; i++) {
		if (!isPrime(i)) continue;

		alert(i);
	}
}

function isPrime(n) {
	for (let i = 2; i < n; i++) {
		if(n % i == 0) return false;
	}
	return true;
}

The Second variant is easier to understand. instead of the code piece we see a name of the
action (isPrime). sometimes people refer to such code as self-describing

so, functions can be created even if we don't intend to reuse them. they structure the code and make it readable.

Summary

a function declaration looks like this:

function name(parametesr, delimited, by, coma) {
	/* code */
}

values passed to a function as parameters are copied to its local variables
a function may access outer variables, but it works only from inside out the code outise the function doesnt see its local variables
a function can return a value, if it doesnt, then its result is 'undefined'

to make code clean and easy to understand, it's recommended to use mainly local variables and parameters in the function,not outer variables.

it is always easier to understand a function which gets parameters, works with them and returns a result than a function which gets no parameters but modifies outer variables as a side-effect

function naming:

a name should clearly describe what the function does when we see a function call in the code a good name instantly gives us an understanding what it does and returns
a function is an action, so function names are usually verbal
there exit many well known function prefixes, like create, show, get check. use them to hint what a function does

functions are the main bulding blocks of scripts, now we've covered the basics, so we actually can start creating and using them, but that's only the beginning of the path, we are going tom return to them many times, going more deeply into their advanced features.

#########################################################################################

Function Expressions

IN JavaScript, a function is not a magical language structure, but a special kind of value.

the syntax that we used before is called a function declaration:

function sayHi(){
	alert("Hello!");
}

there is another syntax for creating a function that is called a Function Expression

it looks like this:

let sayHi = function() {
	alert("Hello!");
};

here the function is created and assigned to the variable explicitly, like any other value, no matter how the function is defined, it's just a value stored in the variable sayHi

the meaning of thse code samples is the same: "create a function and put it into the variable sayHi"

we can even print out that value using alert

please not that the last line does not run the function, because there are no parentheses after sayHi. there are programming languages where any mention of a function name causes its execution, but JavaScript is not like that

in JS a function is a value, so we can deal with it as a value. the code above shows its string representation, which is the source dode.

it is a special value because we can call it using parenthesis after it, but it is still a value that can be copied like any other;

function sayHi() { (1)
	alert("Hello!");
}

let func = sayHi; (2)

func(); (3)
sayHi();


he is what happens above in detail:

1 - the function declaration created the function and puts it into the variable named sayHi
2 - copies it into the variable func. notice there are no parenthesis after the name of the function. this means we are copying the function not the result of its execution
3 - now the function can be called as both sayHi() and func()

we could also have used a function expression to declare sayHi, for example:

let sayHi = function() {
	alert("Hello!");
};

let func = sayHi;

why semicolon at the end?
there's no need for ; at the end of code blocks and syntax structures that use them, like if {}, for {} and function f {}.

the function expression is used inside the statement 'let ... ' as a value, it's not a code block. but rather an assignment. The semicolon at the end is a semicolon at the end of statements. no matter what the value is. so the semicolon here is not related to the function expression itself, it is just to terminate the statement.

Callback Functions

let's look at more examples of passing functions as values and using function expressions.
we will write a function ask(question, yes, no) with three parameters:

question

text of the question

yes

function to run if the answer is yes

no

function to run if the answer is no

The function should ask the 'question' and, depending on the user's answer, call yes() or no()

function ask(question, yes, no) {
	if (confirm(question)) yes()
	else no();
}

function showOk() {
	alert("You agreed");
}

function showCancel() {
	alert("You canceled the execution");
}

//usage: functions showOk, showCancel are passed as arguments to ask
ask("Do you agree?", showOk, showCancel);

in practice, such functions are quite useful. the major difference between a real-life ask and the example above is that real-life functions use more complex ways to interact with the user than a simple confirm, in the browser, such function usually draws a nice-looking question window, but that's another story.

the arguments showOk and showCancel of ask are called callback functions or just callbacks.

the idea is that we pass a function and expect it to be called back later if necessary. in our case, showOk becomes the callback for 'yes' answer and showCancel for 'no' answer.

we can rewrite it using function expressions shorter:

function ask(question, yes, no) {
	if (confirm(question()) yes()
 	else no();
}

ask(
	"Do you agree?",
	function(){alert("You agreed."); },
	function(){alert("You canceled the execution."); }
	);

Here functions are declared right inside the ask(...) call. They have no name and so are called anonymous. such functions are not accessible outside of ASK, because they are not assigned to variables. but that's just what we want here.

such code appears in our scripts very naturally, it's in the spirit of JavaScript.

a function is a value representing an action, regular values like strings or numbers represent the DATA, a function can be perceived as an ACTION. we can pass it between variables and run when we want.

Function Expression vs Function Declaration

Let's formulate the key difference between function declaration and expressions

first, the syntax: how to differentiate between them in the code.

* function declaration: a function, declared as a separate statement, in the main code flow

//function declaration
function sum(a, b) {
	return a + b;
}

* function expression: a function, crated inside an expression or inside anothet syntax construct. here, the function is created at the right side of the 'assignment expression' =;

//function expression
let sum = function(a,b) {
	return a + b;
};

The more subtle difference is when a function is created by the javascript engine.
A function expression is created when the execution reaches it and is usable only from that moment. once the execution flow passes to the right side of the assignment let sum = function ... - here we go, the function is created and can be used (assigned, called, etc) from now on

Function declaration is different

A function declaration can be called earlier than it is defined.

For example, a global function declaration is visible in the whole script, no matter where it is

that's due to internal algorithms. when JavaScript prepares to run the script, it first looks for global function declarations in it and creates the functions. we can think of it as an 'initialization stage'. and after function declarations are processed, the code is executed. so it has access to all these functions.

For example, we can call a function before it is declared at a script;

sayHi("John");

function sayHi(name) {
	alert(`Hello, ${name}`);
}

but we can't call a function expression before it is created:

sayHi("John") // error!

let sayHi = function(name) {
	alert(`Hello, ${name}`);
}

function expressions are created when the execution reaches them. that would only happen in the line (*).

another special feature of function declaraction is their block scope. In strict mode, when a function declaraion is within a code block, it is visible everywhere inside that block, but not outside of it.

For instance, let's imagine that we need to declare a function welcome() depending on the age variable that we get during runtime, and then we plan to use it some time later.

if we use function declaration, it won't work as intended:

let age = prompt("what is your age?", 18)
//conditionally declare a function
if(age<18) {
	
	function welcome() {
		alert("Hello!");
	}
} else {
	function welcome() {
		alert("Greetings!");
	}
}

// ... use it later
welcome(); // won't work, error

that's because a function declaration is only visible inside the code block in which it resides
here is another example:

let age = 16;

if (age < 18) {
	welcome();

	function welcome() {
		alert("Hello!");
	}

	welcome();
} else {
	
	function welcome() {
		alert("Greetings!");
	}
}

// here we're out of curly braces,
//so we can not see function declaration made inside it

welcome(); //error, not defined

what can we do to make welcome visible outside of if? The correct approach would be to use a function expression and assign welcome to the variable that is declared outside of if, and has the proper visibility.

1 - create variable before, in global
2 - assign function to it, even if inside another scope

this code should work:

let age = 18;
let welcome;

if (age < 18) {
	welcome = function() {
		alert("Hello!");
	};
} else {
	welcome = function() {
	alert("Greetings!");
	};

}

welcome(); //ok now, it works

but remember we could use ? operator to make it even smoother.

let age = 18;
let welcome = (age < 18) ?
	function() {alert("Hello!");} :
	function() {alert("Greetings!");};

welcome(); // this version also works

When to choose function declaration versus function expression?

as a rule of thumb, when we need to declare a function, the first to consider is function declaration syntax. it gives more freedom in how to organize our code, because we can call such functions before they are declared.

that's also better for readability, as it's easier to loop up function f() {} in the code than let f = function() {}. they are more eye catching.

BUT if a function declaration does not suit us for some reason, or we need a conditional declaration (we've just seen an example), then function expression should be used

therefore, inside conditionals mostly.

Summmary

* functions are values. they can be assigned, copied or declared in any piece of the code
* if the fucntion is declared as a separate statement in the main code flow, it's called a 'function declaration'
* if the function is created as a part of an expression, it's called a 'function expression'
* function declarations are processed before the code block is executed, they are visible everywhere in the block
* function expressions are created when the execution flow reaches them

in most cases, when we need to declare a function, a function declaration is preferable. because it is visible prior to the declaration itself, that gives us more flexibility in code organization and is usually more readeable. so we should use function expression only when function declaration is not fit for the task. we've seen couple examples of that in this chapter, and will see more in the future.

##########################################################################################

Arrow Functions, The basics

There is another very simple and concise syntax for creating functions, that's often better than function expressions. it's called arrow functions:

let func = (arg1, arg2, arg3, ..., argN) => expression

... this creates a function func that accepts arguments arg1, ..., argN - then evaluates the expression on the right side with their use and returns its result

in other words, it's the shorter version of:

let func = function(arg1, arg2, ..., argN) {
	return expression;
};

let's see a concrete example:

let sum = (a, b) => a + b;

which is much shorter than:

let sum = function(a, b) {
	return a + b;
};

alert(sum(1, 2)); as you can see, (a, b) => a + b means a function that accepts two arguments named a and b. upon the execution, it evaluates the expression a + b and returns the results

* if we have only one argument, then the parentheses around parameters can be omitted, making that even shorter.

let double = n => n * 2;
alert( double(3) );

* if there are no arguments, parentheses will be empty (but they should be present):

let sayHi = () => alert("Hello!");
sayHi();

Arrow functions can be used in the same way as function expressions, for instance, to dynamically create a function:

let age = prompt("what is your age?", 18);

let welcome = (age < 18) ?
	() => alert("Hello") :
	() => alert("Greetings!");

welcome();

arrow functions may appear unfamiliar and not very readable at first, but that quickly changes as the eyes get used to the structure. they are very convenient for simple one-line actions when we're just too lazy to write many words

Multiline Arrow Function

the examples abore took arguments from the left of => and evaluates the right-side expression with them.

sometimes we need something a little bit more complex, like multiple expressions or statements. it is also possible, but we should enclose them in curly braces, then use a normal return within them

Like this:

let sum = (a, b) => {
	let result = a + b;
	return result;
};

alert(sum(1,2));

more to come:
here we praised arrow functions for brevity. but that's not all!
arrow functions have other interesting features

To study them in-depth, we fisrt need to get to know some other aspects of JavaScript. We'll return to arrow functions later in the chapter Arrow Functions Revisited.

For now, we can already use arrow functions for one-line actions and callbacks

SUMMARY

arrow functions are handy  for one-liners. they come in two flavors:


1 - without curly braces (... args) => expression - the right side is an expression, the function evaluates it and returns the result.
2 - with curly braces: (... args) => {body} - brackets allow us to write multiple statements inside the function, but we need an explicit return to return something.

############################################################################################

Code Structure

Statements are delimited with a semicolon:

alert('Hello'); alert('World');

usually a line-break is also treated as a delimiter, so that would also work:

alert('hello')
alert('world')

that's called "automatic semicolon insertion". Sometimes it doesnt work, for instance:

alert("There will be an error after this message")
[1, 2].forEach(alert)

most codestyle guides agree that we should put a semicolon after each statement. semicolons are not required after code blocks {...} and syntax constructs with them like loops:

function f() {
	// no semicolon needed after function declaration
}

for(;;) {
	// no semicolon needed after the loop
}

...but even if we can put an 'extra' semicolon somewhere, that's not an error. It will be ignored.

Strict Mode

To fully enable all features of modern JavaScript, we should start scripts with "use strict".
'use strict';

...

the directive must be at the top of a script or at the beginning of a function body. without "use strict", everything still works, but some features behave in the old-fashion, 'compatible' way. we'd generally prefer the modern behavior.

Some modern features of the language (like classes that we'll study in the future) enable strict mode implicitly.

Variables

Can be declared using:

let
const (constant, can't be changed)
var (old-style, will see later)

A variable name can include:

letter and digits, but the first character may not be a digit
characters $ and _ are normal, on par with letters
Non-Latin alphabets and hieroglyphs are also allowed, but commonly not used

Variables are dynamically typed. They can store any value:

let x = 5;
x = "John";

there are 8 data types:

number - for both floating-point and integer numbers
bigint - for integer numbers of arbitrary length
string - for strings
boolean - for logical values true/false
null - a type with a single value null, meaning 'empty' or 'does not exist'
undefined - a type with a single value undefined, meaning 'not assigned'
object and symbol - for complex data structures and unique identifiers, we haven't learnt them yet

the typeof operator returns the type for a value with two exceptions:

typeof null == 'object' // error in the language
typeof function() {} == "function" // functions are treated specially

Interaction

we're using a browser as a working environment, so basic UI functions will be:

prompt(question, [default])

ask a question, and return either what the visitor entered or null if they clicked 'cancel'

confirm(question)

ask a question and suggest to choose Ok and Cancel. The choice is returned as true/false

alert(message)

outputs a message

All these functions are MODAL. they pause the code execution and prevent the visitor from interacting with the page until they answer.

For instance:

let userName = prompt("Your name?", "Alice");
let isTeaWanted = confirm("Do you want some tea?");

alert( "Visitor: " + userName ); // Alice
alert( "Tea wanted: " + isTeaWanted ); //true

Operators

JavaScript supports the following operators:

Arithmetical

Regular: *, +, -, /, also % for the remainder and ** for power of a number

the binary plus + concatenates strings, and if any of the operands is a string, the other one is converted to strong too.

alert( '1' + 2);
alert( 1 + '2');

* assignments

there is a simple assignment: a = b, and combined ones like a*= 2;

* bitwise

bitwise operatores work with 32-bit integers at the lowers. bit-evel: see the docs when they are needed

* conditional

The only operator with three parameters:
cond ? resultA : resultB; if cond is truthy, returns resultA, otherwise resultB

* logical operators

logical AND && and logical OR ||, perform short-circuit evaluation and then return the value where it stopped (not necessary true/false). logical NOT ! converts the operand to boolean type and returns the inverse value.

* nullish coalescing operator

The ?? operator provides a way to choose a defined value from a list of variables. The result of a ?? b is a unless it's null/undefined, then it is b

* comparisons

Equality check == for values of different types converts them to a number (except null and undefined that equal each other and nothing else), so these are equal:

alert(0 == false); //true
alert(0 == ''); //true

Other comparisons convert to a number as well.

The strict equality operator === doesn't do the conversion: different types always mean different values for it

values null and undefined are special: they equal == each other and don't equal anything else.
Greater/less comparisons compare strings char-by-char, other types are converted to a number

Other Operators

there are few others, like a comma operator

LOOPS

we covered 3 types of LOOPS:

while (condition) {
	...
}

do {
	...
} while (condition);

for(let i = 0; i < 10; i++) {
	...
}


the variable declared in for(let...) loop is visible only inside the loop. but we can also omit let and reuse an existing variable

directives break/continue allow to exit the whole loop/current iteration. use labels to break nested loops.

There are other types of loops used to deal with objects.

The Switch Construct

it can replace multiple IF checks, it uses === for comparisons
for instance:

let age = prompt("Your age?", 18);

switch(age){
	case 18:
	alert("won't work!") //prompt returns a string, not a number
	break;

	case "18":
	alert("This works!");
	break;

	default:
	alert("Any value not equal to one above");
}

FUNCTIONS

We covered three ways to create a function in JavaScript:

1. Function Declaration: the function in the main codeflow:

function sum(a, b) {
	let result = a + b;
	return result;
}

2. Function Expression: the function in the context of an expression

let sum = function(a, b) {
	let result = a + b;

	return result;
};

3. Arrow Functions:

//expression at the right side
let sum = (a, b) => a + b;

//multi-line syntax
let sum = (a, b) => {
	return a + b;
}

//without arguments
let sayHi = () => alert("Hello");

//with a single argument
let double = n => n * 2;

Functions may have local variables:those declared inside its body or its parameter list. such variables are only visible inside the function.
parameters can have default values: function sum(a = 1, b = 2) {...}
functions always return something. if there is no return statement, then the result is undefined

############################################################################################

DEBBUGING IN CHROME

before writing complex code, let's talk about debugging. it is the process of finding and fixing errors within a script. All modern browsers and most environments suppoert debugging tools - a special UI in developer tools that makes debugging much easier. it also allows to trace the code step by step, to see what exactly is going on. we'll be using chrome here, because it has enough features, most other browsers haev a similar process.

The 'Sources' Panel

Your chrome version may look a little bit different, but it still should be obvious what's there.

Open the EXAMPLE PAGE in chrome.
Turn on the developer tools with F12
Select the Sources panel

The source panel has 3 parts.

1 - the file navigator pane lists HTML, JavaScript, CSS and other files. including images that are attached to the page. chrome extensions may appear here too.

2 - the code editor pane shows the source code

3 - the JavaScript Debugging pane is for debugging, we will explore it soon.

After selecting a source code, you can close the files tab for some space.

The Console Panel

if we press Esc, then a console opens below. we can type commands there and press ENTER to execute. after a statement is excuted, it results is shown below. for example, here 1+2 results in 3. and hello("debugger") returns nothing, so the result is undefined.

The Breakpoints

Let's examine what's going on within the code of the example page. In hello.js, click at line number 4, ues, right on the 4 digit. not on the code. You've just set a breakpoint. Please also click on the number for line 8.

a breakpoint is a point of code where the debugger will automatically pause the JavaScript execution.

while the code is paused, we can examine current variables, execute commands in the console. in other words, we can debug it.

we can always find a list of brakepoints in the right panel. that's useful when we have many breakpoints in various files. it allows us to:

a) - quickly jump to the breakpoint in the code, by clicking on it in the right panel
b) - temporarily disable the breakpoint by unchecking it
c) - remove the breakpoint by right-clicking and selecting Remove
d) - and so on

"Conditional breakpoints. right click on the line number allows to create conditional breakpoint. it only triggers when the given expression is truthy. that's handy when we need to stop only for a certain variable value or for certain function parameters"

Debugger command

we can also pause the code by using the debugger command in it, like this:

function hello(name) {
	let phrase = `Hello, ${name}!`;

	debugger; // <-- The debugger stops here

	say(phrase);
}

That's very convenient, when we are in a code editor and don't want to switch to the browser and look up the script in developer tools to set the breakpoint.

Pause and Look around

in our example, hello() is called during the page load, so the easiest way to activate the debugger (after we've set the breakpoints) is to reload the page.

1 - Watch - shows current values for any expressions.

You can click the plus + and input an expression. The debugger will show its value at any moment, autmatically recalculating it in the process of execution.

2 - Call Stack - shows the nested calls chain

At the current moment the debugger is inside hello() call, called by a script in index.html (no function there, so it's called "anonymous").

If you click on a stack item (e.g. "anonymous"), the debugger jumps to the corresponding code, and all its variables can be examined as well

3 - Scope - current variables.

Local shows local function variables, you can also see their values highlighted right over the source

Global has global variables (out of any functions).

There's also ThIs keyword there that we didn't study yet, but we will do that soon.


TRACING THE EXECUTION


now it is time to trace the script.

There are buttons for it at the top of the right panel. let's engage them.

|> - "Resume": continue the execution, hotkey F8.

resumes the execution if there are no additional breakpoints,then the execution just continues and the debugger loses control.

Here's what we can see after a click on it:

The execution has resumed, reached another breakpoint inside say() and paused there. Take a loot at the "Call Stack" at the right. it has increased by one more call. we're inside say() now.

-> * "Step": run the next command, hotkey F9

Run the next statement, if we click it now, alert will be shown, clicking this again and again will step through all script statements one by one

-> * "Step Over": run the next command, but don't go into a function, hotkey f10

Similar to the previous "Step" command, but behaves differently if the next statement is a function call, that is: not a built-in, like alert, but a function of our own.

The "step" command goes into it and pauses the execution at its first line, while "step over" executes the nested function call invisibly, skipping the function internals

The execution is then paused immediately after that function.

That's good if we're not interested to see what happens inside the function call.


-> - "Step Into", hotkey F11

That's similar to 'step', but behaves differently in case of asynchronous function calls. If you're only starting to learn JavaScript,  then you can ignore the difference, as we don't have async calls yet.

for the future, just note that step command ignores async actions, such as setTimeout (scheduled function call), that execute later. the 'step into' goes into their code, waiting for them if necessary

-> - "Step Out", hotkey SHIFT + F11

Continue the execution and stop it at the very last line of the current function, that's handy when we accidentally entered a nested call using step,  but it does not interest us, and we want to continue to its end as soon as possible.

-/-> - Enable / Disable all breakpoints

That button does not move the execution, just a mass on / off for breakpoints

|| - enable / disable automatic pause in case of an error.

when enabled, and the developer tools is open, a script error automatically pauses the execution. Then we can analyze variables to see what went wrong. So if our script dies with an error, we can open debugger, enable this option and reload the page to see where it dies and what's the context at that moment

"Continue to here - right click on a line of code opens the context menu with a great option called "Continue to here". that's handy when we want to move multiple steps forward to the line, but we're too lazy to set a breakpoint.

LOGGING

To output something to console from our code there's console.log function
For instance, this outputs values from 0 to 4 to console:

//open console to see

for (let i = 0; i < 5; i++) {
	console.log("value,", i);
}

Regular Users don't see that output, it is in the console. To see it, either open the console panel of developer tools or press ESC while in another panel: that opens the console at the bottom

If we have enough logging in our code, then we can see what's going on from the records, without the debugger.

SUMMARY

As we can see, there are three main ways to pause a script:

1. A breakpoint
2. The debugger Statements
3. An error (if dev tools are open and the button || is 'on')

When paused, we can debug - examine variables and trave the code to see where the execution goes wrong.

There are many more options in developer tools than covered here. The full manual is at developers/google/chrome-devtools

The information from this chapter is enough to begin debugging, but later, especially if you do a lot of browser stuff, please go there and look through more advanced capabilities of developer tools.
Oh, and also you can click at various places of dev tools and just see what's showing up. that's probably the fastest route to learn dev tools. Don't forget about the right click and context menus.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Coding Style

Our code must be as clean and easy to read as possible.

That is actually the art of programming - to take a complex task and code it in a way that is both correct and human-readable. A good code style greatly assists in that.

Syntax

Here is a cheat sheet with some suggested rules (see below for more details)

* no space between the function name and parentheses between the parentheses and the parameter
* a space between parameters
* curly brace { on the same line, after a space
* indentation 2 spaces
* a space after for / if / while
* spaces around operators
* a semicolon ; is mandatory
* a space between arguments
* an empty line between logical blocks
* lines are not very long
* else without a line break '} else {'
* spaces around a nested call

this is a general guideline, let's discuss the rules and reasons for them in detail.

There are no 'you must' rules - nothing is set in stone, those are style preferences, not religious dogmas.

Curly Braces

in most JavaScript projects, curly braces are written in "Egyptian" style with the opening brace on the same line as the corresponding keyword - not on a new line. there should also be a space before the opening bracket, like this:

if (condition) {
	
}

A single-line construct, such as if (condition) doSomething(), is an important edge case. Should we use braces at all?

Here the annotated variants so you can judge their readability for yourself:

>.< Beginners sometimes do that BAD! Curly braces are not needed:
	if (n < 0) {alert(`Power ${n} is not supported`);}

:( Split to separate line without braces. Never do that, easy to make an error when adding new lines:
	if (n < 0)
		alert(`Power ${n} is not supported`);

:| One line without braces - acceptable if it's short:
	if (n < 0) alert(`Power ${n} is not supported`);

:) The best variant:
	if (n < 0) {
		alert(`Power ${n} is not supported`);
	}

for a very brief code, one line is allowed. e.g. if (cond) return null
but a code block is usually more readable.

Line Length

No one likes to read a long horizontal line of code. it's best practice to split them

for example:

//backtik quotes ` allow to split the string into multiple lines

let str = `
    ECMA International 's TC39 is a group of JavaScript developers,
  	implementers, academics, and more, collaborating with the community
 	to maintain and evolve the definition of JavaScript.
`;

Maximum Line Length usually is between 80 and 120 chars.

and, for if statements:

if (
	id === 123 &&
	moonPhase === 'Warning Gibbous' &&
	zodiacSign === 'Libra'	
) {
	letTheSorceryBegin();
}

INDENTS

There are two types of indents:

* Horizontal Indents: 2 or 4 spaces

A horizontal identation is made using either 2 or 4 spaces or the horizontal tab symbol (key Tab). Which one to choose is an old holy war. Spaces are more common nowadays.

One advantage of spaces over tabs is that spaces allow more flexible configurations of indents than the tab symbol.

For instance, we can align the parameters with the opening bracket, like this

show(parameters,
     aligned,
     one,
     after,
     another
  ) {

}

* Vertical Indents

empty lines for splitting code into logical blocks

even a single function can often be divided into logical blocks, in the example below, the initialization of variables, the main loop and returning the result are split vertically:

function pow(x, n) {
	let result = 1;
	// <--
	for (let i = 0; i < n; i++) {
		result *= x;
	}
	// <--
	return result;
}

Inser an extra newline where it helps to make code more readable. There should not be more than nine lines of code without a vertical indentation

SEMICOLONS

A semicolon should be present after each statement, even if it could possibly be skipped. There are languages where a semicolon is truly optional and it is rarely used. In JavaScript, though, there are cases where a line break is not interpreted as a semicolon, leaving the code vulnerable to errors. See more about that in chapter Code Structure

If you are an experienced JavaScript programmer, you may choose a no-semicolon code style like StandardJS. Otherwise, it's best to use semicolons to avoid possible pitfals. The majority of developers put semicolons.

NESTING LEVELS

Try to avoid nesting code too many levels deep.

For example, in the loop, it's sometimes a good idea to use continue directive to avoid extra nesting. For example, instead of adding a nested if conditional like this:

for (let i = 0; i < 10; i++) {
	if(cond) {
		... // one more nesting level
	}
}

We can write:

for (let i = 0; i < 10; i++) {
	if (!cond) continue;
	... // no extra nesting level
}

A similar thing can be done with if/else and return.

Example:

function pow(x, n) {
	if (n < 0) {
		alert("Negative 'n' not supported");
	} else {
		let result = 1;

		for (let i = 0; i < n; i++) {
			result *= x;
		}

		return result;
	}
}

Like this:

function pow(x, n) {
	if (n < 0) {
		alert("Negative 'n' not supported");
		return;
	}

	let result = 1;

	for (let i = 0; 1 < n; i++) {
		result *= x;
	}

	return result;
}

The second one is more readable because the 'special case' of n < 0 is handled early on. Once the check is done we can move on to the 'main' code flow without the need for additional nesting.

FUNCTION PLACEMENT

If you are writing several 'helper' functions and the code that uses them, there are three ways to organize the functions

1 - Declare the functions above the code that uses them:

//function declarations

function createElement() {
	...
}

let elem = createElement();

2 - Code first, then functions

let elem = createElement();

function createElement() {
	...
}

3 - mixed: a function is declared where it's first used.

Most of the time, the second variant is preferred

That's because when reading the code, we first want to know WHAT IT DOES. if the code goes first, then it becomes clear from the start. Then, maybe we won't need to read the functions at all, especially if their names are descripttive of what they actually do.

STYLE GUIDES

A style guide contains general rules about 'how to write' code, e.g. which quotes to use, how many spaces to indent, the maximal line length, etc. A lot of minor things.

when all members of a team use the same style guide, the code looks uniform, regardless of which team member wrote it. Of course, a team can always write their own style guide, but usually there's no need to. There are many existing guides to choose from.

Some popular choices:

Google Java Script Style Guide
Airbnb Javascript Style Guide
IdiomaticJS
StandardJS

If you're a novice developer, start with the cheat sheet at the beginning of this chapter. Then you can browse other style guides to pick up more ideas and decide which one you like best.

AUTOMATED LINTERS

Linters are tools that can automatically check the style of your code and make improving suggestions. The great thing abut them is that style-checking can also find some bugs, like typos in variable or function names. Because of this feature, using a linter is recommended even if you don't want to stick to one particular 'code style'

Here are some well known linting tools.

1 - JSLint
2 - JSHint
3 - ESLint

All of them do the job, the author uses ESLint

Most linters are integrated with many popular editors: just enable the plugin in the editor and configure the style. for instance, for ESLint, you should do the following.

1 - Install Node.js
2 - Install ESLint with the command npm install -g eslint (npm is a JavaScript package installer)
3 - Create a config file named .eslintrc in the root of your JavaScript project (in the folder that contains all your files).
4 - Install/Enable the plugin for your editor that integrates with ESLint. The majority of editors have one.

Here is an example of an .eslintrc file:

{
	"extends": "eslint:recommended",
	"env": {
		"browser": true,
		"node": true,
		"es6": true
	},
	"rules": {
		"no-console": 0,
		"indent": 2
	}
}

Here the directive "extends" denotes that the configuration is based on the "eslint:recommended" set of settings. After that, we specify our own. It is also possible to download style rules sets from the web and extend them instead. Also certain IDEs have built-in linting, which is conveninent but not as customizable as ESLint.

SUMMARY

All syntax rules described in this chapter (and in the style guides referenced) aim to increase the readability of your code. All of them are debatable.

When we thing about writing 'better' code, the questions we should ask ourselves are: "what makes the code more readable and easier to understand?" and "what can help us avoid errors?" These are the main things to keep in mind when choosing and debating code styles.

Reding popular style guides will allow you to keep up to date with the latest ideas about code style trends and best practices

TASK - Make the Below Code Pretty

What’s wrong with the code style below?

function pow(x,n)
{
  let result=1;
  for(let i=0;i<n;i++) {result*=x;}
  return result;
}

let x=prompt("x?",''), n=prompt("n?",'')
if (n<=0)
{
  alert(`Power ${n} is not supported, please enter an integer number greater than zero`);
}
else
{
  alert(pow(x,n))
}

My attempt at code guiding the fucker:

function pow(x, n) {
	let result = 1;
	
	for (let i = 0; i < n; i++) {
		result *= x;
	}

	return result;
}

let x = prompt("x?", "");
let n = prompt("n?", "");
	
	if (n <= 0) {
		alert(`Power ${n} is not supported, please enter an integer number greater than zero`);
	} else {
		alert(pow(x, n));
	}

COMMENTS

as we know from the chapter CODE STRUCTURE, comments can be single-line with // and multiline with /* ... */;

we normally use them to describe how and why the code works.

At first sight, commenting might be obvious, but novices in programming often use them wrongly.

Bad Comments

Novices tend to use comments to explain "what is going on in the code".

Like this:

//This code will do this thing (...) and that thing (...)
//... and who knows what else...

very;
complex;
code;

But in a good code, the amount of such 'explanatory' comments should be minimal. Seriously, the code should be easy to understand without them.

There's a great rule about that: 'if the code is so unclear that it requires a comment, then maybe it should be rewritten instead'.

Recipe: factor out functions

Sometimes it's beneficial to replace a code piece with a function, like here:

function showPrimes(n) {
	nextPrime:
	for (let i = 2; i < n; i ++) {

		// check if i is a prime number <-- this is good commenting
		for (let j = 2; j < i; j++) {
			if (i % j == 0) continue nextPrime;
		}

		alert(i);
	}
}

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Recipe: Create Functions
And if we have a long "code sheet" like this:

// here we add whiskey

for (let i = 0; i < 10; i++) {
  let drop = getWhiskey();
  smell(drop);
  add(drop, glass);
}

// here we add juice

for (let t = 0; t < 3; t++) {
  let tomato = getTomato();
  examine(tomato);
  let juice = press(tomato);
  add(juice, glass);
}

Then it might be a better variant to refactor it into functions like:

addWhiskey(glass);
addJuice(glass);

function addWhiskey(container) {
  for(let i = 0; i < 10; i++) {
    let drop = getWhiskey();
  }
}

function addJuice(container) {
  for (let t = 0; t < 3; t++) {
    let tomato = getTomato();
  }
}

Once again, functions themselves tell what is going on. There is nothing to comment
and also the code structure is better when split. it's clear what every functions does,
what it takes and what it returns.

In reality, we can't totally avoid "explanatory" comments. There are complex
algorithms. And there are smart "tweaks" for purpose of optimization. But genereally
we should try to keep the code simple and self-descriptive.

GOOD COMMENTS

So, explanatory comments are usually bad. Which comments are good?

# Describe the Architecture #

Provide a high-level overview of components. How they interact, whats the control
flow in various situations.. In short - the bird's eye view of the code. There's
a special language UML to build high-level architecture diagrams explaining they
code. Definitely worth studying.

# Document Function Parameters and Usage #

There's a special syntax JSDoc to document a function: usage, parameters, returned value.

For Instance:

/**
 * Returns x raised to the n-th power.
 *
 * @param {number} x The number to raise.
 * @param {number} n The power, must be a natural number.
 * @return {number} x raised to the n-th power
 */

 function pow(x, n) {
  ...
 }

 Such comments allow us to understand the purpose of the function and use it right
 way without looking in its code. By the way, many editors like WebStorm can understand
 them as well and use them to provide autocomplete and some automatic code-checking
 Also, there are tools like JSDoc 3 that can generate HTML-documentation from comments.
 You can read more information on USEJSDOC.

 # Why is the Task Solved This Way? #

 What's written is important. But what's not written may be even more important
 to understand what's going on. Why is the task solved exactly this way? The code
 gives no answer.

 IF there are many ways to solve the task, why this one? Especially when it's not
 the most obvious one.

 Without such comments, the follow situation is possible:

 1. you (or your colleague) open the code written some time ago, and see that it
 is 'suboptimal'
 2. You think "How stupid I was then, and how much smarter I'm now", and rewrite
 using the 'more obvious and correct' variant
 3. ... The urge to rewrite was good. But in the process you see that the 'more
 obvious' solution is actually lacking. You even dimly remember why, because you
 already tried it long ago. You revert to the correct variant, but the time was wasted

 Comments that explain the solution are very important. They help to continue
 development the right way.

 # Any Subtle Features Of The Code? Where they are used? #

 If the code has anything subtle and counter-intuitive, it's definitely worth commenting.

 SUMMARY

 An important sign of a good developer is comments: their presence and even
 their absence.

 Good comments allow us to maintain the code well, come back to it after a delay
 and use it more effectively.

 Comment this:

  * Overall architecture, high-level review
  * Function Usage
  * Important solutions, especially when not immediately obvious

 Avoid Comments:

  * That tell 'how the code works' and 'what it does'
  * Put them in only if it is impossible to make the code so simple and self-descriptive
  that it doesn't require them.

 Comments are also used for auto-documenting tools like JSDoc3: they read them and
 generate HTML-docs (or docs in another format).

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Why we need tests?

When we write a function, we can usually imagine what it should do:
which parameters give which results.

During development, we can check the function by running it and comparing the
outcome with the expected one. For instance, we can do it in the console.

If something is wrong - then we fix the code, run again, check the result - and
so on till it works. But such manual 're-runs' are imperfect.

*When Testing a Code by Manual Re-Runs, it's easy to miss something*

For instance, we're creating a function f. Wrote some code, testing: f(1) works
but f(2) doesn't work. We fix the code and now f(2) works. Looks complete? But we
forgot to re-test f(1). That may lead to an error.

That's very typicall. When we develop something, we keep a lot of possible use
cases in mind. But it's hard to expect a programmer to check all of them manually
after every change. So it becomes easy to fix one thing and break another one.

*Automated testing means that tests are written separately, in addition to
the code. They run our functions in various ways and compare results with the
expected*

# Behavior Driven Development (BDD) #

Let's start with a technique named BEHAVIOR DRIVEN DEVELOPMENT, or, in short, BDD.

Bdd is three things in one. tests and documentation and examples. Let's examine
a practical case of development.

DEVELOPMENT OF POW: THE SPEC

Let's say we want to make a function pow(x, n) that raises x to an integer power n.
We assume that n >= 0;

That task is just an example. There's the ** operator in JavaScript that can do
that, but here we concentrate on the development flow that can be applied to
more complex tasks as well. before creating the code of POW, we can imagine what
the function should do and describe it. Such description is called a specification
or, in short, a spec, and contains descriptions of use cases together with tests
for them, like this:

describe("pow", function() {

  it("raises to n-th power", function() {
    assert.equal(pow(2, 3), 8);
  )};

});

a spec has three main building blocks that you can see above:

describe("title", function() {...})
what functionality we're describing. IN our case, we're describing the function POW.
Used to grouo 'workers' - the IT blocks

it("use case description", function() {...})
In the title of IT we in a 'human-readeable way' describe the particular use case,
and the second argument is a function that tests it

assert.equal(value1, value2)
The code inside it block, if the implementation is correct, should execute without errors.

Function assert.* are used to check whether pow works as expected. Right here we're
using one of them - assert.equal, it compares arguments and yields an error if they
are not equal. Here, it checks that the result of pow(2, 3) equals 8. There are other
types of comparisons and checks, that we'll add later.

the specification can be executed and it will run the test specified in IT block.
We'll see that later.

THE DEVELOPMENT FLOW

The flow usually looks like this.

1. An initial spec is written, with testes for the most basic functionality
2. An initial implementation is created
3. To check wether it works, we run the testing framework MOCHA (more details soon)
that runs the spec. WHile the functionality is not complete, errors are displayed.
We make corrections until everything works.
4. Now we have a working initial implementation with tests.
5. WE add more use cases to the spec, probably not yet supported by the implementations.
Tests start to fail.
6. Go to 3, update the implementation till tests give no errors.
7. Repeat steps 3-6 till the functionality is ready.

So, the development is iterative. We write the spec, implement it, make sure Tests
pass, then write more tests, make sure they work etc. At the end we have both a
working implementation and tests for it.

Let's see this development flow in our practical case.

The first step is already complete: we have an initial spec for POW. Now, before
making the implementation, let's use few JavaScript libraries to run the tests, just
to see that they are working (they will all fail)

THE SPEC IN ACTION

Here in the tutorial, we'll be using the following JavaScript libraries for tests:

Mocha - the core framework: it provides common testing functions including Describe
and IT and the main function that run TESTS.
Chai - the library with many assertions. IT allows us to use a lot of different assertions,
for now we need only assert.equal.
Sinon - a library to spy over functions, emulate built-in functions and more. We'll need it
much later.

There libraries are suitable for both in-browser and server-side testing. Here we'll
consider the browser variant. THe full HTML page with these frameworks and pow spec:

! THIS WILL START THE HTML CODE !

<!DOCTYPE html>
<html>
<head>
  <!-- add mocha css, to show results -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.css">
  <!-- add mocha framework code -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.js"></script>
  <script>
    mocha.setup('bdd'); //minimal setup
  </script>
  <!-- add chai -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js"></script>
  <script>
    // chai has a lot of stuff, let's make assert global
    let assert = chai.assert;
  </script>
 </head>

 <body>

    <script>
      function pow(x, n) {
        /* function code is to be written, empty now */
      }
    </script>

 <!-- the script with tests (describe, it...) -->
 <script src="test.js"></script>

 <!-- the element with id="mocha" will contain test results -->
 <div id="mocha"></div>

 <!-- run tests! -->
 <script>
    mocha.run();
 </body>

 </html>

This page can be divided into five parts:

1. The <head> - add third-party libraries and styles for tests.
2. The <script> with the function to test, in our case - with the code for pow.
3. The tests - in our case an external script test.js that has describe("pow", ...) from above
4. The HTML element <div id="mocha"> will be used by Mocha to output results.
5. The tests are started by command mocha.run().

as of now, the test fails, there's an error. That's logical: we have an empty
function code in pow, so pow(2, 3) returns undefined instead of 8.

For the future, let's note that there are more high-level test-runners, like karma
and others, that make it easy to autorun many different tests.

INITIAL IMPLEMENTATION

Let's make a simple implementation of pow, for tests to pass:

function pow(x, n) {
  return 8; // :) we cheat!
}

POW - Raises to the n-th power

Improving the SPEC

What we've done is definitely a cheat. The function does not work; an attempt to
calculate pow(3, 4) would give an incorrect result, but tests pass.

...But the situation is quite typical, it happens in practice. Tests pass, but the
function works wrong. Our spec is imperfect. We need to add more uses cases to it.

Let's add one more test to check that pow(3, 4) = 81.

We can select one of two ways to organize the teste here:

1. The first variant - add one more assert into the same it:

describe("pow", function() {

  it("raises to n-th power", function() {
    assert.equal(pow(2, 3), 8);
    assert.equal(pow(3, 4), 81);
  });
});

2. The second variant - make two tests:

describe("pow", function() {

  it("2 raised to power 3 is 8", function() {
    assert.equal(pow(2, 3), 8);
  });
  it("3 raised to power 4 is 81", function() {
    assert.equal(pow(3, 4), 81);
  });
});

The principal difference is that when assert triggers an error, the IT block
immediately terminates. So, in the first variant if the first assert fails, then
we'll never see the result of second assert.

The second variant is better because it is useful to get more information about
what's going on, so the second variant is better.

And besides that, there's one more rule that's good to follow.

One Test Checks One Thing

If we look at the test and see two independent checks in it, it's better to split
it into two simpler ones.

So let's continue with the second variant.

The result:

POW
2 raised to power 3 is 8
3 raised to power 4 is 81

AssertionError: expected 8 to equal 81 at Context.<anonymous> (test.js:8:12)

As we could expect, the second test failed. Sure, our function always returns 8,
while the assert expects 81.

IMPROVING THE IMPLEMENTATION

let's write something more real for tests to pass:

function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }
  return result;
}

to be sure that the function works well, let's test it for more values, instead
of writing it blocks manually, we can generate them in for:

describe("pow", function() {

  function makeTest(x) {
    let expected = x * x * x;
    it(`${x} in the power 3 is ${expected}`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }
});

THE result

POW - 1 in the power 3 is 1
    - 2 in the power 3 is 8
    - 3 in the power 3 is 27
    - 4 in the power 3 is 64
    - 5 in the power 3 is 125

NESTED DESCRIBE

We're  going to add even more tests. But before that let's note that the helper function
makeTest and for should be grouped together. We won't need makeTest in other tests, it's
needed only in for: their common tasks is to check pow raises into the given power.

Grouping is Done with a nested describe:

describe("pow", function() {

  describe("raises x to power 3", function() {

    function makeTest(x) {
      let expected = x * x * x;
      it(`${x} in the power 3 is ${expected}`, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (let x = 1; x <= 5; x++) {
      makeTest(x);
    }
  });

  // ... more tests to follow here, both describe and it can be added
});

The nested describe defines a new "subgroup" of tests. In the output we can see
the titled identation:

POW - raises x to power 3
1 - in the power 3 is 1
2 - in the power 3 is 8
3 - in the power 3 is 27
4 - in the power 3 is 64
5 - in the power 3 is 125

  assert.equal(pow(x, 3), expected);

In the future we can add more it and describe on the top level with helper Functions
on their own, they won't see makeTest.

before/after and beforeEach/afterEach

we can setup before/after functions that execute before/after running tests, and
also beforeEach/afterEach functions that execute before/after EVERY it.

for instance:

describe("test", function() {

  before(() => alert("Testing started - before all tests"));
  after(() => alert("Testing finished - after all tests"));

  beforeEach(() => alert("Before a test - enter a test"));
  afterEach(() => alert("After a test - exit a test"));

  it("test 1", () => alert(1));
  it("test 2", () => alert(2));
});

This way the running sequence will be:

Testing Started - Before all tests (before)
Before a test - enter a test (beforeEach)
1
After a test - exit a test (afterEach)
Before a test - enter a test (beforeEach)
2
After a test - exit a test (afterEach)
Testing Finished - After all tests (after)

Usually, beforeEach/afterEach and before/after are used to perform initialization,
zero out counters or so something else between the tests (or test groups).

Extending the SPEC
The basic functionality of POW is complete. The first iteration of the DEVELOPMENT is done
when we're done celebrating and drinking champagne - let's go on and improve it

as it was said, the function pow(x, n) is meant to work with positive integer values n.

To indicate a mathenmatical error, javaScript functions usually return NaN. Let's do
the same for invalid values of N

Let's first add the behavior to the spec(!):

describe("pow", function() {

  it("for negative n the result is NaN", function() {
    assert.isNan(pow(2, -1));
  });

  it("for non-integer n the result is NaN", function() {
    assert.isNaN(pow(2, 1.5));
  });
});

The result of the tests:

POW - x if n is negative, the result is isNaN
    AssertionError: expected 1 to be NaN
      at Function.assert.isNan (https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js:2594:35)
      at Context.<anonymous> (test.js:19:12)

    - x if n is not integer, the result is NaN
    AssertionError: expected 4 to be NaN
      at Function.assert.isNan (https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js:2594:35)
      at Context.<anonymous> (test.js:19:12)

    - raises x to power 3
    1 - in the power 3 is 1
    2 - in the power 3 is 8
    3 - in the power 3 is 27
    4 - in the power 3 is 64
    5 - in the power 2 is 125

The newly added tests fail because our implementation does not support them. That's how
BDD is done. FIrst we write failing tests, and then make an implementation for them

! Other assertions
Please not the assertion assert.isNan: it checks for NaN

There are other assertions is Chai as well, for instance:

* assert.equal(value1, value2) - checks the equality value1 == value2.
* assert.strictEqual(value1, value2) - checks the strict equality value1 === value2.
* assert.notEqual, assert.notStrictEqual - inverse checks to the ones above
* assert.isTrue(value) - checks that value === true
* assert.isFalse(value) - checks that value === false

... there is a full list in the docs

in order for the tests to work we need to add a few lines to POW:

function pow(x, n) {
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

Now it works, as all tests will pass:

POW - if n is negative, the result is NaN
    - if n is not integer, the result is NaN
    Raises X to the power 3
    1 - in the power 3 is 1
    2 - in the power 3 is 8
    3 - in the power 3 is 27
    4 - in the power 3 is 64
    5 - in the power 3 is 125

SUMMARY

In BDD, the spec goes first, followed by implementation. At the end we have both
the spec and the code.

The spec can be used in three ways:

1.As Tests - they guarantee that the code works correctly.
2.As Docs - the titles of describe and it tell what the function does.
3.As Examples - the tests are actually working examples showing how function can be used

With the spec, we can safely improve, change, even rewrite the function from scratch
and make sure it still works right.

That's especially important in large projects when a function is used in many places.
When we change such a function, there's just no way to manually check if every places
that uses it still works right.

Without tests, people have two ways:

1. To perform the chance, no matter what. And then our users meet bugs, as we
probably fail to check something manually
2. Or, if the punishment for errors ir harsh, as there are no tests, people become
afraid to modify such functions, and then the code becomes outdated, no one wants to
get into it. Not good for development.

Automatic Testing Helps To AVoid These Problems!

If the project is covered with tests, there's just no such a problem. After any
changes we can run tests and see a lot of checks made in a matter of seconds.

BESIDES, a well-tested code has better architecture.

Naturally, that's because auto-tested code is easier to modify and improve. but
ther's also another reason.

To write tests, the code should be organized in such a way that every function har
a clearly described task, well-defined input and output. That means a good architecture
from the beginning.

In real life, that's sometimes not that easy. Sometimes it's difficult to write a
spec before the actual code, because it's not yet clear how it should behave. But
in general writing tests makes development faster and more stable.

Later in the tutorial you will meet many tasks with tests baked-inn. So you'll
see more practical examples. Writing tests requires good JavaScript knowledge, but we're
just starting to learn it. So, to settle down everything, as of now you're not required
to write tests, but you should already be able to read them even if they are a little
bit more complex than in this champter.

TASK - WHAT's WRONG IN THE TEST?

it("raises x to the power n", function(){
  let x = 5;

  let result = x;
  assert.equal(pow(x, 1), result);

  result *= x;
  assert.equal(pow(x, 2), result);

  result *= x;
  assert.equal(pow(x, 3), result);
});

The test demonstrates one of the temptations a developer meets when writing tests.
what we have here is actually 3 tests, but layed out as single function with 3 asserts.

sometimes it's easier to write this way, but if an error occurs, it's much less
obvious whaat went wrong.

if an error happens in the middle of a complex execution flow, then we'll have to
figure out the data at that point. We'll actualy have to DEBUG the test.

It would be much better to break the thest into multiple IT blocks with clearly
written inputs and outputs.

Like This:

describe("Raises x to power n", function() {
  it("5 in the power of 1 equals 5", function() {
    assert.equal(pow(5, 1), 5);
  });

  it("5 in the power of 2 equals 25", function() {
    assert.equal(pow(5, 2), 25);
  });

  it("5 in the power of 2 equals 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});

We replaced a single it with describe and a group of IT blocks. Now if something
fails we would see clearly what the data was.

Also we can isolate a single test and run it standalone mode by writhing it.only
instead of it:

describe("Raises x to power n", funtion() {
  it("5 in the power of 1 equals 5", function() {
    assert.equal(pow(5, 1), 5);
  });
  //MOCHA WILL RUN ONLY THIS BLOCK
  it.only("5 in the power of 2 equals 25", function() {
    assert.equal(pow(5, 2), 25);
  });

  it("5 in the power of 3 equals 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});

################################################################################

POLYFILLS AND TRANSPILERS

The JavaScript language steadily evolves. New proposals to the language appear
regularly, they are analyzed and, if considered worthy, are appended to the list
at the ECMA website, and then progress to the specification

Teams behind JavaScript engines have their own ideas about what to implement FIrst
they may decide to implement proposals that are in draft and postpone things That
are already in the spec, because they are less interesting or just harder to do

So it's quite commom for an anegine to implement only the part of the standard.
A good page to see the current state of support for language features is:

https://kangax.github.io/compat-table/es6

as programmers, we'd like to use most recent features. The more good stuff the better.

On the other hand, now to make our modern code work on older engines that don't
understand recent features yet?

There are two tools for that:

1. TRANSPILERS
2. POLYFILLS
Here in this chapter, our purpose is to get the gist of how they work and their
place in web DEVELOPMENT

TRANSPILERS

A transpiler is a special piece of software that can parse ("read and understand")
modern code, and rewrite it using older syntax constructs, so that the result
would be the same.

E.g. JavaScript before year 2020 didn't have the "nullish coalescing operator" ??
So, if a visitor uses an outdated browser, it may fail to understand the code:

height = height ?? 100.

a transpiler would analyze our code and rewrite height ?? 100 into:

(height !== undefined && height !== null) ? height : 100;

now the rewritten code is suitable for older JavaScript engines.

Usually, a developer runs the transpiler on their own computer, and then deploys
the transpiled code to the server.

Speaking of names, Babel is one of the most prominent transpilers out there.

Modern project build systems, such as webpack, provide means to run transpilers
automatically on every code change, so it's very easy to integrate into
development process.

POLYFILLS

New language features may include not only syntax constructs and operators, But
also built-in functions.

For example, Math.trunc(n) is a function that "cuts off" the decimal part of
a number, e.g:

Math.trunc(1.23) = 1

In some (very outdated) JavaScript engines, there's no Math.trunc, so, such code
will fail.

As we're talking about new functions, not syntax changes, there's no need to
transpile anything here. We just need to declare the missing function.

A script that updates/adds new functions is called "polyfill". It "fills in" the
gap and adds missing implementations.

For this particular case, the polyfill for Math.trunc is a cript that implements it:

if (!Math.trunc) {
  //implement it
  Math.trunc = function(number) {
  // math.ceil and math.floor existe even in ancient Js engines
  //they are covered later in the tutorial
  return number < 0 ? Math.ceil(number) : Math.floor(number);
  };
}

JS is a highly dynamic language, scripts may add/modify any functions, even
including built-in ones.

Two interesting libraries of polyfulls are:

* core.js that supports a lot, allows us to include only needed Features
* polyfill.io service that provides scripts with polyfills, depending on the
features and user's browser.

SUMMARY

In this chapter we'd like to motivate you to study modern and even "Bleeding-edge"
language features. even if they aren't yet well-supported by JavaScript engines.

Just don't forget to use a tarnspiler (if using modern syntax or operatores) and
polyfils (to add funtions that may be missing). And they'll ensure that the code works.

For example, later when you're familiar with JS, you can setup a code build system
based on webpack with babel-loader plugin.

more info: https://caniuse.com/ - for browser related Functions

P.S. Google Chrome is usually the most up-to-date with language features,
try it if a tutorial demo fails.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

OBJECTS!

As we know from the chapter Data Types, there are eight data types in javaScript
seven of them are called primitive, because their values contain only a single
thing (be it a string or a number or whatever).

In contrast, objects are used to stroe keyed collections of various data and more
complex entities. In JavaScript, objects penetrate almost every aspect of the
language. So we must understand them first before going in-depth anywhere else.

An object can be created with figure brackets {...} with an optional list of
properties. a property is a "key: value" pair, where key is a string (also called
a "Property name"), and value can be anything.

we can imagine an object as a cabinet with signed files. Every piece of data is
stored in its file by the key. It's easy to find a file by its name or add/remove a file

an empty object ("empty cabinet") can be created using one of two syntaxes;

let user = new Object(); // "object constructor" syntax
let user = {} ;; "Object literal" syntax

usually the figure brackets {...} are used. That declaration is called an object literal

we can immediately put some properties into {...} as "key:value" pairs;

let user = {
  name: "John",
  age: 30
};

A property has a key (also known as "name" or "identifier") before the colon ":"
and a value to the right of it.

In the USER object, there are two properties:

1. The first property has the name "name" and the value "John".
2. The second one has the name "age" and the value 30.

The resulting user object can be imagined as a cabinet with two signed files
labeled "name" and "age"

we can add, remove and read files from it any time.

Property values are accessible using the dot notation:

//get property values of the object:
alert( user.name ); //John
alert( user.age ); //30

The value can be of any type. Let's add a boolean one:

The value can be of any type. Let's add a boolean one:

user.isAdmin = true;

user = {
  name: "John",
  age: 30,
  isAdmin: true
}

to remove a property we can use the delete operator:

delete user.age;

user = {
  name: "John",
  isAdmin: true
}

We can also use multiword property names, but then they must be quoted:

let user = {
  name: "John",
  age: 30,
  "likes birds": true //multiword property name must be quoted
};

The last property in the list may end with a comma:

let user = {
  name: "John",
  age: 30
}

That is called a "trailling" or "hanging" comma. Makes it easier to add/remove/move
around properties, because all lines become alike.

Square Brackets notation
For multiword properties, the dot access doesn't work:

// this would give a syntax errors
user.likes birds = true;

JavaScript doesnt understand that. it thinks that we address user.likes, and then
gives a syntax error when comes across unexpected BIRDS.
The dot requires the key to be a valid variable identifier. That implies:
contains no spaces, doesnt start with a digit and doesnt include special characters
( $ and _ are allowed)

There is an alternative "square bracket notation" that works with any string:

let user = {};

//set
user["likes birds"] = true;

//get
alert(user["likes birds"]); //true

//delete
delete user["likes birds"];

Now everything is fine. Please note that the string inside the brackets is properly
quoted (any type of quotes will do)

square brackets also provide a way to obtain the property name as the result of
any expression - as opposed to a literal string - like from a variable as follows:

let key = "likes birds";

user[key] = true;

Here the variable KEY may be caculated at run-time or depend on the user input.
And then we use it to access the property. That gives us a great deal of flexibility.

For instance:

let user = {
  name: "John",
  age: 30
};

let key = prompt("What do you want to know about the user?", "name");

//acess by variable

alert( user[key] ); // John (if enter "name")

The dot notation cannot be used in a similar way:

let user = {
  name: "John",
  age: 30
};

let key = "name";
alert( user.key ) // undefined

Computed Properties

We can use square brackets in an object literal, when creating an object. That's
called 'computed properties'.

For instance:

let fruit = prompt("which fruit to buy?", "apple");

let bag = {
  [fruit]: 5,
};

alert( bag.apple ); //5 if fruit="apple"

The meaning of a computed property is simple: [fruit] means that the property name
should be taken from fruit.

So, if a visitor enters "apple", bag will become {apple: 5}.

Essentially, that works the same as:

let fruit = prompt("Which fruit to buy?", "apple");
let bag = {};

//take property name from the fruit variable
bag[fruit] = 5;

... but looks nicer.

We can use more complex expressions inside square brackets:

let fruit = 'apple';
let bag = {
  [fruit + "Computers"]: 5 //bad.appleComputers = 5
};

Square Brackets are much more powerful than the dot notation. They allow any
property names and variables. But they are also more cumbersome to write.

So most of the time, when property names are known and simple, the dot is used.
And if we need something more complex, then we switch to square brackets.

Property Value Shorthand

in real code we often use existing variables as values for property names

for instance:

function makeUser(name, age) {
	return {
		name: name,
		age: age,
		// ...other properties
	};
}

let user = makeUser("John", 30);
alert(user.name); //John

in the example above, properties have the same name as variables. the use-case of making a property from a variable is so common, that there's a special property value shorthand to make it shorter.

instead of name: name, we can just write name, like this:

function makeUser(name, age) {
	return {
		name,
		age,
		// ...
	}
}

we can use both normal properties shorthands in the same object:

let user = {
	name, // same as name:name
	age: 30
}

PROPERTY NAMES LIMITATIONS

As we already know, a variable cannot have a name equal to one of language-reserverd words like "for", "let", "return" etc

but for an object property, there is no such restriction:

// these properties are all right

let obj = {
	for: 1,
	let: 2,
	return: 3
};

alert( obj.for + obj.let + obj.return); //6

in short, there are no limitations on property names. they can be any string or symbol (a special type for identifiers, to be covered later).

Other types are automatically converted to strings.

For instance, a number 0 becomes a string "0" when used as a property key:

let obj = {
	0: "test" // same as "0": "test"
}

//both alerts access the same property:

alert( obj["0"] );
alert( obj[0] );

there's a minot gotcha with a special property named __proto__. We can't set it to a non-object value:

let obj = {};
obj.__proto__ = 5 //assign a number
alert(obj.__proto__); //the value is still a object, didnt work

as we see from the code, the assignment to a primitive 5 is ignored.
we'll cover the special nature of __proto__ in subsequent chapters, and suggest the ways to fix such behavior.

PROPERTY EXISTENCE TEST, "IN" OPERATOR

A notable feature of objects in JavaScript, compared to many other languages, is that it's possible to access any property. There will be no error if the property doesnt exist!

reading a non-existing property just returns 'undefined'. so we can easily test wether the 
property exists:

let user = {};
alert( user.noSuchProperty === undefined); //true means "no such property"

there is also a special operator "in" for that

The syntax is:

"key" in object

for instance:

let user = {name: "John", age:30};

alert( "age" in user ); // true, user.age exists
alert( "blabla" in user ); //false, user.blabla does not exist

please note that on the left side of in there must be a PROPERTY NAME. that's usually a quoted string.

if we omit quotes, that means a variabla, it should contain the actual name to be tested. for instance:

let user = { age:30 };

let key = "age";
alert( key in user ); //true, property 'age' exists, because we created a key for it

why does the in operator exist? isn't it enough to compare against undefined?
well, most of the time the comparisonwith undefined works fine, but there is a special case
when it fails, but "in" works correctly.

it's when an object property exists, but, stores 'undefined':

let obj = {
	test: undefined
};

alert( obj.test ); //it is undefined, so, no such propety?
alert( "test" in obj ); // true

in the code above, the property obj.test technically exists. So the in operator works right.

Situations like this happen very rarely, because undefined should not be explicitly assigned.
we mostly use 'null' for 'unknown' or 'empty' values. so the in operator is an exotic guest

the "FOR IN" loop

to walk over all keys of an object, there exists a special form of the loop:
for .... in, this is a completely different thing from the for(;;) construct that we studied
before

The syntax:

for (key in object) {
	//executes the body for each key among the object
}

for instance, let's output all properties of user:

let user = {
	name: "John",
	age: 30,
	isAdmin: true
};

for (let key in user) {
	//keys
	alert( key );
	//values for the keys
	alert( user[key] );
}

not that all 'for' construct allow us to declare the looping variable inside the loop, like
let key here

also, we could use another variable name here instead of key, for instance, "for (let prop in obj)" is also widely used.

ORDERED LIKE AN OBJECT

Are objects ordered? in other words, if we loop over an object, do we get all properties in the same order they were added? can we rely on this?

the short answer is: "ordered in a special fashion": integer properties are sorted, others appear in creation order. The details follow.

As an example, let's consider an object with the phone codes:

let codes = {
	"49" : "Germany",
	"41" : "Switzerland",
	"44" : "Great Britain",
	// ..,
	"1": "USA"
};

for (let code in codes) {
	alert(code); //1, 41, 44, 49
}

The object may be used to suggest a list of options to the user. If we're making a site mainly for German audience, then we propably want "49" to be the first.

But if we run the code, we see a totally different picture:

USA(1) goes first
then Switzerland (41) and so on

The phone codes go in the ascending sorted order, because they are integers, so we see 1, 41, 44 and 49

integer properties? what's that?

the 'interger property' term here means a string that can be converted to-and-from an integer without a change. so "49" is an integer property name, because when it's transformed to an integer number and back it's still the same. but "+49" and "1.2" are not

on the other hand, if the keys are non-integer, then they are listed in the creation order, for instance:

let user = {
	name: "John",
	surname: "Smith"
};

user.age = 25;

for (let prop in user) {
	alert( prop ); // name, surname, age
}

Always in the order of creation.

So, to fix the issue with phone codes, we can 'cheat' by making the codes non-integer. Adding a plus "+" sign before each code is enough.

S U M M A R Y

Objects are associative arrays with several special features.

They store properties (key-value pairs), where:

* property keys must be strings or symbols (usually strings)
* values can be of any type

To acess a property we can use:

* the dot notation: obj.property.
* square brackets notation obj["property"]. Square brackets allow to take the key from a variable, like obj[varWithKey]

Additional operatores:

* To delete a property: delete obj.prop
* to check if a property with given key exists: "key" in obj
* to iterate over an object: for (let key in obj) loop

What've studied in this chapter is called a 'plain object', or just 'Object'

There are many other kinds of objects in JavaScript:

* Array to store ordered data collections
* Date to store the information about date and time
* Error to store the information about an error
* ...And so on.

They have their special features that we'll study later. sometimes people say something
like "array type" or "data type", but formally they are not types of their own, but belong
to a single "object" data type. And they extend it in various ways.

Objects in JavaScript are very powerful. Here we've just scratched the surface of a topic that is really huge. We'll be closely working with objects and learning more about them in
further parts of this tutorial.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Object References And Copying

One of the fundamental differences of objects versus primitives is that objects are stored
and copied "by reference", whereas primitive values: strings, numbers, booleans, etc - are 
always copied "as a whole value".

That's easy to understand if we look a bit under the hood of what happens when we copy a value

let's start with a primitive, such as a string
Here we put a copy of message into phrase:

let message = "Hello!";
let phrase = message;

As a result we have two independent variables, each one storing the string "Hello!".

now we have two variables: message and phrase
both with the "Hello!" value

BUT Objects are not like that.

A variable assigned to an object stores not the object itself, but its "address in memory" - 
in other words "a reference" to it.

Let's look at an example of such variable:

let user = {
	name: "John"
};

the object is stored somewhere in memory (at the right of the picture), while the user variable (at the left) has a "reference" to it.

We may think of an object variable, such as user, as like a sheet of paper with the address of the object on it.

when we perform actions with the object, e.g. take a property user.name, the JavaScript engine looks at what's at that address and performs the operation on the actual object.

Now here's why it's important:

When an object variable is copied, the reference is copied, but the object itself is not duplicated.

For instance:

let user = { name: "John" };

let admin = user; //copy the reference

Now we have two variables, each storing a reference to the same object.
As you can see, there's still one object, but now with two variable that reference to it.

We can use either variable to access the object and modify its contents:

let user = { name: 'John' };
let admin = user;

admin.name = 'Pete'; // changed by the "admin" reference

alert(user.name); // 'Pete', changes are seen from the "user" reference

it's as if we had a cabinet with two keys and used one of them (admin) to get into it and make
changes. Then, if we later use another key (user), we are still opening the same cabinet and can access the changed contents.

COMPARISON BY REFERENCE

Two objects are equal only if they are the same object. For instance, here a and b reference the same object, thus they are equal:

let a = {};
let b = a; // copy the reference

alert(a == b); // true
alert(a === b); // true

and here two independent objects are not equal, even though they look alike (both are empty):

let a = {};
let b = {};

alert( a == b ); //false

for comparisons like obj1 > obj2 or for a comparison against a primitive obj == 5, objects are converted to primitives. We'll study how object conversions work very soon, but to tell the truth, such comparisons are needed very very rarely,  usually they appear as a result of a programming mistake.

CLONING AND MERGING, OBJECT.ASSIGN()

So, cpying an object variable creates one more reference to the same object. But what if we need to duplicate an object? Create an independent copy, a clone?

That's also doable, but a little bit more difficult, because there's no built-ni method for that in JavaScript. But there is rarely a need - copying by reference is good most of the time

But if we really want that, then we need to create a new object and replicate the structure of the existing one by iterating over its properties and copying them on the primitive level.

Like This:

let user = {
	name: "John",
	age: 30
};

let clone = {}; // the new empty object

//let's copy all user properties into it
for (let key in user) {
	clone[key] = user[key];
}

clone.name = "Pete"
alert(user.name); //still John

as we can use the method Object.assign for that:

The syntax is:

Object.assign(dest, [src1, src2, src3...])

* The first argument dest is a target object.
* Further arguments src1, ..., srcN (can be as many as needed) are source objects
* It copies the properties of all source objects src1, ..., srcN into the target dest. In other words, properties of all arguments starting from the second are copied into the first object.
* The call returns dest.

For instance, we can use it to merge several objects into one:

let user = { name: "John" };

let permissions1 = {canView: true};
let permissions2 = {canEdit: true};

//copies all oproerties from permissions 1 and permissions 2 to the user object

Object.assign(user, permissions1, permissions2);

//now user = { name: "John", canView: true, canEdit: true}

If the copied property name already exists, it gets overwritten:

let user = { name: "John" };
Object.assign(user, { name: "Pete" });
alert(user.name); // now user = { name: "Pete" }

We also can use Object.assign to replace for..in loop for simple cloning:

let user = {
	name: "John",
	age: 30
};

let clone = Object.assign({}, user) //shorter syntax, fills the newly created clone object

It copies all properties of user into the empty object and returns it.

There are also other methods of cloning an object, e.g. using the spread syntax clone = {...user}, covered later in the tutorial

NESTED CLONING

Until now we assumed that all properties of user are primitive. But properties can be references to other objects. What to do with them?

Like This:

let user = {
	name: "John",
	sizes: {
		height: 182,
		width: 50
	}
};

alert( user.sizes.height ); // 182

now it's not enough to copy clone.sizes = user.sizes, because the user.sizes is an object, it
will be copied by reference. So clone and user will share the same sizes

let user = {
	name: "John",
	sizes: {
		height: 182,
		width: 50
	}
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); //true, same object

// user and clone share sizes
user.sizes.width++; //change a property from one place
alert(clone.sizes.width); //51, see the result from the other one

To fix that, we should use a cloning loop that examines each value of user[key] and, if it's an object, then replicate its structure as well. That is called a "deep cloning".

We can use recursion to implement it. Or, to not reinvent the wheel, take an existing implementation, for instance _.cloneDeep(obj) from the JavaScript library lodash.

CONST OBJECTS CAN BE MODIFIED

An important side effect of storing objects as references is that an object declared as CONST can be modified. For instance:

const user = {
	name: "John"
};

user.name = "Pete"; //(*)
alert(user.name); // Pete

It might seem that the line (*) would cause an error, but it does not. The value of user is constant, it must always reference the same object, but properties of that object are free to change.

In other words, the const user gives an error only if we try to set user = ... as a whole.

That said, if we really need to make constant object properties, it's also possible, but using totally different methods. We'll mention that in the chapter Property Flags and Descriptors.

SUMMARY

Objects are assigned and copied by reference. In other words, a variable stores not the "object value", but a "reference" (address in memory) for the value. So copying such a variable or passing it as a function argument copies that reference, not the object itself.

All operation via copied references (like adding/removing properties) are performed on the same single object. To make a 'real copy' (a clone) we can use Object.assign for the so-called "shallow copy" (nested objects are copied by reference) or a "deep cloning" function, such as _.cloneDeep(obj).

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

GARBAGE COLLECTION

Memory management in JavaScript is performed automatically and invisibly to us. We create 
primitives, objects, functions ... All that takes memory

What happens when something is not needed any more? How does the JavaScript engine discover it and clean it up?

Reachability

The main concept of memory management in JavaScript is reachability. Simply put, reachable values are those that are accessible or usable somehow. They are guaranteed to be stored in memory.

1. There's a base set of inherently reachable values, that cannot be deleted for obviuos reasons.

	For instance: 

	* The currently executing function, its local variables and parameters
	* Other functions on the current chain of nested calls, their local variables and parameters
	* Global variables
	* (there are some other, internal ones as well)

	These values are called roots

2. Any other value is considered reachable if it's reachable from a root by a reference or by a chain of references.

	For Instance:

	If there's an object in a global variable, and that object has a property referencing another object, that object is considered reachable. ANd those that it references are also reachable. Dtailed examples to follow.

There is a background process in the JavaScript engine that is called garbage collector. It monitors all objects and removes those that have become unreachable.

A simple example:

let user = {name: "John"};

<global> -user> Object(name: "John");

here the arrow depicts an object reference. The global variable "user" references the object {name: "John"} (we'll call it John for brevity). The "Name" property of John stores a primitive, so it's painted inside the object.

If the value of user is overwritten, the reference is lost:

user: null;

<global> -user> null

the Object user is lost.

Now John becomes unreachable, there is no way to access it, no references to it, Garbage Collector will junk the data and free the memory

TWO REFERENCES

Now let's imagine we copied the references from user to admin:

//user has a reference to the object

let user = {
	name: "John"
};

let admin = user;

<global> -user>   Object(name:"John");
         -admin>


user = null;

... then the object is still reachable via admin global variable, so it's in memory.
If we overwrite admin too, the it can be removed.

Interlinked objects

Now a more complex example: The family:

function marry(man, woman) {
	woman.husband = man;
	man.wife = woman;

	return {
		father: man,
		mother: woman
	}
}       

let family = marry({
	name: "John"
}, {
	name: "Ann"
});

The function marry marries two objects by giving them references to each other and returns a new object that contains them both. The resulting memory structure:

<global variable> -family> Object:   father Object name: "John"
											wife \/   /\ husband
									 mother Object name: "Ann"

As of now, all objects are reachable:
Not let's remove two references:

delete family.father;
delete family.mother.husband;

<global variable> -family> Object: mother Object name: "Ann"
									   wife /\

it's not enough to delete only one of these two references, because all objects would still be reachable. but if we delete both, then we can see that John has no incoming reference:

Hence, the John object is GARBAGE.

outgoing references do not matter. Only incoming ones can make an object reachable. So, John is now unreachable and will be removed from the memory with all its data that also became unaccessible.

After Garbage Collection:

<global> -family> Object -mother> Object name:"Ann"

it is possible that the whole island of interlinked objects becomes unreachable and is remover from the memory. The source object s the same as above, then:

family = null;

The in-memory picture becomes:

<global> family: null

and the island is GARGABE

This example demonstrates how important the concept of reachability is. It's obvious that john and ann are still linked, both have incoming references, but that is not enough. The former "family" object has been unlinked from the root, there's nor eference to it any more, so the whole island becomes unreachable and will be removed

INTERNAL ALGORITHMS

The basic garbage collection algorithm is called "mark-and-sweep".
The following "garbage collection" steps are regularly performed:

* the garbage collector takes roots and 'marks' (remembers) them
* then it visits and 'marks' all references from them
* then it visits marked objects and marks their references. All visited objects are remembered, so as not to visit the same object twice in the future
* ... and so on, until every reachable (from the roots) references are visited.
* all objects except marked ones are removed.

we can imagine the process as spilling a huge bucket of paint from the roots, that flows through all references and marks all reachable objects. the unmarked ones are then removed.


that's the concept of how garbage collection works. Javascript engines apply many optimizations to make it run faster and not affect the execution.

Some of the optimizations:

* general Collection - objects are split into two sets: "new ones" and "old ones". Many objects appear, do their job and die fast, they can be cleaned up aggressively. those that survive for long enough, become "old" and are examined less often.

* incremental collection - if there are many objects and we try to walk and mark the whole object set at once, it may take some time and introduce visible delays in the execution. So the engine tries to split the garbage collection into pieces. Then thepieces are executed one by one separately. That requires some extra bookkeeping between them to track changes, but we have many tiny delays instead of a big one.

* idle-time collection - the garbage collector tries to run only while the CPU is idle, to reduce the possible effect on the execution

there exist other optimizations and flavours of garbage collection algorithms. As much as i'd like to describe them here, I have to hold off, because different engines implement different twaks and techniques. And what's even more important, things change as engines develop, so, studying deeper 'in advance', without a real need is probably not worth that. unless, of course, it is a matter of pure interest, then there will be some links for you below.

SUMMARY

The main things to know:

* garbage collection is performed automatically. we cannot force or prevent it.

* objects are retained in memory while they are reachable.

* being references is not the same as being reachable (from a root): a pack of interlinked objects can become unreachable as a whole

modern engines implement advanced algorithms of garbage collection. A general book "the garbage collection handbook: the art of automatic memory management" covers some of them.

If you are familiar with low-level programming, the more detailed information about v8 garbage collection is in the article: A tour of v8: garbage collection.

V8 blog also publishes articles about changes in memory management from time to tome. Naturally, to learn the garbage collection, you'd better prepare by learning about v8 internals in general and read the blog of Vyascheslav Egorov who worked as one ov v8 engineers. I'm saynig: "v8" because it is best covered with articles in the internet. For other engines, many approaches are similiar, but garbage collection differs in many aspecds.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Object Methods, "this"

Objects are usually created to represent entities of the real world. Like users, orders and so on.

let user = {
	name: "John",
	age: 30
};

And, in the real world, a user can ACT: select something from the shopping cart, login, logout etc. Actions are represented in JavaScript by functions in properties.

Method Examples

For a start, let's teach the user to say hello:

let user = {
	name: "John",
	age: 30
};


user.sayHi = function() {
	alert("Hello!");
};

user.sayHi(); // Hello!


Here we've just used a function expression to create a function and assign it to the property user.sayHi of the object.

Then we call it as a user.sayHi(). The user can now speak!

a function that is a property of an object is called its *method*.

So, here we've got a method sayHi of the object user.

of course, we could use a pre-declared function as a method, like this:

let user = {
	
}

function sayHi() {
	alert("Hello!");
};

user.sayHi = sayHi;
user.sayHi();

object-oriented programming: when we write our code using objects to represent entities, that's called object-oriented programming. in short: "OOP".

OOP is a big thing, an interesting science of its own. How to choose the right entities? How to organize the interaction between them? That's architecture, and there are great books on that topic; like:

"Design Patterns: Elements of Reusable Object-Oriented Software"
"Object-Oriented Analysis and Design With Applications"

METHOD SHORTHAND

there exists a shorter syntax for methods in an object literal:

user = {
	sayHi: function() {
		alert("Hello!");
	}
};


//method shorthand looks better, right?

user = {
	sayHi() {
		alert("Hello");
	}
};

As demonstrated, we can omit "function" and just write sayHi(). To tell the truth, the notations are not fully identical. There are subtle differences related to object inheritance (to be covered later), but for now they do not matter. In almost all cases, the shorter syntax is preferred.

"this" in methods.

It's common that an object method needs to access the information stored in the object to do its job.

For instance, the code inside user.sayHi() may need the name of the user.

To access the object, a method can use the 'this' keyword.

The value of 'this' is the object "before dot", the one used to call the method.

For instance:

let user = {
	name: "John",
	age: 30,


	sayHi() {
		// 'this' is the 'current object'
		alert(this.name);
	}


};


user.sayHi(); // John

here during the executino of user.sayHi(), the value of this will be user. Technically, it's also possible to access the object without this, by referencing it via outer variable:

let user = {
	name: "John",
	age: 30,

	sayHi() {
	alert(user.name);
	}
};



... but such code is unreliable. If we decide to copy user to another variable, e.g. admin = user and overwite user with something else, then it will access the wrong object.

That's demonstrated below:

let user = {
	name: "John",
	age: 30,

	sayHi() {
		alert( user.name ); //leads to an error
	}
};



let admin = user;
user = null; //overwrite to make things obvious

admin.sayHi(); // TypeError: cannot read property 'name' of null

if we used this.name, instead of user.name, inside the alrt, then the code would work.

"this" IS NOT BUOND

IN javascript, keyword 'this' behaves unlike most other programming languages. it can be used in any function, even if it's not a method of an object. There's no syntax error in the following example:

function sayHi() {
	alert( this.name )
}

the value of this is evaluated during the run-time, depending on the context. for instance, here the same function is assigned to two different objects and has different 'this' in the calls:

let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
	alert( this.name );
}

user.f = sayHi;
admin.f = sayHi;

user.f(); //John (this == user)
admin.f(); //Admin (this == admin)

admin['f']();

the rule is simple: if obj.f() is called, then this is obj during the call of f. So it's either user or admin, in the example above.

(i) Calling without an object: This == undefined.

we can even call the function without an object at all:

function sayHi() {
	alert(this);
}

sayHi(); //undefined

in this case, this is undefined, in strict mode. If we try to access this.name, there will be an error. In non-strict mode, the value of 'this' in such case will be the global object (window in a browser, we'll get to it later in the chapter global object). This is a historical behavior that 'use strict' fixes.

usually such call is a programming error. if there's this inside a function, it expects to be called in an object context.

(i) the consequences of unbound this

if you come from another programming language, then you are probably used to the idea of a 'bound this', where methods defined in an object always have 'this' referencing that object.

In JavaScript 'this' is free, its value is evaluated at call-time and does not depend on where the method was declared, but rather on what object is 'before the dot'.

The concept of 'run-time' evaluated 'this' has both pluses and minuses. On the one hand, a function can be reused for different objects. On the other hand, the greater flexibility creates more possibilites for mistakes.

Here our position is not judge wheter this language design decision is good or bad. we'll understand how to work with it, how to get benefits and void problems.

*
ARROW FUNCTIONS HAVE NO 'THIS'
*

Arrow functions are special: they don't have their 'own' this. if we reference this from such a function, it's taken from the outer 'normal' function.

for instance, here, arrow() uses this from the outer user.sayHi() method:

let user = {
	firstName: "Ilya",
	sayHi() {
	let arrow = () => alert(this.firstName);
	arrow();
	}
};

user.sayHi(); // Ilya

that's a special feature of arrow functions, it's useful when we actually do not want to have a separete this, but rather to take it from the outer context. later in the chapter "arrow functions revisited" we'll go more deeply into arrow functions.

SUMMARY

* Functions that are stored in object properties are called 'methods'.
* methods allow objects to 'act' like object.doSomething().
* methods can reference the object as this

the value of this is defined at run-time

* when a function is declared, it may use this, but that this nas no value until the function is called.
* a function can be copied between objects
* when a function is called in the 'method' syntax: object.method(), the value of 'this' during the call IS object.

please note that arrow functions are special: theyn have no 'this'. When this is accessed inside an arrow function, it is taken from outside.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

CONSTRUCTOR, OPERATOR "NEW"

The regular {...} syntax allows to create one object. But often we need to create many similar objects, like multiple users or menu items and so on.

That can be done using constructor functions and the 'new' operator.

Constructor Function

Constructor functions technically are regular functions. There are two conventions though:

1. They are named with capital letter first.
2. They should be executed only with "new" operator.

For Instance:

function User(name) {
	this.name = name;
	this.isAdmin = false;
}

let user = new User("Jack");

alert(user.name); // Jack
alert(user.isAdmin); // false

When a function is executed with new, it does the following steps:

1. A new empty object is created and assigned to 'this'.
2. The function body executes. Usually it modifies 'this', adds new properties to it.
3. The value of 'this' is returned.

In other words, new User(...) does something like:

function User(name) {
	// this = {}; (implicitly)

	//add properties to this
	this.name = name;
	this.isAdmin = false;

	//return this; (implicitly)
}

So let user = new User ("Jack") gives the same result as:

let user = {
	name: "Jack",
	isAdmin: false
};

now if we want to create other users, we can call new User ("Ann"), new User ("Alice") and
so on. Much shorter than using literals every time, and also easy to read.

That's the main purpose of constructors - to implement reusable object creation code.

Let's note once again - technically, any function can be used as a constructor. That is: any functino can be run with new, and it will execute the algorithm above. The 'capital letter first' is a common agreement, to make it clear that a function is to be run with new.

new function() {...}

If we have many lines of code all about creation of a single complex object, we can wrap them in constructor function, like this:

let user = new function() {
	this.name = "John";
	this.isAdmin = false;

	// ...other code for user creation
	// maybe complex logic and statements
	// local variables etc
};

The constructor can't be called again, because it is not saved anywhere, just created and called. So this trick aims to encapsulate the code that constructs the single object, without future reuse.

CONSTRUCTOR MODE TEST: NEW.TARGET

Advanced Stuff: The syntax from this section is rarely used, skip it unless you want to know everything.

Inside a function, we can check whether it was called with new or without it, using a special new.target property.

it is undefined for regular calls and equals the function if called with 'new':

function User() {
	alert(new.target);
}

// without 'new':
User(); //undefined

// with 'new':
new User(); // function User { ... }

That can be used inside the function to know whether it was called with 'new', 'in constructor mode', or without it, 'in regular mode'.

we can also make both new and regular calls to do the same, like this:

function User(name) {
	if (!new.target) { // if you run me without new
		return new User(name); // ... I will add new to you
	}

	this.name = name;
}

let john = User("John"); // redirects call to new Users
alert(john.name); // John

this approach is sometimes used in libraries to make the syntax more flexible, so that people may call the function with or without 'new' and it still works. Probably not a good thing to use everywhere though, because omitting 'new' makes it a bit less obvious what's going on. With 'new' we all know that the new object is being created.

RETURN FROM CONSTRUCTORS

Usually, constructors do not have a 'return' statement. Their task is to write all necessary stuff into 'this', and it automatically becomes the result.

But if there is a return statement, then the rule is simple:

* if return is called with an object, then the object is returned instead of this
* if return is called with a primitive, it's ignored

In other words, return with an object returns that object, in all other cases, 'this' is returned.

For instance,  here 'return' overrides 'this' by returning an object:

function BigUser() {
	this.name = "John";

	return { name: "Godzilla" }; // <-- returns the object
}

alert( new BigUser().name ); // Godzilla got that object

And here's an example with an empty 'return' (or we could place a primitive after it, doesn't mater):

function SmallUser() {
	this.name = "John";
	return; // <-- return this
}

alert( new SmallUser().name ); // John

usually constructors don't have a return statement. Here we mention the special behavior with returning objects mainly for the sake of completeness

(i) Omitting parentheses: by the way, we can omit parentheses after new, if it has no arguments:

let user = new User; // <-- no parentheses
// same as 
let user = new User();

it is not considered a 'good style', but the syntax is allowed.

METHODS IN CONSTRUCTOR

using constructor functions to create objects gives a great deal of flexibility. The constructor function may have parameters that define how to construct the object and what to put in it.

Of course, we can add to 'this' not only properties, but methods as well.

For instance, new User(name) below creates an object with the given name and method sayHi:

function User(name) {
	this.name = name;

	this.sayHi = function() {
		alert( "My name is: " + this.name );
	};
}

let john = new User("John");
john.sayHi(); // my name is: John

/*
john = {
	name: "John",
	sayHi: function() {...}
}
*/

to create complex objects, there's a more advanced syntax, classes, that we'll cover later.

SUMMARY

* construtor functions or, briefly, constructors, are regular functions, but there's a common agreement to name them with capital letter first.
* constructor functions should only be called using 'new'. Such a call implies a creation of empty 'this' at the start and return the populated one at the end.

We can use constructor functions to make multiple similar objects.

JavaScript provides constructor functions for many built-in language objects: like Date for dates, Set for sets and others that we plan to study.

(i) Objects, we'll be back!: In this chapter, we only cover the basics abuot objects and constructors. They are essential for learning more about data types and functions in the next chapters. After we learn that, we erturn to objects and cover them in-depth in the chapters Prototypes, Inheritance and Classes

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Optional Chaining '?.'

The optional chaining ?. is a safe way to access nested object properties, even if an intermediate property doesn't exist.

The "non-existing property" problem

If you've just started to read the tutorial and learn JavaScript, maybe the problem hasn't touched you yet, but it's quite common.

As an example, let's say we have user objects that hold the information about our users.

Most of our users have addresses in user.address property, with the street user.address.street, but some did not provide them.

In such case, when e attempt to get user.address.street, and the user happens to be without an address, we get an error:


let user = {};

alert(user.address.street); //error

That's the expected result, JavaScript works like this. As user.address is undefined, an attempt to get user.address.street fails with an error.

In many practical cases we'd prefer to get undefined instead of an error here (meaning "no street").

... and another example. In the web development, we can get an object that corresponds to a web page element using a special method call, such as document.querySelector('.elem'), and returns 'null' when there's no such element.

// document.querySelector('.elem') is null if there's no element
let html = document.querySelector('.elem').innerHTML; //error if it's null

Once again, if the element doesn't exist, we'll get an error accessing .innerHTML of null. And, in some cases, when the absence of the element is normal, we'd like to avoid the error and just accept html = null as the result.

how can we do this? The obvious solution would be to check the value using if or the conditional operator ?, before accessing its property, like this:

let user = {};

alert(user.address ? user.adress.street : undefined);

It works, there's no error... but it's quite inelegant. As you can see, the "user.address" appears twice in the code. for more deeply nested properties, that becomes a problem as more repetitions are required.

E.G. let's try getting user.address.street.name

we need to check both user.address and user.address.street:

let user = {};
alert(user.address ? user.address.street ? user.address.street.name : null : null);

That's just awful, one may even have problems understanding such code. Don't even care to, as there's a better way to write it, using the && operator:

let user = {}; //user has no address
alert( user.address && user.address.street && user.address.street.name) // undefined (no error)

AND'ing the whole path to the property ensures that all componentes exist (if not, the evaluation stops), but also isn't ideal.

As you can see, property names are still duplicated in the code. E.G. in the code above, user.address appears three times.

That's why the optional chaining ?. was added to the language. To solve this problem once and for all.

OPTIONAL CHAINING

The optional chaining ?. stops the evaluation if the value before ?. is undefined or null and returns undefined.

Further, in this article, for brevity, we'll be saying that something 'exists' if it's not null and not undefined.

in other words, value?.prop:

* works as value.prop, if value exists.
* otherwise (when value is undefined/null) it returns undefined

Here's the safe way to access user.address.street using ?.:

let user = {};
alert( user?.address?.street ); // undefined

The code is short and clean, there's no duplication at all.
Reading the address with user?.address works even if user object doesn't exist:

let user = null;

alert( user?.address ); // undefined
alert( user?.address.street ); // undefined

Please note: the ?. syntax makes optional the value before it, but not any further.

Eg. in user?.address.street.name the ?. allows 'user' to safely be null/undefined (and returns undefined in that case), but that's only for 'user'. Further properties are accessed in a regular way, if we want some of them to be optional, then we'll need to replace more . with ?..

(w) don't overuse the optional chaining

We should use ?. only where it's ok that something doesn't exist. For example, if according to our coding logic 'user' object must exist but 'address' is optional, then we should write user.address?.street but not user?.address?.street.

So, if user happens to be undefined due to a mistake, we'll see a programming error about it and fix it. Otherwise, coding errors can be silenced where not appropriate, and become more difficult to debug.

(w) the variable before ?. must be declared

if there's no variable 'user' at all, then user?.anything triggers an error:

//ReferenceError: user is not defined

The variable must be declared (e.g. let/const/var user or as a function parameter). The optional chaining works only for declared variables.

SHORT-CIRCUITING

as it was said before the ?. immediately stops ("short-circuits") the evaluation if the left part doesn't exist. So, if there are any further function calls or side effects they don't occur. For instance:

let user = null;
let x = 0;

user?.sayHi(x++); // no "sayHi" so the execution will stop

alert(x); // 0, value not incremented.

Other Variants: ?.(), ?.[]

The optional chaining ?. is not an operator, but a special syntax construct, that also works with functions and square brackets. For example ?.() is used to call a function that may not exist.

in the code below, some of our users have 'admin' method and some don't.

let userAdmin = {
	admin() {
		alert("I am admin");
	}
};

let userGuest = {};

userAdmin.admin?.(); // I am admin

userGuest.admin?.(); // nothing (no such method)

here, in both lines, we first use the dot (userAdmin.admin) to get admin property, because we assume that the user object exists, so it's safe read from it.

Then ?.() checks the left part: if the admin function exists, then ir tuns (that's so for userAdmin). Otherwise (for userGuest) the evaluation stops without errors.

The ?.[] syntax also works, if we'd like to use brackets to access properties instead of dot .. Similar to previous cases, it allows to safely read a property from an object that may not exist.

let key = "firstName";

let user1 = {
	firstName: "John"
};

let user2 = null;

alert( user1?.[key] ); // John
alert( user2?.[key] ); // undefined

also we can use ?. with delete:

delete user?.name; //delete user.name if user exists.

We can use ?. for safe reading and deleting, but not writing. 

The optional chaining ?. has no use at the left side of an assignment. For example:

let user = null;
user?.name = "John"; 

//error, doesn't wotk. it's just not that smart.

SUMMARY

The optional chaining ?. syntax has three forms:

1. obj?.prop - returns obj.prop if obj exists, otherwise undefined
2. obj?.[prop] - returns obj.[prop] if obj exsits, otherwise undefined
3. obj.method?.() - calls obj.method() if obj.method exits, otherwise undefined

As we can see, all of them are straightforward and simple to use. The ?. checks the left part for null/undefined and allows the evaluation to proceed if it's not so

A chain of ?. allows to safely access nested properties.

Still, we should apply ?. carefully, only where it's acceptable that the left part doesn't exist. So that it won't hide programming errors from us, if they occur.

############################################################################################

Symbol Type

By specification, object property keys may be either of string type, or of symbol type. Not numbers, not booleans, only strings and symbols. These two types only.

Till now we've been using only strings. Now let's see the benefits that symbols can give us.

A symbol represents a unique identifier.

A value of this type can be created using Symbol();

// id is a new Symbol

let id = Symbol();

Upon creation, we can give symbol a descrption (also called a symbol name), mostly useful for debugging purposes:

// id is a sumbol with the descrption "id"
let id = Symbol("id");

Symbols are guaranteed to be unique. Even if we create many symbols with the same description,
they are different values. The description is just a label that doesn't affect anything.

For instance, here are two symbols with the same description - they are not equal:

let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); //false

if you are familiar with Ruby or another language that also has some sort of 'symbols' - please don't be misguided. Javascript symbols are different.

(w) Symbols don't auto-convert to a string:

For instance, we can alert almost any value, and it will work. Symbols are special. They don't auto-convert.

For instance, this 'alert' will show an error:

let id = Symbol("id");
alert(id); //TypeError cannot convert a Symbol value to a string

that's a 'language guard' against messing up, because strings and symbols are fundamentally different and should not accidentally convert into no another.

If we really want to show a symbol, we need to explicitly call .toString() on it, like here:

let id = Symbol("id");
alert(id.toString()); // Symbol(id), now it works

Or get symbol.description property to show the description only:

let id = Symbol("id");
alert(id.description); //id

"HIDDEN" PROPERTIES

Symbols allow us to create "hidden" properties of an object, that no other part of code can accidentally access or overwrite.

For instance, if we're working with user objects, that belong to a third-party code. We'd like to add identifiers to them.

Let's use a symbol key for it:

let user = {
	name: "John"
};

let id = Symbol("id");

user[id] = 1;
alert( user[id] ); // 1 - we can access the data using the symbol as the key

what's the benefit of using Symbol("id") over a string "id"?

as 'user' objects belongs to another code, and that code also works with them, we shouldn't just add any fields to it. That's unsafe. But a symbol cannot be accessed accidentally, the third-party code probably won't even see it, so it's probably all right to do.

Also, imagine that another script wants to have its own identifier inside 'user', for its own purposes. That may be another JavaScript library, so that the scripts are completely unaware of each other.

Then that script can create its own Symbol("id"), like this:

// ...
let id = Symbol("id");
user[id] = "Their id value";

There will be no conflict between our and their identifiers, because symbols are always different, even if they have the same name.

... but if we used a string "id" instead of a symbol for the same purpose, then there would be a conflict:

let use = { name: "John" };

// Our script uses "id" property
user.id = "Our id value";

// ... another script also wants "id" for its purposes...

user.id = "Their id value"
// Boom! overwritten by another script!

Symbols in an object literal

If we want to use a symbol in an object literal {...}, we need square brackets around it.

Like this:

let id = Symbol("id");

let user = {
	name: "John",
	[id]: 123
};

That's because we need the value from the variable 'id' as the key, not the string 'id'.

Symbols are skipped by for...in

Symbolic properties do not participate in for...in loop.

For instance:

let id = Symbol("id");
let user = {
	name: "John",
	age: 30,
	[id]: 123
};

for (let key in user) alert(key); //name, age (no symbols)

// the direct access by the symbol works
alert( "Direct: " + user[id] );

Object.keys(user) also ignores them. That's a part of the general 'hiding symbolic properties' principle. If another script or a library loops over our object, it won't unexpectedly access a symbolic property.

In contrast, Object.assign copies both string and symbol properties:

let id = Symbol("id");
let user = {
	[id]: 123
};

let clone = Objectassign({}, user);

alert( clone[id] ); //123

There is no paradox here. That's by design. The idea is that when we clone an object or merge objects, we usually want all properties to be copied (including symbols like id);

GLOBAL SYMBOLS

As we've seen, usually all symbols are different, even if they have the same name. But sometimes we want same-named symbols to be same entities. For instance, different parts of our application want to access symbol "id" meaning exactly the same property.

To achieve that, there exists a 'global symbol registry'. We can create symbols in it and access them later, and it guarantees that repeated accesses by the same name return exactly the same symbol.

In order to read (create if absent) a symbol from the registry, use Symbol.for(key).

That call checks the global registry, and if there's a symbol described as 'key', then returns it, otherwise creates a new symbol Symbol(key) and stores it in the registry by that given 'key'.

For instance:

// read from the global registry
let id = Symbol.for("id"); // if the symbol did not exist, it is created

// read it again (maybe from another part of the code)
let idAgain = Symbol.for("id");

// the same symbol
alert( id === idAgain ); // true

Symbols inside the registry are called global symbols. If we want an application-wide symbol, accessible everywhere in the code - that's what they are for.

(i) That sounds like Ruby: in some programming languages, like Ruby, there's a single symbol per name. In JavaScript, as we can see, that's right for global symbols.

Symbol.keyFor

For global symbols, not only Symbol.for(key) returns a symbol by name, but there's a reverse call: Symbol.keyFor(sym), that does the reverse: returns a name by a global symbol.

For instance:

// get symbol by name

let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

//get name by symbol
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id

The Symbol.keyFor internally uses the global symbol registry to look up the key for the symbol. So it doesn't work for non-global symbols. If the symbols is not global, it won't be able to find it and returns undefined.

That said, any symbols have description property.

For instance:

let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

alert( Symbol.keyFor(globalSymbol) ); // name, global symbol
alert( Symbol.keyFor(localSymbol) ); //undefined

alert( localSymbol.description ); // name


SYSTEM SYMBOLS

There exist many "system" symbols that JavaScript uses internally, and we can use them to fine-tune various aspects of our objects.

They are listed in the specification in the Well-known symbols table:

* Symbol.hasInstance
* Symbol.isConcatSpreadable
* Symbol.iterator
* Symbol.toPrimitive
* ... and so on.

For instance, Symbol.toPrimitive allows us to describe object to primitive conversion. We'll see its use very soon.

Other symbols will also become familiar when we study the corresponding language features.

SUMMARY

Symbol is a primitive type for unique identifiers.

Symbols are created with Symbol() call with an optional description (name).

Symbols are always different values, even if they have the same name. If we want same-named symbols to be equal, then we should use the global registry: Symbol.for(key) returns (creates if needed) a global symbol with key as the name. Multiple calls of Symbol.for with the same key return exactly the same symbol.

Symbols have two main use cases:

1. "Hidden" object properties. If we want to add a property into an object that 'belongs' to another script or a library, we can create a symbol and use it as a property key. A symbolic property does not appear in for..in, so it won't be accidentally processed together with other properties. Also it won't be accessed directly, because another script does not have our symbol. So the property will be protected from accidental use or overwrite.

So we can 'covertly' hide something into objects that we need, but others should not see, using symbolic properties.

2. There are many system symbols used by JavaScript which are accessible as Symbol.*. We can use them to alter some built-in behaviors. For instance, later in the tutorial we'll use Symbol.iterator for iterables, Symbol.toPrimitive to setup object-to-primitive conversion and so on.

Technically, symbols are not 100% hidden. THere is a built-in method Oject.getOwnPropertySymbols(obj) that allows us to get all symbols. Also there is a method named Reflect.ownKeys(obj) that returns all keys of an object including symbolic ones. So there are not really hidden. But most libraries, built-in functions and syntax constructs don't use these methods.

#############################################################################################

Object to primitive conversion

What happens when objects are added obj1 + obj2, subtracted obj1 - obj2 or printer using alert(obj)?

In that case, objects are auto converted to primitives, and then the operation is carried out.

In the chapter Type Conversions, we've seen the rules for numeric, string and boolean conversions of primitives. But we left a gap for objects. Now, as we know about methods and symbols it becomes possible to fill it.

1. All objects are true in a boolean context. There are only numeric and string conversions.

2. The numeric conversion happens when we subtract objects or apply mathematical functions. For instance, Date objects (to be covered in the chapter Date and Time) can be subtracted, and the result of date1 - date2 is the time differente between two dates.

3. As for the string conversion - it usually happens when we output an object like alert(obj) and in similar contexts.

%
ToPrimitive
%

We can fine-tune string and numeric conversion, using special object methods.

There are three variants of type conversion, so-called 'hints', described in the specification:

"string"

For an object-to-string conversion, when we're doing an operation on an object that expects a string, like 'alert':

//output
alert(obj);

//using object as a property key
anotherObj[obj] = 123;

"number"

For an object-to-number conversion, like when we're doing maths:

// explicit conversion
let num = Number(obj);

// maths (except binary plus)
let n = +obj; // unary plus
let delta = date1 - date2;

// less/greater comparison
let greater = user1 > user2;

"default"

Occurs in rare cases when the operator is 'not sure' what type to expect.

For instance, a binary plus + can work both with strings (concatenates) and numbers (adds them), so both strings and numbers would do. So if a binary plus gets an object as an argument, it uses the 'default' hint to convert it.

Also, if an object is compared using == with a string, number or a symbol, it's also unclear which conversion should be done, so the 'default' hint is used.

//binary  plus uses the 'default' hint

let total = obj1 + obj2;

//obj == number uses the 'default' hint
if (user == 1 ) { ... };

The greater and less comparison operatores, such as < >, can work with both strings and numbers too. Still, they use the 'number' hint, not 'default'. that's for historical reasons.

In practice though, we don't need to remember these peculiar details, because all built-in objects except for one case (Date object, we'll learn it later) implement "default" conversion the same way as 'number'. And we can do the same.


(i) No 'boolean' hint

Please note - there are only three hints. It's that simple.

There is no 'boolean' hint (all objects are true in boolean context) or anything else. And if we treat 'default' and 'humber' the same, like mols built-ins do, then there are only two conversions.

To do the conversion, JavaScript tries to find an call three object methods:

1. Call obj[Symbol.toPrimitive](hint) - the method with the symbolic key Symbol.toPrimitive (system symbol) if such method exists..
2. Otherwise if hint is 'string': try obj.toString() and obj.valueOf(), whatever exists.
3. Otherwise if hint is 'number' or 'default': try obj.valueOf() and obj.toString(), whatever exists.

%
Symbol.toPrimitive
%

Let's start from the first method. There's a built-in symbol named Symbol.toPrimitive that should be used to name the conversion method, like this:

obj[Symbol.toPrimitive] = function(hint) {
	// must return a primitive value
	// hint = one of 'string', 'number', 'default'
};

For instance, here user object implements it:

let user = {
	name: "John",
	money: 1000,

	[Symbol.toPrimitive](hint) {
	alert(`hint: ${hint}`);
	return hint == 'string' ? `{name: "${this.name}"}` : this.money;
	}
};

// conversions demo:

alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500

As we can see from the code, user becomes a self-descriptive string or a money amount depending on the conversion. The single method user[Symbol.toPrimitive] handles all conversion cases.

toString/valueOf

methods toString and valueOf come from ancient times. They are not symbols (symbols did not exist that long ago), but rather 'regular' string-named methods. They provide an alternative 'old-style' way to implement the conversion.

If there's no Symbol.toPrimitive then JavaScript tries to find them and try in the order:

* toString -> valueOf for 'string' hint
* valueOf -> toString otherwise.

These methods must return a primitive value. If toString or valueOf returns an object, then it's ignored (same as if there were no method).

By default, a plain object has following toString and valueOf methods:

Here's the demo:

let user = {name: "John"};

alert(user); // [object Object]
alert(user.valueOf() === user); //true

So if we try to use an object as a string, like in an alert or so, then by default we see [object Object]. And the default valueOf is mentioned here only for the sake of completeness, to avoid any confusion. As you can see, it returns the object itself, and so is ignored. Don't ask me why, that's for historical reasons. So we can assume it doesn't exist.

Let's implement these methods.

For instance, here user does the same as above using a combination of toString and valueOf instead of Symbol.toPrimitive:

let user = {
	name: "John",
	money: 1000,

	// for hint="string"
	toString() {
		return `{name: "${this.name}"}`;
	},

	// for hint="number" or 'default'
	valueOf() {
		return this.money;
	}

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500

In the absense of Symbol.toPrimitive and valueOf, toString will handle all primitive conversions.

Return types

the important thing to know about all prmitive-conversion methods is that they do not necessarily return the 'hinted' primitive. There is no control whether toString returns exactly a string, or where Symbol.toPrimitive method returns a number for a hint 'number'

The only mandatory thing: these methods must return a primitive, not an object

(i) historical notes: for historical reasons, if toString or valueOf returns an object, there's no error, but such value is ignored (like if the method didn't exist). That's because in ancient times there was no good 'error' concept in JavaScript. In contrast, Symbol.toPrimitive MUST return a primitive, otherwise there will be an error

Further Conversions

As we know already, many operators and functions perform type conversions, e.g. multiplication * converts operands to numbers.

If we pass an object as an argument, then there are two stages:

1. The object is converted to a primitive (using the rules described above)
2. If the resulting primitive isn't of the right type, it's converted.

For instance:

let obj = {
	// toString handles all conversions in the absence of other methods
	toString() {
		return "2";
	}
};

alert(obj * 2); // 4, object converted to primitive "2", then multiplication made it a number

1. The multiplication obj * 2 first converts the object to primitive (that's a string "2").
2. Then "2" * 2 becomes 2 * 2 (the string is converted to number).

Binary plus will concatenate strings in the same situation, as it gladly accepts a string:

let obj = {
	toString() {
		return "2";
	}
};

alert(obj + 2); // 22 ("2" + 2), conversion to primitive returned a string => concatenate

SUMMARY

The object-to-primitive conversion is called automatically by many built-in functions and operators that expect a primitive as a value.

There are 3 types of HINTS of it:

* 'string' (for alert and other operations that need a string)
* 'number' (for maths)
* 'default' (few operators)

The specification describes explicitly which operator uses which hint. There are very few operatores that 'don't know that to expect' and use the 'default' hint. Usually for built-in objects 'default' hint is handled the same way as 'number', so, in practice, the last two are often merged together.

The conversion algorithm is:

1. Call obj[Symbol.toPrimitive](hint) if the method exists.
2. Otherwise if hint is 'string':
	Try obj.ToString() and obj.ValueOf(), whatever exists.
3. Otherwise if hint is "number" or "default"
	Try obj.valueOf() and obj.ToString(), whatever exists.

In practice, it's often enough to implement only obj.toString() as a 'catch-all' method for all conversions that return 'human-readable' representation of an object, for logging or debugging purposes.

##############################################################################################

Methods of Primitives

JavaScript allows us to work with primitives (strings, numbers, etc) as if they were objects. They also provide methods to call as such. We will study those soon, but first we'll see how it works because, of course, primitives are not objects (and here we will make it even clearer).

Let's look at the key distinctions between primitives and objects.

A primitive:

* is a value of a primitive type
* there are 7 primitive types: string, number, bigint, boolean, symbol, null and undefined

An object

* is capable of storing multiple values as properties.
* can be created with {}, for instance: {name: "John", age: 30}. There are other kinds of objects in JavaScript: functions, for example, are objects.

One of the best things about objects is that we can store a function as one of its properties.

let john = {
	name: "John",
	sayHi: function() {
		alert("Hi buddy!");
	}
};

john.sayHi(); // hi buddy! -> this is a method

So here we've made an object John with the method sayHi.

Many built-in objects already exist, such as those that work with dates, errors, HTML elements, etc. They have different properties and methods. 

But, those features come with a cost! Objects are 'heavier' than primitives. They require additional resources to support the internal machinery.

A PRIMITIVE AS AN OBJECT

here's the paradox faced by the creator of JavaScript:

* there are many things one would want to do with a primitive like a string or a number. It would be great to access them as methods.
* primitives must be as fast and lightweight as possible.

The solution looks a little bit awkward, but here it is:

1. Primitives are still primitive. A single valeu, as desired.
2. The language allows access to methods and properties of strings, numbers, booleans and symbols.
3. In order for that to work, a special 'object wrapper' that provides the extra functionality is created, and then is destroyed.

The 'object wrappers' are different for each primitive type and are called: String, Number, Boolean and Symbol. Thus, they provide different sets of methods.

For instance, there exists a string method srt.toUpperCase() that returns a capitalized str.

Here's how it works:

let str = "Hello";

alert( str.toUpperCase() ); //HELLO

Simple, right? Here's what actually happens in str.toUpperCase():

1. The string sts is a primitive. So in the moment of accessing its property, a special object is created that knows the value of the string, and has useful methods, like toUpperCase().

2. That method runs and returns a new string (shown by alert).
3. The special object is destroyed, leaving the primitive str alone.

So primitives can provide methods, but they stull remain lightweight.

Th JS engine highly optimizes this process. It may even skip the creation of the extra object at all. but it must still adhere to the specification and behave as if it creates one.

A number has methods of its own, for instance, toFixed(n) rouns the number to the given precision:

let n = 1.23456;
alert( n.toFixed(2) ); //1.23

We'll see more specifics methods in chapters Numbers and Strings.

(w) Constructs String/Number/Boolean are for internal use only.

Some langauges like Java allow us to explicitly create "wrapper objects" for primitives using a syntax like new Number(1) or new Boolean(false).

In JavaScript, that's also possible for historical reasons, but highly frowned upon. Things will go crazy in several places;

For Instance:

alert( typeof 0); // 'number'
alert( typeof new Number(0)); //'object'

Objects are always truthy in IF, so here the alert will show up:

let zero = new Number(0);
if (zero) { // zero is true because it is an object
	alert( "zero is truthy!?!");
}

On the other hand, using the same functions String/Number/Boolean without new is a totally sane and useful thing. They convert a value to the corresponding type: to a string, a number or a boolean (primitive).

For example, this is entirely valid:

let num = Number('123'); //convert a string to number

(w) null/undefined have no methods:

The special primitives null and undefined are exceptions. They have no corresponding "wrapper objects" and provide no methods. In a sense, they are 'the most primitive'.

An attempt to access a property of such value would result in a typeError.

SUMMARY

* Primitives except null and undefined provide many helpful methods. we will study those in the upcoming chapters.

* Formally, these methods work via temporary objects, but JavaScript engines are well tuned to optimize that internally, so they are not expensive to call

Can I add a property to a string?

Consider the following code:

let str = "Hello";
str.test = 5;

alert(str.test);

Will it work?

What will be shown?

Depending on whether you have 'use strict' or not, the result may be:

1. undefined (no strict mode)
2. an error (strict mode)

Why?

1. When a property of str is accessed, a 'wrapper object' is created.
2. In strict mode, writing into it is an error.
3. Otherwise, the operation with the property is carried on, the object gets the 'test' property, but after that the 'wrapper object' disappears, so in the last line str has no trace of the property.

This example shows that primitives are not objects. They can't store additional data.

#############################################################################################

Numbers

In modern JavaScript, there are two types of numbers:

1. Regular numbers in JavaScript are stored in 64-bit format IEEE-754, also known as 'double precision floating point numbers'. These are numbers that we're using most of the time, and we'll talk about them in this chapter.
2. BigInt numbers, to represent integers of arbitrary length. They are sometimes needed, because a regular number can't exceed 2^53 or be less than -2^53. As bigints are used in few special areas, we devote them a special chapter BigInt.

So here we'll talk about regular numbers. Let's expand our knowledge of them.

More Ways To Write a Number

Imagine we need to write 1 billion. The obvious way is:

let billion = 100000000;

We also can use underscore _ as the separator:

let billion = 1_000_000_000;

Here the underscore _ plays the role of the 'syntactic sugar', it makes the number more readable. The JavaScript engine simply ignores _ between digits, so it's exactly the same one billion as above.

In real life though, we try to avoid writing long sequences of zeroes. We're too lazy for that, we'll try to write something like '1bn' for a billion or '7.3bn' for 7 billion 300 million. The same is true for most large numbers.

In JavaScript, we can shorten a number by appending the letter 'e' to it and specifying the zeroes count:

let billion = 1e9;
alert( 7.3e9 );

In other words, e multiplies the number by 1 with the given zeros count.

1e3 = 1 * 1000 // e3 means *1000
1.23e6 = 1.23 * 1000000 // e6 means *1000000

Now let's write something very small. Say, 1 microsecond (one millionth of a second):

let ms = 0.000001;

Just like before, using 'e' can help. if we'd like to avoid writing the zeroes explicitly, we could say the same as:

let ms = 1e-6; // six zeroes to the left from 1

If we count the zeroes in 0.000001, there are 6 of them. So naturally it's 1e-6.

In other words, a negative number after 'e' means a division by 1 with the given number of zeroes:

// -3 divides by 1 with 3 zeroes
1e-3 = 1 / 1000 (=0.001)

// -6 divides by 1 with 6 zeroes
1.23e-6 = 1.23 / 1000000 (=0.00000123)

HEX, BINARY AND OCTAL NUMBERS

Hexadecimal numbers are widely used in JavaScript to represent colors, encode characters, and for many other things. So naturally, there exists a shorter way to write them: 0x and then the number

For instance:

alert( 0xff ); // 255
alert( 0xFF ); // 255 the same, case doesnt matter

Binary and octal numeral systems are rarely used, but also supported using the 0b and 0o prefixes:

let a = 0b11111111; // binary form of 255
let b = 0o377; // octal form of 255

alert( a == b ); // true, the same number 255 at both sides

There are only 3 numeral systems with such support. For other numeral systems, we should use the function parseInt (which we sill see later)

toString(base)

The moethod num.toString(base) returns a string representation of num in the numeral system with given base.

For example:

let num = 255;

alert( num.toString(16) ); // ff
alert( num.toString(2) );  // 11111111

The base can vary from 2 to 36. By default it's 10.

Common use cases for this are:

* base=16 is used for hex colors, character encodings etc, digits can be 0..9 or A..F
* base=2 is mostly for debugging bitwise operations, digit can be 0 or 1
* base=36 is the maximum, digits can be 0..9 or A..Z. The whole latin alphabet is used to represent a number. A funny, but useful case for 36 is when we need to turn a long numeric identifier into something shorter, for example to make a short url. Can simply represent it in the numeral systen with base 36.

alert( 123456..toString(36) ); //2n9c

(w) Two dots to call a method: please note that two dots in 123456..toString(36) is not a typo. If we want to call a method directly on a number, like toString, in the example above, then we need to place two dots .. after it.

If we places a single dot: 123456.toString(36), then there would be an error, because JavaScript syntax implies the decimal part after the first dot. And if we place one more dot, then JavaScript knows that the decimal part is empty and now goes the method.

Also could write (123456).toString(36).

ROUNDING

One of the most used operations when working with numbers is rounding.

There are several built-in functions for rounding:

Math.floor: rounds down 3.1 becomes 3

Math.ceil: rounds up 3.1 becomes 4

Math.round: rounds to the nearest integer 3.1 becomes 3, 3.6 becomes 4

Math.trunc (not supported by internet explorer): removes anything after the decimal point without rouding: 3.1 becomes 3.

These functions cover all of the possible ways to deal with the decimal part of a number. But what if we'd like to round the number to n-th digit after the decimal?

For instance, we have 1.2345 and want to round it to 2 digits, getting only 1.23?

Some ways to do so:

1. Multiply-and-divide

For example, to round the number to the 2nd digit after the decimal, we can multiply the number by 100 (or a bigger power of 10), call the rounding function and then divide it back.

let num = 1.23456;

alert( Math.round(num * 100) / 100); //1.23456;

2. The method toFixed(n) rounds the number to n digits after the point and returns a string representation of the result.

let num = 12.34;
alert( num.toFixed(1) ); // '12.3'

this roudns up or down to the nearest value, similar to Math.round:

let num = 12.36;
alert (num.toFixed(1)); // '12.4'

please note that result of toFixed is a string. If the decimal part is shorter than required, zeroes are appended to the end:

let num = 12.34;
alert( num.toFixed(5) ); // "12.34000", added zeroes to make exactly 5 digits

we can convert it to a number using the unary plus or a Number() call: +num.toFixed(5).

Imprecise Calculations

Internally, a number is represented in 64-bit format IEEE-754, so there are exactly 64 bits to store a number: 52 of them are used to store the digits, 11 of them store the position of the decimal point (they are zero for integer numbers), and 1 bit is for the sign.

If a number is too big, it would overflow the 64-bit storage, potentially giving an infinity:

alert( 1e500 ); //Infinity

What may be a little less obvious, but happens quite often, is the loss of precision. Consider this (falsy!) test:

alert( 0.1 + 0.2 == 0.3 ); // false

That's right, if we check whether the sum of 0.1 and 0.2 is 0.3, we get false.

alert( 0.1 + 0.2 ); // 0.30000000000000000000000000000

OUCH! There are more consequences than an incorrect comparison here. imagine you're making an e-shopping site and the visitor puts $0.10 and $0.20 goods into their cart, the total order will be $0.300000000000000000000000004. That would surprise anyone.

But why does this happen?

A number is stored in memory in its binary form, a sequence of bits - ones and zeroes. But fractions like 0.1, 0.2 that look simple in the decimal numeric system are actually unending fractions in their binary form.

In other words, what is 0.1? it is one divided by ten 1/10, one-tenth. in decimal numeral systems such numbers are easily representable. Compare it to one-third: 1/3, it becomes and endless fraction: 0.33333(3).

So, division by powers 10 is guaranteed to work well in the decimal system, but division by 3 is not. For the same reason, in the binary numeral system, the division by powers of 2 is guaranteed to work, but 1/10 becomes and endless binary fraction.

There is just no way to store exactly 0.1 or exactly 0.2 using the binary system, just like there is no way to store one-third as a decimal fraction.

The numeric format IEEE-754 solves this by rounding to the nearest possible number. These rounding rules normally don't allow us to see that 'tiny precision loss', but it exists.

We can see this in action:

alert( 0.1.toFixed(20)); //0.100000000000000000000000555

And when we sum two numbers, their 'precision losses' add up. That's why 0.1 + 0.2 is not exactly 0.3.

(i) the same issue exists in many other programming languages. PHP, Java, C, Perl, Ruby give exactly the same result, because they are based on the same numeric format.

Can we work around the problem? Yes, the most reliable method is to round the result with the help of a method toFixed(n):

let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); //0.30

Please note that toFixed always returns a string. It ensures that it has 2 digits after the decimal point. That's actually convenient if we have an e-shopping and need to show $0.30. For other cases, we can use the unary plus to coerce it into a number:

let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3

we also can temporarily multiply the numbers by 100 (or a bigger number) to turn them into integers, do the maths, and then divide back. Then as we're doing maths with integers, the error somewhat decreases but we still get it on division:

alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001

So, multiply/divide approach reduces the error, but doesn't remove it totally. Sometimes we could try to evade fractions at all. Like if we're dealing with a shop, then we can store a prices in cents instead of dollars. But what if we apply a discout of 30%? In practice, totally evading fractions is rarely possible. Just round them to 'cut the tails' when needed.

(i) The funny thing: Try running this:

alert( 9999999999999999 ); // shows 1000000000000000

This suffers from the same issue: a loss of precision. There are 64 bits for the number, 52 of them can be used to store digits, but that's not enough. So the least significant digits disappear. JavaScript doesnt trigger an error in such events. It does its best to fit the number into the desired format, but unfortunately, this format is not big enough.

(i) two zeroes: another funny consequence of internal representation of numbers is the existence of two zeroes: 0 and -0.

That's because a sign is represented by a single bit, so it can be set or not set for any number, including zero. In most cases the distinction is unnoticeable, because operators are suited to treat them as the same.

TESTS: isFinite and isNan

Remember these two special numeric values?
* Infinity (and -Infinity) is a special numeric value that is greater (less) than anything.
* NaN represents an error.

they belong to the type number, but are not 'normal' numers, so there are special functions to check for them:

* isNan(value) converts its argument to a number and then tests it for being NaN:

alert( isNan(NaN) ); // true
alert( isNan("str") ); // true

but do we need this function? can't we just use the comparison === NaN}? Sorry, but the answer is no. The value NaN is unique in that it does not equal anything, including itself:

alert( NaN === NaN); // false

* isFinite(value) converts its argument to a number and returns 'true' if it's a regular number. not NaN/Infinity/-Infinity:

alert( isFinite("15")); //true
alert( isFinite('str')); //false, because NaN
alert( isFinite(Infinity)); //false, because Infinity

sometimes isFinite is used to validate whether a string value is a regular number:

let num = +prompt("enter a number", '');
// will be true unless you enter Infinity, -Infinity and NaN
alert( isFinite(num));

please note that an empty or a space-only string is treated as 0 in all numeric functions including isFinite.

(i) compare with object.is: there is a special built-in method Object.is that compares values like ===, but is more reliable for two edge cases:

1. It works with NaN: Object.is(Nan, Nan) === true, that's a good thing.
2. Values 0 and -0 are different: Object.is(0 , -0) === false, technically that's true, because internally the number has a sign bit that may be different even if all other bits are zeroes.

In all other cases, Object.is(a, b) is the same as a === b.

This way of comparison is often used in JavaScript specification. When an internal algorithm needs to compare two values for being exactly the same, it uses Object.is (internally called SameValue).

parseInt and parseFloat

Numeric conversion using a plus + or Number() is strict if a value is not exactly a number, it fails:

alert( +"100px" ); //NaN

the sole exception is spaces at the beginning or at the end of the string, as they are ignored.

But in real life we often have values in units, like "100px" or "12pt" in CSS. Also in many countries the currency symbol goest after the amount, so we have '19Euros' and would like to extract a numeric value out of that.

That's what parseInt and parseFloat are for.

They 'read' a number from a string until they can't. In case of an error, the gathered nuumber is returned. The function parseInt returns an interger, whilst parseFloat will return a floating-point number:

alert( parseInt('100px') ); //100
alert( parseFloat('12.5em') ); //12.5

alert( parseInt('12.3') ); //12, only the integer
alert( parseFloat('12.3.4') ); // 12.3, the second point stops the reading.

There are situations when parseInt/parseFloat will return NaN. It happens when no digits could be read:

alert(parseInt('a123')); // NaN, the first symbol stops the process

(i) the second argument of parseInt(str, radix): The parseInt() function has an optional second parameter. It specifies the base of the numeral system, so parseInt can also parse strings of hex numbers, binary numbers and so on:

alert( parseInt('0xff', 16)); // 255
alert( parseInt('ff', 16)); //255, without 0x also works

alert( parseInt('2n9c', 36)); //123456

OTHER MATH FUNCTIONS

JavaScript has a built-in Math object which contains a small library of mathematical functions and constants

a few examples:

Math.random() -> returns a random number from 0 to 1 (not including 1)

Math.max(a, b, c...) / Math.min(a, b, c....) -> returns the greatest/smallest from the arbitrary number of arguments.


Math.pow(n, power) -> Returns n raised to the given power.

There are more functions and constants in Math object, including trigonometry, which you can find in the docs for the Math object.

SUMMARY

To write numbers with many zeroes:

* Append 'e' with the zeroes count to the number
* A negative number after 'e' causes the number to be divided by 1 with given zeroes. 

For different numeral systems:

* Can write numbers directly in hex (0x), octal (0o) and binary (0b)
* parseInt(str, base) parses the string str into an integer in numeral system with given base
* num.toString(base) converts a number to a string in the numeral system with the given base

For converting values like 12pt and 100px to a number:

* Use parseInt/parseFloat for the 'soft' conversion, which reads a number from a string and then returns the value they could read before the error.

For fractions:

* Round using Math.floor, Math.ceil, Math.trunc, Math.round or num.toFixed(precision)
* make sure to remember there's a loss of precision when working with fractions

More math Functions:

* see the Math object when you need them. The library is very small, but can cover basic needs.

###########################################################################################

STRINGS!!!!!

In JavaScript, the textual data is stored as strings. There is no separate type for a single character. The internal format for strings is always UTF-16, it is not tied to the page encoding.

QUOTES

let's recall the kinds of quotes. Strings can be enclosed within either single quotes, double quotes or backticks:

let single = 'single-quoted';
let double = "double-quoted";
let backticks = `backticks`;

single and double quotes are essentially the same. Backticks, however, allow us to embed any expression into the string, by wrapping it in ${...}:

function sum(a, b) {
	return a + b;
}

alert(`1 + 2 = ${sum(1,2)}.`); // 1 + 2 = 3.

Another advantage of using backticks is that they allow a string to span multiple lines:

let guestList = `Guests:
	* John
	* Pete
	* Mary
`;

alert(guestList);

looks natural, right? but single or double quotes do not work this way. If we use them and try to use multiple lines, there'll be an error:

let guestList = "Guests: // Error: Unexpected token illegal"
	* John";

Single and double quotes comes from ancient times of language creation when the need for multiline strings was not taken into account. Backticks appeared much later and thus are more versatile.

Backticks also alow us to specify a 'template function' before the first backtick. The syntaz is: func`string`. The function func is called automatically, receives the string and embedded expressions and can process them. This is called 'tagged templates'. This feature makes it easier to implement custom templating, but it is rarely used in practice. You can read more about it in 'the manual';

SPECIAL CHARACTERS

it is still possible to create multiline strings with single and double quotes by using a so-called 'newline character', written as \n, which denotes a line break:

let guestList = "Guests: \n * John \n * Pete \n * Mark";
alert(guestList); // a multiline list of guest

For example, these two lines are equal, just written differently:

let str1 = "Hello\nWorld"; // two lines using a \n
// two lines using a normal newline and backticks
let str2 = `Hello
World`;

alert(str1 == str2); //true

Some Other Less Common 'special' Characters

\n -> new line
\r -> carriage return: not used alone, windows text files use a combination of two characters \r\n to represent a line break
\', \" -> quotes
\\ -> backlash
\t -> tab
\b, \f, \v -> Backspace, form feed, vertical tab - kept for compatibility, not used nowadays
\xXX -> unicode character with the given hexadecimal unicode XX, e.g. '\x7A' is the same as 'z'
\uXXXX -> A unicode symbol with the hex code XXXX, in utf-16 encoding, for instance \u00A9 - is a unicode for the copyrightsymbol. it must be exactly 4 hex digits
\u{X...X} ( 1 to 6 hex chars) -> a unicode symbol with the given UTF-32 encoding. Some rare characters are encoded with teo Unicode Symbols, taking 4 bytes. This way we can insert long codes.

examples:

alert( "\u00A9" ); // copyright symbol
alert( "\u{20331}" ); // a rare chinese heiroglyph
alert( "\u{1F60D}" ); // a smiling face symbol

All special characters start with a backslash character. It is also called an 'escape character'. We might also use it if we wanted to insert a quote into the string. For instance:

alert( 'I\'m the Walrus!' ); // I'm the Walrus!

As you can see, we have to prepend the inner quote by the backslash \', because otherwise it would indicate the string end.

Of course, only the quotes that are the same as the enclosing ones need to be escaped. So, as a more elegant solution, we could switch to double quotes or to backticks instead.

alert( `I'm the Walrus!`); // I'm the Walrus!

Note that the backlash \ serves for the correct reading of the string by JavaScript, then disappears. The in-memory string has no \. You can cleary see that in alert from the examples above.

But what if we need to show an actual backlash \ within the string?
That's possible, but we need to double it like \\:

alert( `The backlash: \\`); // the backlash \

STRING LENGTH 

the length property has the string length:

alert( `My\n`.length ); // 3

Note that \n in a single 'special' character, so the length is indeed 3.

(w) length is a property -> people with a background in some other languages sometimes mistype by calling str.length() instead of just str.length. That doesn't work.

Please note that str.length is a numeric property, not a function. There is no need to add parenthesis after it.

ACCESSING CHARACTERS

to get a character at position 'pos', use square brackets [pos] or call the method str.charAt(pos). The first character starts from the zero position:

let str = `Hello`;

// the first character

alert( str[0] ); // H
alert( str.charAt(0) ); // H

// the last character
alert( str[str.length -1] ); // o

The square brackets are a modern way of getting a character, while charAt exists mostly for historical reasons. The only difference between them is that if no character is found, [] returns undefined, and charAt returns an empty string:

let str = `Hello`;

alert( str[1000] ); // undefined
alert( str.charAt(1000) ); // '' (an empty string)

We can also iterate over characters using for..of:

for (let char of "Hello") {
	alert(char); // H,e,l,l,o (char becomes 'h', then 'e', then 'l', then 'l', then 'o');
}

STRINGS ARE IMMUTABLE

Strings can't be changed in JavaScript. It is impossible to change a character. Let's try it to show that it doesn't work:

let str = 'Hi';
str[0] = 'h'; // error
alert( str[0] ); // doesn't work

The usual workaround is to create a whole new string and assign it to st instead of the old one. For instance:

let str = 'Hi';
str = 'h' + str[1]; // replace the string

alert( str ); // hi

In the following sections we'll see more examples of this

CHANGING THE CASE

methods toLowerCase() and toUpperCase() change the case:

alert( 'Interface'.toUpperCase() ); //interface
alert( 'Interface'.toLowerCase() ); //interface

Or, if we want a single character lowercased:

alert( 'Interface'[0].toLowerCase() ); // 'i'

SEARCHING FOR A SUBSTRING: There are multiple ways to look for a substring within a string.

str.indexOf

the first method is str.indexOf(substr, pos). it looks for the substr in str, starting from the given position pos, and returns the position where the match was found or -1 if nothing can be found. For instance:

let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, because Widget is found at the beginning.
alert( str.indexOf('widget') ); // -1, not found

alert( str.indexOf("id") ); // 1, 'id' is found at the position 1 (... 'id'get)

The optional second parameter allows us to start searching from a given position. For instance, the first occurrence of 'id' is at position 1. To look for the next occurrence, let's start the search from position 2:

let str = 'Widget with id';
alert( str.indexOf('id', 2)) // 12

If we're interested in all occurrences, we can run indexOf in a loop. Every new call is made with the position after the previous match:

let str = 'As sly as a fox, as strong as an ox';

let target = 'as'; // let's look for it

let pos = 0;
while (true) {
	let foundPos = str.indexOf(target, pos);
	if(foundPos == -1) break;

	alert(`Found at ${foundPos}`);
	pos = foundPos + 1; //continue the search from the next position
}

The same algorithm can be layed out shorter:

let str = "As sly as a fox, as strong as an ox";
let target = 'as';

let pos = -1;

while ((pos = str.indexOf(target, pos + 1)) != -1) {
	alert(pos);
}

(i) str.lastIndexOf(substr, position): there is also a similar method str.lastIndexOf(substr, position) that searches from the end of a string to its beginning. This would list the occurences in reverse order.

There is a slight inconvenience with indexOf in the if test. We can't put it in the if like this:

let str = "Widget with id";

if(str.indexOf("Widget")) {
	alert("We found it"); // doesn't work!
}

the 'alert' in the example above doesn't show because, str.indexOf("Widget") returns 0 (meaning that it found the match at the starting position). Right, but if considers 0 to be false.

So, we should actually check for -1, like this:

let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
	alert("We found it"); // works now!
}

THE BITWISE NOT TRICK

One of the old tricks used here is the bitwise NOT ~ operator. It converts the number to a 32-bit integer (removes the decimal part if exists) and then reverses all bits in its binary representation.

In practice, that means a simple thing: for 32-bit integers ~n equals - (n+1).

for instance:

alert(~2); // -3, the same as -(2+1)
alert(~1); // -2, the same as -(1+1)
alert(~0); // -1, the same as -(0+1)
alert(~-1); // 0, the same as -(-1+1)

As we can see, ~n is zero only if n == -1 (that's for any 32-bit signed integer n)
So, the test if ( ~str.indexOf("...") ) is truthy only if the result of indexOf is not -1. In other words, when there is a match.

People use it to shorten indexOf checks:

let str = "Widget";

if (~str.indexOf("Widget")) {
	alert( 'Found it!' ); // works
}

It is usually not recommended to use language features in a non-obvious way, bit this particular trick is widely used in old code, so we should understand it. Just remember:

if(~str.indexOf(...)) reads as 'if found'

To be precise though, as big numbers are truncated to 32 bits by ~ operator, there exist other numbers that give 0, the smallest is ~4294967295 = 0; That makes such check correct only if a string is not that long.

Right now we can see this trick only in the old code, as modern JavaScript provides .includes method (see below).

INCLUDES, STARTSWITH, ENDSWITH

THe more modern method str.includes(substr, pos) returns true/false depending on whether str contains substr within.

It's the right choice if we need to test for the match, but don't need its position:

alert("Widget with id".includes("Widget")); // true
alert( "Hello".includes("Bye")); // false

The optional second argument of str.includes is the position to start searching from:

alert( "Widget".includes("id")); //true
alert( "Widget".includes("id", 3)); //false, from position 3 there is no 'id'

The methods str.startsWith and str.endsWith do exactly what they say:

alert( "Widget".startsWith("Wid")); // true
alert( "Widget".endsWith("get")); // true

GETTING A SUBSTRING

There are 3 methods in JavaScript to get a substring: substring, substr and slice

str.slice(start [, end]) -> returns the part of the string from start to (but not including) end.

str.substring(start [, end]) -> returns the part of the string between start and end. looks like slice but allows to start from higher positions

str.substr(start [, length]) -> returns the part of the string from start, with the given length. In contrast with the previous methods, this one allows us to specify the length instead of the ending position.

(i) which one to choose ? All of them can do the job. Formally, substr has a minor drawback: it is described not in the core JavaScript specification, but in Annex B, which covers browser-only features that exist mainly for historical reasons. So, non browser environments may fail to support it. Slice is the favorite method.

COMPARING STRINGS

As we know from the chapter Comparisons, strings are compared character-by-character in alphabetical order.

Although, there are some oddities.

1. A lowercase latter is always greater than the uppercase
2. Letters with diacritical marks are 'out of order'

This may lead to strange results if we sort these country names. Usually people would expect Zealand to come after Österreich in the list

To understand what happens, let's review the internal representation of strings in JavaScript.

All strings are encoded using UTF-16. That is: each character has a corresponding numeric code. There are special methods that allow to get the character for the code and back.

str.codePointAt(pos) -> returns the code for the character at position pos:

alert("z".codePointAt(0)); // 122
alert("Z".codePointAt(0)); // 90

String.fromCodePoint(code) -> creates a character by its numeric code

alert( String.fromCodePoint(90)); // Z

We can also add Unicode characters by their codes using \u followed by the hex code:

// 90 is 5a in hexadecimal system
alert( '\u005a' ); // Z

NOw let's see the characters with codes 65..220 (the latin alphabet and a little bit extra) by making a string of them:

let str = '';

for (let i = 65; i <= 220; i++) {
	str +- String.fromCodePoint(i);
}

alert(str);

See? Capital characters go first, then a few special ones, then lowercase characters, and Ö near the end of the output. Now it is obvious why a > Z

The characters are compared by their numeric code. The greater code means that the character is greater. The code for a (97) is greater than the code for Z(90)

* all lowercase letters go after uppercase letters because their codes are greater
* some letters like Ö stand apart from the main alphabet, here its code is greater than anything from a to z.

CORRECT COMPARISONS

The 'right' algorithm to do string comparisons is more complex than it may seem, because alphabets are different for different languages.

So, the browser needs to know the language to compare.

Luckily, all modern browsers (IE10- requires the additional library intl.js) support the internationalization standard ECMA-402.

It provides a special method to compare strings in different languages, following their rules.

The call str.localeCompare(str2) returns an integer indicating whether str is less, equal or greater than str2 according to the language rules:

* returns a negative number if str is less than str2
* returns a positive number if str is greater than str2
* returns 0 if they are equivalent

For instance:

alert('Österreich'.localeCompare('Zealand')); // -1

This method actually has two additional arguments specified in the documentation, which allows it to specify the language (by default taken from the environment, letter order depends on the language) and setup additional rules like case sesitivity or should 'a' and 'á' be treated as the same etc.

Internals, Unicode

(w) Advanced Knowledge: This section goes deeper into string internals. This knowledge will be useful for you if you plan to deal with emoji, rare mathematical or hieroglyphic characters or other rare symbols.

You can skip the section if you don't plan to support them.

Surrogate Pairs

All frequently used characters have 2-byte codes. Letters in most european languages, numbers and even most hieroglyphs, have a 2-byte representation.

But 2 bytes only allow for 65536 combinations and that's not enough for every possible sy,bol. So rare symbols are encoded with a pair of 2-byte chars called 'a surrogate pair'

The lengh of such symbols is 2:

alert( '𝒳'.length ); // 2, MATHEMATICAL SCRIPT CAPITAL X
alert( '😂'.length ); // 2, FACE WITH TEARS OF JOY
alert( '𩷶'.length ); // 2, a rare Chinese hieroglyph

Note that the surrogate pairs did not exist at the time when JavaScript was created, and thus are not correctly processed by the language!

We actually have a single symbol in each of the strings above, but the 'length' shows a length of 2.

String.fromCodePoint and str.codePointAt are few rare methods that deal with surrogate pairs right. They recently appeared in the language. Before them, there were only String.fromCharCode and str.charCodeAt. These methods are actually the same as fromCodePoint/codePointAt, but don't work with surrogate pairs.

Getting a symbol can be tricky, because surrogate pairs are treated as two characters:

alert( '𝒳'[0] ); // strange symbols...
alert( '𝒳'[1] ); // ...pieces of the surrogate pair

Note that pieces of the surrrogate pair have no meaning without each other. So the alerts in the example above actually display garbage.

Technically, surrogate pairs are also detectable by their codes: if a character has the code in interval of 0xd800..0xdbff, then it is the first part of the surrogate pair. The next character (second part) must have the code in interval 0xdc00..0xdfff. These intervals are reserved exclusively for surrogate pairs by the standard. In the case above:

// charCodeAt is not surrogate-pair aware, so it gives codes for parts

alert( '𝒳'.charCodeAt(0).toString(16) ); // d835, between 0xd800 and 0xdbff
alert( '𝒳'.charCodeAt(1).toString(16) ); // dcb3, between 0xdc00 and 0xdfff


You will find more ways to deal with surrogate pairs later in the chapter Iterables. There are probably special libraries for that too, but nothing famous enough to suggest here.

Diacritical marks and Normalziation

In many languages there are symbols that are composed of the base character with a mark above/under it. For instance, the letter a can be the base character for áàâãä etc. Most common 'composite' character have their own code in the UTF-16 table. But nor all of them, because there are too many possible combinations.

To support arbitrary compositions, UTF-16 allows us to use several Unicode characters: the base character followed by one or many 'mark' characters that 'decorate' it.

For instance, if we have S followed by the special 'dot above' character (code \u0307) it is shown as Ṡ

If we need additional mark above the letter (or below it) - no problem, just add the necessary mark character.

For instance, if we append a character 'dot below' (code \u0323), then we'll have "S with dots above and below" hence: Ṩ

This provides great flexibility, but also an interesting problem: two characters may visually look the same, but be represented with different Unicode compositions:

let s1 = 'S\u0307\u0323'; // Ṩ, S + dot above + dot below
let s2 = 'S\u0323\u0307'; // Ṩ, S + dot below + dot above

alert( `s1: ${s1}, s2: ${s2}` );

alert( s1 == s2 ); // false though the characters look identical (?!)

To solve this there exists a 'unicode normalization' algorithm that brings each string to the single 'normal' form:

It is implemented by str.normalize().

alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true

It is funny that in our situation normalize() actually brings toegher a sequence of 3 characters to one: \u1e68 (S with two dots).

alert( "S\u0307\u0323".normalize().length ); // 1

alert( "S\u0307\u0323".normalize() == "\u1e68" ); // true

In reality, this is not always the case. The reason being that the symbol Ṩ is 'common enough', so UTF-16 creators included it in the main table and gave it the code.

If you want to learn more about normalization rules and variants - they are described in the appendix of the unicode standard: unicode nromalization forms, but for most practical purposes, the information from this section is enough.

SUMMARY

* there are 3 types of quotes. Backticks allow a string to span multiple lines and embed expressions ${}

* strings in JavaScript are encoded using UTF-16

* we can use special characters like \n and insert letters by their unicode using \u

* to get a character, use: [].

* to get a substring, use: slice or substring.

* to lowercase/uppercase a string, use: toLowerCase/toUpperCase

* To look for a substring, use: indexOf, or includes/startsWith/endsWith for simple checks

* to compare strings according to the language, use: localeCompare, otherwise they are compared by character codes

Also some other useful methods:

str.trim() - removes spaces from the beginning and end of the string
str.repeat(n) - repeats the string n times
... and so on

Strings also have methods for doing search/replace with regular expressions. But that's a big topic, so it's explained in a separate tutorial section Regular Expressions.

#############################################################################################

ARRAYS

Objects allow you to store keyed collections of values. That's fine. But quite often we find that we NEED an ordered collection, where we have a 1st, a 2nd and a 3rd element and so on. For example, we need that to store a list of something: users, goods, HTML elements etc.

It is not convenient to use an object here, because it provides no methods to manage the order of elements. We can't insert a new property 'between' the existing ones. Objects are just not meant for such use.

There exists a special data structure name Array, to store ordered collections.

DECLARATION

These are two syntaxes for creating an empty array:

let arr = new Array();
let arr = [];

Almost all the time, the second syntax is used. WE can supply initial elements in the brackets:

let fruits = ["Apple", "Orange", "Plum"];

Array elements are numbered, starting with zero. We can get an element by its number in square brackets.

let fruits = ["Apple", "Orange", "Plum"];

alert( fruits[0] ); // Apple
alert( fruits[1] ); // Orange
alert( fruits[2] ); // Plum

we can replace an element:

fruits[2] = "Pear"/ // now ["Apple", "Orange", "Pear"]

...Or add a new one to the array:

fruits[3] = 'Lemon'; // now ["Apple", "Orange", "Pear", "Lemon"]

The total count of the elements in the array is its length:

let fruits = ["Apple", "Orange", "Plum"];
alert( fruits.length ); // 3

We can also use alert to show the whole array:

let fruits = ["Apple", "Orange", "Plum"];
alert( fruits ); // Apple, Orange, Plum

An array can store elements of any type. For instance:

// mix of values
let arr = [ 'Apple', {name: "John"}, true, function() {alert('hello');}];

// get the object at index 1 and then show its name
alert( arr[1].name ); // John

// get the function at index 3 and run it
arr[3](); // hello

(i) Trailing Comma - An array, just like an object, may wnd with a comma:

let fruits = [
	'Apple',
	'Orange',
	'Plum',
];

It is a good idea to use the trailing coma because it makes insert / remove items.

METHODS POP/PUSH, SHIFT/UNSHIFT

A queue is one of the most common uses of an array. In computer science, this means an ordered collection of elements which supports two operations:

* push - appends an element to the end
* shift - get an element from the beginning, advancing the queue, so that the 2nd element becomes the first

Array s support both operations. In practice we need it very often. For example, a queue of messages that need to be shown on-screen.

There's another use case for arrays - the data structure named STACK - it supports two operations:

* push - adds an element to the end
* pop - takes an element from the end

So new elements are added or taken always from the 'end'. a Stack is usually illustrated as a pack of cards: new cards are added to the top or taken from the top

For stacks, the latest pushed item is received first, that's also called LIFO (last-in-first-out) principle. For queues, we have FIFO (first-in-first-out). Arrays in JavaScript can work both as a queue and as a stack. They allow you to add/remove elements both to/from the beginning or the end.

In computer science, the data scructure that allows this, is called deque.

METHODS THAT WORK WITH THE END OF THE ARRAY:

pop - extracts the last element of the array and returns it

push - append the element to the end of the array

(The call fruits.push(...) is equal to fruits[fruits.length] = ...)

METHODS THAT WORK WITH THE BEGINNING OF THE ARRAY:

shift - extracts the first element of the array and returns it

unshift - add the element to the beginning of the array:

PS: methods PUSH and UNSHIFT can add multiple elements at once.

INTERNALS

An array is a special kind of object. The square brackets used to access a property arr[0] actually come from the object syntax. That's essentially the same as obj[key], where arr is the object, while numbers are used as keys.

They extend objects providing special methods to work with ordered collections of data and also the length property. But at the core it's still an object.

Remember, there are only eight basic data types in JavaScript (Number, BigInt, String, Boolean, null, undefined, object and symbol). Array is an object and thus behaves like an object. For instance, it is copied by reference: 

let fruits = ['Banana']

let arr = fruits; // copy by reference, two variables reference the same array.

alert(arr === fruits); // true

arr.push('Pear'); // modify the reference

alert(fruits); // Banana, Pear

... but what makes arrays really impressive is their internal representation. The engine tries to store its elements in the contiguous memory area, one after another, just as depicted on the illustrations in this chapter, and there are other optimizations as well, to make arrays work really fast. But they all break if we quit working with an array as with an 'ordered collection' and start working with it as if it were a regular object.

For instance, tecnically we can do this:

let fruits = [];

fruits[99999] = 5;

fruits.age = 25;

That's possible, because arrays are objects at their base. We can add any properties to them. But the engine will see that we're working with the arrays as with a regular object. Array-specific optimizations are not suited for such cases, and will be turned off - their benefits disappear.

The ways to misuse an array:

* add a non-numeric property like. arr.test = 5/
* make holes, like: add arr[0] and then arr[1000] (and nothing between them).
* fill the array in the reverse order, like arr[1000], arr[999] and so on

Please think of arays as special structures to work with the ORDERED DATA. They provide special methods for that. Arrays are carefully tuned inside JavaScript engines to work with contiguous ordered data, please use them this way. And if you need arbitrary keys, chances are high that you actually require a regular object {}.

PERFORMANCE

Methods push/pop run fast while shift/unshift are slow. It is faster to work with the end of the array than with its beginning. 

fruits.shift(); // take 1 element from the start

it's not enough to take and remove the element with the number 0. Other elements need to be renumbered as well. The 'shift' operation must do 3 things:

1. remove the element with the index 0.
2. remove all elements to the left, renumber them from the index 1 to 0, from 2 to 1 and so on.
3. Update the length property.

The more elements in the array, the more time to move them, more in-memory operations.

The similar thing happens with unshift: to add an element to the beginning of the array, we need first to move existing elements to the right, increasing their indexes.

and what's with push/pop? They don't need to move anything, To extract an element from the end, the pop method cleans the index and shrotens length. These are the actions for the pop operation!

> the pop method does not need to move anything, because other elements keep their indexes. That's why it's blazingly fast. Similar thing with the push method.

LOOPS

one of the oldest ways to circle array itens is the for loop over indexes:

let arr = ["Apple", "Orange", "Pear"];

for (let i = 0; i < arr.length; i++) {
	alert( arr[i] );
}

but for arrays there is another form of loop, for..of:

let fruits = ["Apple", "Orange", "Plum"];

// iterates over array object

for (let fruit of fruits) {
	alert( fruit );
}

the for .. of loop doesn't give access to the number of the current element, just its value, but in most cases that's enough. And it's shorter.

Technically, because arrays are objects, it is also possible to use for..in

let arr = ["Apple", "Orange", "Pear"];
for (let key in arr) {
	alert( arr[key] ); // Apple, Orange, Pear
}

But that's actually a bad idea. There are potential problems with it:

1. The loop for..in iterates over all properties, not only the numeric ones. There are so called 'array-like' objects in the browser and in other environments, that look like arrays. That is, they have length and indexes properties, but they may also have other non-numeric properties and methods, which we usually don't need. The for..in loop will list them though. So if we need to work with array-like objects, then these 'extra' properties can become a problem.

2. The for..in loop is optimized for generic objects, not arrays, and thus is 10-100 times slower. Of course, it's still very fast. The speedup may only matter in bottlenecks. But still we should be aware of the difference.

Generally, we shouldn't use for..in for arrays.

A WORD ABOUT LENGTH

The length property automatically updates when we modify the array. To be precise, it is actually not the count of values in the array, but the greatest numeric index plus one. For instance, a single element with a large index gives a big length.

let fruits = [];
fruits[123] = "Apple";

alert( fruits.length ); //124

Note that we usually don't use arrays like that. Another interesting thing about the length property is that it's writable. If we increase it manually, nothing interesting happens. But if we decrease it, the array is truncated. The process is irreversible, here's the example:

let arr = [1,2,3,4,5];

arr.length = 2; // truncate to two elements

alert( arr ); // [1, 2]

arr.length = 5; // return length back
alert( arr[3] ); // undefined: the values do not exist anymore.

So, the simples way to clear the array is: arr.length = 0;

NEW ARRAY() - There is one more syntax to create an array:

let arr = new Array("Apple", "Pear", "etc");

it is rarely used, because square brackets [] are shorter. Also there's a tricky feature with it. If new Array is called with a single argument which is a number, then it creates an array without items, but with the given length. Let's see how one can shoot themself in the foot:

let arr = new Array(2); // will it create an array of [2]?

alert( arr[0] ); // undefined! no elements.

alert( arr.length ); // length 2

In the code above, new Array(number) has all elements undefined. To evade such surprises, we usually use square brackets, unless we really know that we're doing.

MULTIDIMENSIONAL ARRAYS

Arrays can have items that are also arrays. We can use it for multidimensional arrays, for example to store matrices.

let matrix = [
	[1, 2, 3],
	[4, 5, 6],
	[7, 8, 9]
];

alert( matrix[1][1] ); // 5, the central element

toString - arrays have their own implementation of toString method that returns a comma-separated list of elements.

For instance:

let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); //true

Also, if we try:

alert( [] + 1 ); // '1'
alert( [1] + 1 ); // '11'
alert( [1,2] + 1); // '1,21'

Arrays do not have Symbol.toPrimitive, neither a viable valueOf, they implement only toString conversion, so here [] becomes an empty string, [1] becomes '1' and [1,2] becomes "1,2".

When the binary plus '+' operator adds something to a string, it converts it to a string as well, so the next step looks like this:

alert( '' + 1 ); // '1'
alert( '1' + 1 ); // '11'
alert( '1,2' + 1); // '1,21'

DON'T COMPARE ARRAYS WITH ==

Arrays in JavaScript, unlike some other programming languages, shouldn't be compared with operator ==. This operator has no special treatment for arrays, it works with them as with any objects. Let's recall the rules:

* Two objects are equal == only if they're references to the same object.
* if one of the arguments of == is an object and the other one is a primitive, then the obeject gets converted to primitive, as explaind before.
* ...with an exception of null and undefined that equal == each other and nothing else.

The strict comparison === is even simpler, as it doesn't convert types. So, if we compare arrays with ==, they are never the same, unless we compare two variables that reference exactly the same array.

alert( [] == [] ); //false
alert( [0] == [0] ); //false

these arrays are technically different objects. So they aren't equal. The == operator doesn't do item-by-item comparison. Comparison with primitives may give seemingly strange results as well:

alert( 0 == [] ); // true
alert('0' == []); // false

Here, in both cases, we compare a primitive with an array object. So the array [] gets converted to primitive for the purpose of comparison and becomes an empty string ''.

Then the comparison process goes on with the primitives, as described in the type conversions chapter.

// after [] was converted to ''
alert( 0 == '' ); //true, as '' becomes converted to 0 for comparison.
alert( '0' == '' ); //false, no type conversion, because both strings.

So, how to compare arrays? That's simple, don't use the == operator. Instead, compare them item-by-item in a loop or using iteration methods explained in the next chapter.

SUMMARY

Array is a special kind of object, suited to storing and managing ordered data items.

* The declaration:

// square brackets usual
let arr = [item1, item2...];
let arr = new Array(item1, item2...);

The call to 'new Array(number)'' creates an array with the given length, but without elements.

* The length property is the array length or, to be precise, its last numeric index plus one. It is auto-adjusted by array methods.

if we shorten length manually, the array is truncated.

We can use an array as a deque with the following operations:

* push(... items) adds items to the end
* pop() removes the element from the end and returns it
* shift() removes the element from the beginning and returns it.
* unshift(... items) adds items to the beginning.

To loop over the elements of the array:

* for (let i = 0; i < arr.length; i++) - works fastest, old-browser-compatible
* for (let item of arr) - the modern syntax for items only
* for (let i in arr) - never use

To compare arrays, don't use the == operator (as well as >, < and others), as they have no special treatment for arrays. They handle them as any objects, and it's not what we usually want.

Instead you can use for..of loop to compare arrays item-by-item. we will continue with arrays and study more methods to add, remove, extract elements and sort arrays in the next chapter.

############################################################################################

ARRAY METHODS

Arrays provide a lot of methods. To make things easier, in this chapter they are split into groups.

ADD/REMOVE items

We already know methods that add and remove items from the beginning or the end:

* arr.push( ... items) - adds items to the end.
* arr.pop() - extracts an item from the end.
* arr.shift() - extracts an item from the beginning.
* arr.unshift( ... items) - adds items to the beginning.

now the new ones:

SPLICE

How to delete an element of the array? There arrays are objects, so we can try to use delete:

let arr = ["I", "go", "home"];
delete arr[1]; // remove 'go'
alert( arr[1] ); // undefined

// now arr = ["I", , "home"];
alert( arr.length ); // 3

The element was removed, but the array still has 3 elements, we can see that the lenght = 3.

That's natural, because delete obj.key removes a value by the key. It's all it does. Fine for objects, but for arrays we usually want the rest of elements to shift and occupy the freed place. WE expect to have a shorter array now.

So, special methods shouls be used.

The arr.splice method is a swiss army knife for arrays. It can do everything: insert, remove and replace elements. The syntax is:

arr.splice(start[, deleteCount, elem1, ..., elemN])

It modifies arr starting from the index start:, removes deleteCount elements and then inserts
elem1, ..., elemN at their place. Returns the array of removed elements. This method is easy to grasp by examples.

let arr = ['a', 'b', 'c'];
arr.splice(1,1); // from index 1 remove 1 element
alert(arr); ['a', 'b'].

Easy right? starting from index 1 it removed 1 element.
In the next example remove 3 elements and replace them with the other two:

let arr = ['a', 'b', 'c'];
// remove 3 first elements and replace them with other elements
arr.splice(0, 3, 'd', 'e');

alert(arr); // now ['d', 'e'];

Here we can see that splice returns the array of removed elements:

#
let arr = ['a', 'b', 'c'];
let removed = arr.splice(0, 2);

alert( removed ); // ['a', 'b'];
#

the splice method is also able to insert the elements without any removals. For that we need to set deleteCount to 0:

#
let arr = ['a', 'b', 'c'];

// from index 2
// delete 0
// then insert 'd', 'e'

arr.splice(2, 0, 'complex', 'language');

alert( arr ); // ['a', 'b', 'd', 'e', 'c'];
#

(i) negative indexes allowed.

Here and in other array methods, negative indexes are allowed. They specify the position 
from the end of the array

#
let arr = [1, 2, 3];

// from index -1 (one step from the end)
// delete 0 elements
// then insert 3 and 4

arr.splice(-1, 0, 3, 4);
alert( arr ); // 1, 2, 3, 4, 5

<><>

SLICE

The method arr.slice is much simpler than similar-looking arr.splice.

#
arr.slice([start], [end]);
#

it returns a new array copying to it all items from index start to end (NOT INCLUDING END). Both start and end can be negative, in that case position from array end is assumed. It's similar to a string method str.slice, but instead of substrings it makes subarrays.

For instance:

#
let arr = ['t', 'e', 's', 't'];
alert(arr.slice(1, 3)); // e, s (copy from 1 to 3)
alert(arr.slice(-2)); // s, t copy from -2 till the end
#

we can also call it withuot arguments. arr.slice() creates a copy of arr. That's often used to
obtain a copy for further transformations that should not affect the original array.

<><>

CONCAT

The method arr.concat creates a new array that includes values from other arrays and additional items.

#
arr.concat(arg1, arg2...)
#

it accepts any number of arguments - either arrays or values.

The result is a new array containing items from arr, then arg1, arg2, etc.

If an argument argN is an array, then all its elements are copied. Otherwise, the argument itself is copied.

let arr = [1, 2];

// create an array from: arr and [3, 4]
alert( arr.concat([3, 4])); // 1, 2, 3, 4

// create an array from: arr and [3, 4] and [5, 6]
alert( arr.concat([3, 4], [5, 6])); // 1, 2, 3, 4, 5, 6

// create an array from: arr and [3, 4] then add values 5 and 6
alert( arr.concat([3, 4], 5, 6)); // 1, 2, 3, 4, 5, 6

Normally, it only copies elements from arrays. Other objects, even if they look like arrays, are added as a whole.

let arr = [1, 2];

let arrayLike = {
	0: 'something',
	length: 1
};

alert( arr.concat(arrayLike)); // 1, 2, [object Object]

... but if an array-like object has a special Symbol.isConcatSpreadable property, then it is treated as an array by concat: its elements are added instead:

let arr = [1, 2];
let arrayLike = {
	0: 'something',
	1: 'else', 
	[Symbol.isConcatSpreadable]: true,
	length: 2
};

alert( arr.concat(arrayLike)); // 1, 2, something, else

<><>

ITERATE: FOREACH

The arr.ForEach method allows to run a function for every element of the array

#
arr.ForEach(function(item, index, array) {
	// ... do something with item
});
#

for instance, this shows each element of the array:

// for each element call alert

#
let array = ['a', 'b', 'c'];
array.forEach(alert);
#

and this code is more elaborate about their positions in the target array:

#
['Bilbo', 'Gandalf', 'Nazgul'].forEach((item, index, array) => {
	alert(`${array} is at index ${index} in ${array}`);
})

The result of the function is thrown away and ignored.

<><> Now lets cover methods that search in an array <><>

indexOf/lastIndexOF and Includes

the methods arr.indexOf, arr.lastIndexOf and arr.includes have the same syntax and do essentially the same as their string counterparts, but operate on items instead of characters.

* arr.indexOf(item, from) - looks for item starting from index from, and returns the index where it was found, otherwise returns -1

* arr.lastIndexOf(item, from) - same,but looks for from right to left

* arr.includes(item, from) - looks for item starting from index from, returns true if found

#
let arr = [1, 0, false];
alert( arr.indexOf(0) ); //1
alert( arr.indexOf(false)); //2
alert( arr.indexOf(null)); //-1
alert( arr.includes(1)); //true
#

note that methods use === comparison. So if we look for 'false' it finds exaclty false, and not the zero. If we want to check for inclusion, and don't want to know the exact index, then arr.includes is preferred. Also a very minor difference of includes is that it correctly handles NaN, unlike indexOf/lastIndexOf

const arr = [NaN];
alert( arr.indexOf(NaN)); // -1 (should be 0, but === doesn't work for NaN);
alert( arr.includes(NaN)); // true (correct)

<><>

FIND and FINDINDEX

imagine we have an array of objects. How do we find an object with the specific condition? Here the arr.find(fn) method comes in handy.

#
let result = arr.find(function(item, index, array) {
	// if true is returned, item is returned and iteration is stopped
	// for falsy scenario returns undefined
});
#

the function is called for elements of the array, one after another:

* item is the element
* index is its index
* array is the array itself

If it returns true, the search is stopped, the item is returned. if nothing found, undefined is returned. For example, we have an array of users, each with the fields id and name. Let's try to find the one with id == 1;

#
let users = [
	{id: 1, name: "John"},
	{id: 2, name: "Pete"},
	{id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);
alert(user.name); // John
#

In real life arrays of objects is a common thing, so the find method is very useful. Note that in the example we provide to find the function item => item.id == 1 with one argument. That's typical, other arguments of this function are rarely used.

The arr.findIndex method is essentially the same, but it returns the index where the element
was found instead of the element itself and -1 is returned when nothing is found.

<><>

FILTER

the find method looks for a single (first) element that makes the function return true. If there may be many, we can use arr.filter(fn). The syntax is similar to find, but filter returns an array of all matching elements:

let results = arr.filter(function(item, index, array) {
	// if true item is pushed to results and the iteration continues
	// returns tempty array if nothing found
});

For instance:

#
let users = [
	{id: 1, name: "John"},
	{id: 2, name: "Pete"},
	{id: 3, name: "Mary"},
];

//returns array of first two users

let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
#

<><>

TRANSFORM AN ARRAY

Let's more on to methods that transform and reorder an array. 

* map - arr.map method is one of the most useful and often used. It calls the function for
each element of the array and returns the array of results. The syntax is:

let result = arr.map(function(item, index, array) {
	// returns the new value instead of item
});

For instance, here we transform each element into its length:

#
let lengths = ['Bilbo', 'Gandalf', 'Nazgul'].map(item => item.length);
alert(lengths); // 5,7,6
#

* sort(fn) - The call to arr.sort() sorts the array in place, changing its element order. it also returns the sorted array, but the returned value is usually ignored, as arr itself is modified.

For instance:

#
let arr = [ 1, 2, 15 ];

// the method reorders the content of arr
arr.sort();

alert( arr ); // 1, 15, 2
#

The items are sorted as strings by default. Literally, all elements are converted to strings for comparisons. For strings, lexicographic ordering is applied and indeed "2" > "15". To use our own sorting order, we need to supply a function as the argument of arr.sort().

The function should compare two arbitrary values and return:

#
function compare(a, b) {
	if (a > b) return 1; // if the first value is greater than the second
	if (a == b) return 0; // if values are equal
	if (a < b) return -1; // if the first value is less than the second
}
#

for instance, to sort as numbers:

function compareNumeric(a, b) {
	if(a > b) return 1;
	if(a == b) return 0;
	if(a < b) return -1;
}

let arr = [ 1, 2, 15];
arr.sort(compareNumeric);

alert(arr); // 1, 2, 15

Now it works as intended. Let's step aside and think what's happening. The arr can be array of anything, right? It may contain numbers or strings or objects or whatever. We have a set of some items. To sort it, we need an ordering function that knows how to compare its elements. The default is a string order.

the arr.sort(fn) method implements a generic sorting algorithm. We don't need to care how it
internally works (an optimized quicksort or Timsort most of the time). It will walk the array, compare its elements using the provided function and reorder them, all we need is to provide the fn which does the comparison.

By the way, if we ever want to know which elements are compared - nothing prevents from alerting them:

#
[1, -2, 15, 2, 0, 8].sort(function(a, b){
	alert( a + " <> " + b);
	return a - b;
});
#

The algorithm may compare an element with multiple others in the process, but it tries to make as few comparisons as possible.

(i) a comparison function may return any number - actually, a comparison function is only required to return a positive number to say 'greater' and a negative number to say 'less'. 

That allows to write shorter functions:

#
let arr = [1, 2, 15];

arr.sort(function(a, b) { return a - b; });
alert(arr); // 1, 2, 15
#

(i) Arrow functions for the best - remember arrow functions? we can use them here for neater sorting:

arr.sort((a, b) => a - b);

This works exactly the same as the longer version above.

(i) use localeCompare for strings - remember strings comparison algorithm? it compares letters by their codes by default. For many alphabets, it's better to use str.localeCompare method for correctly sorting letters, such as Ö. For example, let's sort a few countries in German:

#
let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (wrong)

alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (correct!)
#

<><>

REVERSE

The method arr.reverse reverses the order of elements in arr. For instance:

#
let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5, 4, 3, 2, 1
#

It also returns the array arr after the reversal.

<><>

SPLIT AND JOIN

Here's the situation from real life. We are writing a messaging app, and the person enters the comma-delimited list of receivers: John, Pete, Mary. But for us an array of names would be much more comfortable than a single string. how to get it?

The str.split(delim) method does exactly that. It splits the string into an array by the given delimiter delim. In the example below we split by a comma followed by a space:

let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');

for (let name of arr) {
	alert(`A message to ${name}.`); // A message to Bilbo (and other names)
}

The split method has an optional second numeric argument - a limit on the array length. If it is provided, then the extra elements are ignored. In practice, it is rarey used though.

#
let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
#

(i) Split into letters - The call to split(s) with an empty s would split the string into an array of letters:

#
let str = "test";

alert( str.split('') ); // t,e,s,t
#

The call arr.join(glue) does the reverse to split. It creates a string of arr items joined by 'glue' between them.

For instance:

let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';'); // glue the array into a string using ; 

alert( str ); // Bilbo;Gandalf;Nazgul

<><>

REDUCE / REDUCERIGHT

when we need to iterate over an array - we can use forEach, for or for..of.

When we need to iterate and return the data for each element - we can use map

the methods arr.reduce and arr.reduceRight also belong to that breed, but are a little bit more intricate. They are used to calculate a single value based on the array:

let value = arr.reduce(function(accumulator, item, index, array) {
	// ...
}, [initial]);

The function is applied to all array elements one after another and 'carries on' its result to the next call.

arguments:

* accumulator - is the result of the previous function call, equals initial the first time (if initial is provided).
* item - is the current away item.
* index - is its position.
* array - is the array.

as function is applied, the result of the previous funcion call is passed to the next one as the first argument. So, the first argument is essentially the accumulator that stores the combined result of all previous executions. and at the end it becomes the result of reduce.

#
let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
#

The function passed to reduce uses only 2 arguments, that's typically enough. LEt's see the details of what is going on:

1. On the first run, sum is the initial value (the last argument of reduce), equals 0, and current is the first array element, equals 1. So the function result is 1.

2. On the second run, sum = 1. We add the second array element (2) to it and return.

3. On the 3rd run, sum = 3 and we add one more element to it, and so on...

The calculation flow:

sum 0
current 1

\/

sum 0 + 1
current 2

\/

sum 0 + 1 + 2
current 3

\/

sum 0 + 1 + 2 + 3
current 4

\/ 

sum 0 + 1 + 2 + 3 + 4
current 5

total = 15



                sum	current	result
the first call	0	1	1
the second call	1	2	3
the third call	3	3	6
the fourth call	6	4	10
the fifth call	10	5	15

Here we can clearly see how the result of the previous call becomes the first argument of the next one. We also can omit the initial value:

#
let arr = [1, 2, 3, 4, 5];

//removed intial value from reduce (no 0)

let result = arr.reduce((sum, current) => sum + current);

alert( result ); // 15
#

The result is the same. That's because if there's no initial , then reduce takes the first element of the array as the initial value and starts the iteration from the 2nd element.

the calculation table is the same as above, minus the first row. But such use requires an extreme care. If the array is empty, then reduce call without initial value gives an error.

here:


#
let arr = [];

// Error: reduce of empty array with no initial value
// if the initial value existed, reduce wold return it for the empty array

arr.reduce((sum, current) => sum + current);
#

So it's advised to always specify the initial value. The method arr.reduceRight does the same, but goes from the right to the left.

<><>

Array.isArray

Arrays do not form a separate language type. They are based on objects. So typeof does not helo to distinguish a plain object from an array:

alert(typeof {}); // object
alert(typeof []); // same
... but arrays are used so often that there's a special method for that: Array.isArray(value). It returns true if the value is an array and false otherwise.

alert(Array.isArray({})); //false
alert(Array.isArray([])); //true

<><>

MOST METHODS SUPPORT 'thisArg'

Almost all array methods that call functions - like find, filter, map, with a notable exception of sort, accept an optional additional parameter thisArg.

That parameter is not explained in the sections above, because it is rarely used. But for completeness we have to cover it. Here's the full syntax of these methods:

arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);

// ...
// thisArg is the optional last argument

the valur of thisArg parameter becomes this for func

for example, here we use a method of army object as filte,r and thisArg passes the context:

#
let army = {
	minAge: 18,
	maxAge: 27,
	canJoin(user) {
		return user.age >= this.minAge && user.age < this.maxAge;
	}
};

let users = [
	{age: 16},
	{age: 20},
	{age: 23},
	{age: 30}
];

// find users, for who army.canJoin returns true
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23

#


If in the example above we used users.filter(army.canJoin), then army.canJoin would be called as a standalone function, with this=undefined, thus leading to an instant error.

A call to users.filter(army.canJoin, army) can be replaced with users.filter(user => army.canJoin(user)), that does the same. The latter is used more often, as it's a bit easier to understand for most people.


SUMMARY

a cheat sheet of array methods:

* To add/remove elements:

** push(... items) - adds items to the end,
** pop() - extracts an item from the end,
** shift() - extracts an item from the beginning,
** unshift(... items) - adds items to the beginning,
** splice(pos, deleteCount, ...items) - at index pos, deletes deleteCount elements and inserts items
** slice(start, end) - creates a new array, copies elements from index start till end (not inclusive) into it
** concat(...items) - returns a new array: copies all members of the current one and adds items to it. If any of items is an array, then its elements are taken

* To search among elements:

** indexOf/lastIndexOf(item, pos) - look for item starting from position pos, return the index or -1 if not found
** includes(value) - returns true if the array has value, otherwise false
** find/filter(func) - filter elements through the function, return first/all values that make it return true.
** findIndex is like find, but returns the index instead of a value

* To iterate over elements:

** forEach(func) - calls func for every element, does not return anything

* To transform the array:

** map(func) - creates a new array from the results of calling func for every element
** sort(func) - sorts the array in-place, then returns it
** reverse() - reverses the array in-place, then returns it
** split/join - converts a string to array and back.
** reduce/reduceRight(func, initial) - calculate a single value over the array by calling func for each element and passing an intermediate result between the calls.

* additionally:

** Array.isArray(arr) checks arr for being an array.

Please not that the methods sort, reverse and splice modify the array itself. These methods are the most used ones, they cover 99% of use cases. But there are a few others:

* arr.some(fn) / arr.every(fn) check the array

The function fn is called on each element of the array similar to map. If any / all results are true, returns true, otherwise, false.

These methods behavor sort of like || and && operatores: if FN returns a truthy value, arr.some() immediately returns true and stops iterating over the rest of items; if fn returns a falsy value, arr.every() immediately returns false and strops iterating over the rest of items as well.

We can use every to compare arrays:

function arraysEqual(arr1, arr2) {
	return arr1.length === arr.lenght && arr1.every((value, index) => value === arr2[index]);
}

alert( arraysEqual([1,2], [1,2])); // true

* arr.fill(value, start, end) - fills the array with repeating value from index start to end
* arr.copyWithin(target, start, end) - copies its elements from position start till position end into ITSELF, at position target (overwrites existing array).
* arr.flat(depth)/arr.flatMap(fn) create a new flat array from a multidimensional array.

for the full list, as always, see the manual.

From the first sight it may seen that tere are so many methods, quite difficult to remembet. But actually that's much easier. Look through the cheat sheet just to be aware of them. Then solve the tasks of this chapter to practice, so that you have experienced with array methods. Afterwards whenever you need to do something with an array, and you don't know how, come here. look at the cheat sheet and find the right method.

Examples will help you to write it correctly, soon you will automatically remember these methods, without specific efforts from your side.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>


Iterables

Iterable objects are a generalization of arrays. That's a concept that allows us to make any objects useable in a for...of loop. Of course, arrays are iterable, but there are many other built-in objects
that are iterable as well. For instance, strings are also iterable.

If an object isn't technically an array, but represents a collection (list, set) of something, then
for..of is a great syntax to loop over it, so let's see how to make it work.

<><>

SYMBOL.ITERATOR

We can easily grasp the concept of iterables by making one of our own. For instance, we have an object
that is not an array, but looks suitable for for...of. Like a range object that represents an interval
of numbers:

let range = {
	from: 1, 
	to: 5
};

// we want the for...of to work:
// for(let num of range) ... num=1,2,3,4,5

To make the range object iterable (and thus let for..of work) we need to add a method to the object named
Symbol.iterator ( a special bult-in symbol just for that).

1. When for..of starts, it calls that method once (or errors if not found). The method must return an 
iterator - an object with the method next.

2. Onward, for..of works only with that returned object.

3. When for..of wants the next value, it calls next() on that object.

4. The result of next() must have the form {done: Boolean, value: any}, where done=true means that the
iteration is finished, otherwise value is the next value.

Here's the full implementation for range with remarks:

#
let range = {
	from: 1,
	to: 5
};

// 1. call to for..of initially calls this
range[Symbol.iterator] = function() {
	
	// ...it returns the iterator object:
	// 2. Onward, for..of works only with this iterator, asking it for next values
	return {
		current: this.from,
		last: this.to,

		// 3. next() is called on each iteration by the for..of loop
		next() {
			// 4. it should return the value as an object {done:.., value:...}
			if (this.current <= this.last) {
				return { done: false, value: this.current++ };
			} else {
			  return {done: true};
			}
		}
	};
};

// now it works!

for (let num of range) {
	alert(num); // 1, then 2, 3, 4, 5
}
#

Please note the core features of iterables: separation of concerns

* the range itself does not have the next() method.
* instead, another object, a so-called 'iterator' is created by the call to range[Symbol.iterator](),
and its next() generates values for the iteration.

So, the iterator object is separate from the object it iterates over. Technically, we may merge them and
use range itself as the iterator to make the code simpler. Like this:

let range = {
	from: 1,
	to: 5,

	[Symbol.iterator]() {
		this.current = this.from;
		return this;
	},

	next() {
		if (this.current <= this.to) {
			return { done:false, value: this.current++};
		} else {
			return { done: true };
		}
	}
};

for (let num of range) {
	alert(num); // 1, then 2, 3, 4, 5
}

Now range[Symbol.iterator]() returns the range object itself: it has the necessary next() method and
remembers the current iteration progress in this.current. Shorter? Yes. Ans sometimes that's fine too.

The downside is that now it's impossible to have two for..of loops running over the object simultaneously:
they'll share the iteration state, because there's only one iterator - the object itself. But two parallel for ofs is a rare thing, even in async scenarios.

(i) Infinite Iterators - Infinite iterators are also possible. For instance, the range becomes infinite
for range.to = Infinity. Or we can make an iterable object that generates an infinite sequence of pseudorandom numbers. Also can be useful.

There are no limitations on next, it can return more and more values, that's normal.
Of course, the for..of loop over such an iterable would be endless. But we can always stop it using break.

<><>

String is Iterable

Array and strings are most widely used built-in iterables. For a string, for..of loops over it's characters:

#
for (let chat of 'test') {
	// triggers 4 times: once for each character
	alert( char ); // t, then e, then s, then t
}
#

And it works correctly with surrogate pairs!

let str = '𝒳😂';
for (let char of str) {
    alert( char ); // 𝒳, and then 😂
}

Calling an Iterator Explicitly

For deeper understanding, let's see how to use an iterator explicitly. We'll iterate over a string in
exactly the same way as for..of, but with direct calls. This code creates a string iterator and gets values
from it 'manually':

let str = 'Hello';

// does the same as
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
	let result = iterator.next();
	if (result.done) break;
	alert(result.value); // outputs characters one bye one
}

That is rarely needed, but gives us more control over the process than for..of. For instance, we can 
split the iteration process: iterate a bit, then stop, do something else, and then resume later.

Iterables and Array-Likes

Two official terms look similar, but are very different. Please make sure you understand them well to avoid the confusion.

* iterables are objects that implement the Symbol.iterator method, as described above.
* Array-Like are objects that have indexes and length, so they look like arrays

When we use JavaScript for practical tasks in a browser or any other environment, we may meet objects
that are iterables or array-likes or both.

For instance, strings are both iterable and array-like. But an iterable may be not array-like and vice versa. array-like may be not iterable.

For example, the range in the example above is iterable, but not array-like, because it does not have indexed properties and length.

And here's the object that is array-like, but not iterable:

let arrayLike = {
	0: "Hello",
	1: "World",
	length: 2
};

// ERROR (no Symbol.iterator)
for (let item of arrayLike) {}

Both iterables and array-likes are usually not arrays, they don't have push, pop, etc. That's rather inconvenient if we have such an object and want to work with it as with an array. We would like to work with range using array methods. how to achieve that?

<><>

ARRAY.FROM

There's a universal method, Array.from that takes an iterable or array-like value and makes a 'real' Array from it. Then we can call array methods on it. For instance:

let arrayLike = {
	0: 'Hello',
	1: 'World',
	length: 2
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World (method works)

Array.from at the line (*) takes the object, examines it for being an iterable or array-like, then makes a new array and copies all items to it.

The same happens for an iterable:

// assuming that range is taken from the example above

let arr = Array.from(range);
alert(arr); // 1, 2, 3, 4, 5 (array toString conversion)

the FULL syntax for Array.from also allows us to provide an optional 'mapping' function:

Array.from(obj[, mapFn, thisArg])
The optional second argument mapFn can be a function that will be applied to each elemnt before adding it to the array, and thisArg allows to set this for it.

For instance:

#
// assmung that range is taken from the example above
// square each number
let arr = Array.from(range, num => num * num);

alert(arr); // 1, 4, 9, 16, 25
#

Here we use Array.from to turn a string into an array of characters:

#
let str = '𝒳😂';

// splits str into array of characters
let chars = Array.from(str);

alert(chars[0]); // 𝒳
alert(chars[1]); // 😂
alert(chars.length); // 2
#

unlike str.split, it relies on the iterable nature of the string and so, just like for..of, correctly
works with surrogate pairs.

technically here it does the same as:

#
let str = '𝒳😂';

let chars = []; // Array.from internally does the same loop
for (let char of str) {
  chars.push(char);
}

alert(chars);
#

... but it is shorter. We can even build surrogate-aware slice on it:

#
function slice(str, start, end) {
  return Array.from(str).slice(start, end).join('');
}

let str = '𝒳😂𩷶';

alert( slice(str, 1, 3) ); // 😂𩷶

// the native method does not support surrogate pairs
alert( str.slice(1, 3) ); // garbage (two pieces from different surrogate pairs)
#

SUMMARY!

Objects that can be used in for..of are called iterable. 

* Technically, iterables must implement the method named Symbol.iterator.
** The result of obj[Symbol.iterator]() is called an iterator. It handles further iteration process.
** An iterator must have the method named next() that returns an object {done: Boolean, value: any}, here
done:true denotes the end of the iteration process, otherwise the value is the next value.

* The Symbol.iterator method is called automatically by for..of, but we also can do it directly.
* Built-in iterables like strings or arrays, also implement Symbol.iterator
* String iterator knows about surrogate pairs.

Objects that have indexed properties and length are called array-like. Such objects may also have other properties and methods, but lack the built-in methods of arrays.

If we look inside the specification - we'll see that most built-in methods assume that they work with iterables or array-likes instead of 'real' arrays, because that's more abstract.

Array.from[obj[, mapFn, thisArg]) makes a real Array from an iterable or array-like obj, and we can then use array methods on it. The optional arguments mapFn and thisArg allow us to apply a function to each item.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Map and Set

Till now, we've learned about the following complex data structures:

* objects are used for storing keyed collections
* arrays are used for storing ordered collections

But that's not enough for real like. That's why Map and Set also exist.

Map

Map is a collection of keyed data items, just like an Object. But the main differente is that Map allows keys of any type. Methods and properties are:

* new Map() - creates the map.
* map.set(key, value) - stores the value by the key.
* map.get(key) - returns the value by the key, undefined if key doesn't exist in map
* map.has(key) - returns true if the key exists, false otherwise
* map.delete(key) - removes the value by the key.
* map.clear() - removes everything from the map.
* map.size - returns the current element count.

For instance:

#
let map = new Map();

map.set('1', 'str1'); // a string key
map.set(1, 'num1');   // a numeric key
map.set(true, 'bool1'); // a boolean key

// remember the regular Object? it would convert keys to a string
// map keeps the type, so these two are different:

alert( map.get(1) ); // 'num1'
alert( map.get('1')); // 'str1'

alert( map.size ); // 3
#

As we can see, unlike objects, keys are not converted to strings. Any type of key is possible.

(i) map[key] isn't the right way to yse a Map - Although map[key] also works, e.g. we can set map[key] = 2, this is treating map as a plain JavaScript object, so it implies all corresponding limitations (only string/symbol keys and so on). So we should use map methods: set, get and so on.

Map can also use objects as keys.

For instance:

#
let john = { name: "John" };

// for every user, let's store their visits counter
let visitCountMap = new Map();

// johnis the key for the map

visitsCountMap.set(john, 123);
alert( visitsCountMap.get(john) ); // 123
#

Using objects as keys is one of the most notable and important Map features. The same does not count for Object. String as a key in Object is fine, but we can't use another Object as a key in Object.

Let's try:

#
let john = { name: "John" };
let ben = { name: "Ben" };

let visitsCountObj = {}; // try to use an object

visitsCountObj[ben] = 234;
visitsCountObj[john] = 123;

// that's what got written!
alert( visitsCountObj["[object Object]"]); // 123
#

as visitsCountObj is an objct, it convers all Object keys, such as john and ben above, to same string "[object Object]". Definitely not what we want.

(i) how map compares keys. TO test keys for equivalente Map uses the algorithm SameValueZero. It is roughly the same as strict equality ===, but the difference is that NaN is considered equal to Nan. SO it can be used as a key as well.

(i) Chaining - every map.set call returns the map itself, so we can 'chain' the calls:

map.set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');

<><>

ITERATION OVER MAP

For looping over a map, there are 3 methods: 

* map.keys() - returns an iterable for keys
* map.values() - returns an iterable for values
* map.entries() - returns an iterable for entries [key, value], it's used by default in for..of.

For instance:

let recipeMap = new Map([
	['cucumber', 500],
	['tomatoes', 350],
	['onion', 50]
]);

// iterate over keys (vegetables)
for (let vegetable of recipeMap.keys()) {
	alert(vegetable); // cucumber, tomatores, onion
}

// iterate over values (amuonts)
for (let amount of recipeMap.values()) {
	alert(amount); // 500, 350, 50
}

// iterate over [key, value] entries
for (let entry of recipeMap) { // the same as of recipe.Map.entries()
	alert(entry); // cucumber, 500 (and so on)
}

(i) The insertion order is used - the iteration goes in the same order as the values were inserted.
Map preserves this order, unlike a regular Object

Besides that, Map has a built-in forEach method similar to Array:

// runs the function for each (key, value) pair
recipeMap.forEach((value, key, map) => {
	alert(`${key}: ${value}`); // cucumber: 500 etc
});

<><>

OBJECT.ENTRIES: MAP FROM OBJECT

When a Map is created, we can pass an array (or another iterable) with key/value pairs for initialization.

// array of [key, value] pairs

let map = new Map([
	['1', 'str1'],
	[1, 'num1'],
	[true, 'bool1']
]);

alert( map.get('1') ); //str1

If we have a plain object, and we'd like to create e Map from it, then we can use built-in method
Object.entries(obj) that returns an array of key/value pairs for an object exactly in that format.

So we can create a map from an object like this:

let obj = {
	name: "John",
	age: 30
};

let map = new Map(Object.entries(obj));

alert( map.get('name') ); // John tarkov

Here, Object.entries returns the array of key/value pairs: ['name', 'john'], ['age', 30]. That's what
Map needs.

<><>

Object.fromEntries: Object from Map

We've just seen how to create Map from a plain object with Object.entries(obj). There's Object.fromEntries method that does the reverse: given an array of [key, value] pairs, it creates an object from them:

#
let prices = Object.fromEntries([
	['banana', 1],
	['orange', 2],
	['meat', 4],
]);

// now prices = {banana:1, orange:2, meat:4}

alert(prices.orange); //2
#

We can use Object.fromEntries to get a plain object from Map. E.g. we store the data in a Map, but we need to pass it to a 3rd-party code that expects a plain object. Here we go:

#
let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // make a plain object

// done!
// obj = { banana:1, orange:2, meat:4}

alert(obj.orange); // 2
#

A call to map.entries() returns an iterable of key/value pairs, exactly in the right format for Object.fromEntries. We could also make line (*) shorter:

#
let obj = Object.fromEntries(map); // omit .entries()
#

That's the same because Object.fromEntries expects an iterable object as the argument. Not necessarily an array. And the standard iteration for map returns same key/value pairs as map.entries(). So we get a plain object with same key/value as the map.

<><>

SET

A set is a special type collection - 'set of values' (without keys), where each value may occur only once.

Its main methods are:

* new Set(iterable) - creates the set and if an iterable object is provided (usually an array), copies values from it into the set
* set.add(value) - adds a value, returns the set itself.
* set.delete(value) - removes the value, returns true if valur existed at the moment of the call, otherwise returns false
* set.has(value) - returns true if the value exists in the set otherwise false.
* set.clear() - removes everything from the set
* set.size() - is the elements count

The main feature is that repeated calls of set.add(value) with the same value don't do anything. That's the reason why each value appears in a Set only once.

For example, we have visitors coming, and we'd like to remember everyone. But repeated visits should not lead to duplicates. A visistor must be 'counted' only once.

Set is just the right thing for that:

#
let set = new Set();

let john = {name:"John"};
let pete = {name:"Pete"};
let mary = {name:"Mary"};

// visits, some users come multiple times
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set keeps only unique values
alert( set.size ); //3

for (let user of set) {
	alert(user.name); // John (then Pete and Mary)
}
#

The alternative to Set could be an array of users, and the code to check for duplicates on every insertion using arr.find. But the performance would be much worse, because this method walks through the whole array checking every element. Set is much better optimized internally for uniqueness checks.

<><>

ITERATION OVER SET

We can loop over a set either with for..of or using forEach:

#
let set = new Set(['oranges', 'apples', 'bananas']);

for (let value of set) alert(value);

// the same with forEach:

set.forEach((value, valueAgain, set) => {
	alert(value);
});
#

Note the funny thing. The callback function passed in forEach has 3 arguments: a value, then 'the same value' valueAgain, and then the target object. Indeed the same value appears in the arguments twice.

That's for compatibility with Map where the callback passed forEach has three arguments. Looks a bit strange, for sure. But may help to replace Map with Set in certain cases with ease, and vice versa.

The same methods Map has for iterators are also supported:

* set.keys() - returns an iterable object for values,
* set.values() - same as set.keys(), for compatibility with Map,
* set.entries() - returns an iterable object for entries [value, value], exists for compatibility with Map

SUMMARY

Map - is a collection of keyed values. Methods and properties:

* new Map([iterable]) - creates the map, with optional iterable (e.g. array) of [key, value] pairs of initialization.
* map.set(key, value) - stores the value by the key, returns the map itself.
* map.get(key) - returns the value by the key, undefined if key doesn't exist in map.
* map.has(key) - returns true if the key exists, false otherwise.
* map.delete(key) - removes the value by the key, returns true if key existed at the moment of the call, otherwise false.
* map.clear() - removes everything from the map.
* map.size - returns the current element count.

The difference from a regular Object: any keys, objects can be keys. Additional conveninent methods, the size property

Set - is a collection of unique values - Methods and properties:

* new Set([iterable]) - creates the set, with optional iterable (e.g. array) of values for initialization.
* set.add(value) - adds a value (does nothing if value exists), returns the set itself.
* set.delete(value) - removes the value, returns true if value existed at the moment of the call, otherwise false
* set.has(value) - returns true if the value exists in the set, otherwise false.
* set.clear() - removes everything from the set.
* set.size - is the elements count.

Iteration over Map and Set is always in the insertion order, so we can't say that these collections are unordered, but we can't reorder elements or directly get an element by its number.


<><><><><><><>

WEAKMAP AND WEAKSET

As we know from the chapter Garbage Collection, Javascript engine keeps a value in memory while it is 'reachable' and can potentially be used. For instance:

#
let john = { name: "John" };

// the object can be accessed, john is the reference to it

// overwrite the reference
john = null;

// the object will be removed from memory
#

Usually, properties of an object or elements of an array or another data structure are considered reachable and kept in memory while that data structure is in memory. For instance, if we put an object into an array, then while the array is alive, the object will be alive as well, even if there are no other references to it.

#
let john = { name: "John" };

let array = [ john ];

john = null; // overwrite the reference

// the object previously referenced by john is stored inside the array
// therefore it won't be garbage-collected
// we can get it as array[0]
#

Similar to that, if we use an object as the key in a regular Map, then while the Map exists, that object exists as well. It occupies memory and may not be garbage collected.

For instance:

let john = {name: 'john'};
let map = new Map();
map.set(john, "...");

john = null; // overwrite the reference

// john is stored inside the map, we can get it by using map.keys();

WeakMap is fundamentally different in this aspect, it doesn't prevent garbage-collection of key objects.
let's see what it means on examples:

<><> WeakMap

The first differente between Map and WeakMap is that key must be objects, not primitive values.

#
let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, 'ok'); // works fine (object key)

// can't use a string as the key
weakMap.set('test', 'whoops'); // error, because 'test' is not an object
#

<>
now if we use an object as the key in it, and there are no other references to that object - it will be removed from memory (and from the map) automatically.
<>

#
let john = {name:"john"};

let weakMap = new WeakMap();
weakMap.set(john, '...');

john = null; // overwrite the reference

// john is removed from memory!
#

Compare it with the regular Map example above. Now if john only exists as the key of WeakMap - it will be automatically deleted from the map (and memory).

WeakMap does not support iteration and methods keys(), values(), entries(), so there's no way to get all keys or values from it.

WeakMap has only the following methods:

* weakMap.get(key)
* weakMap.set(key, value)
* weakMap.delete(key)
* weakMap.has(key)

why such limitation? that's for technical reasons. If an object as lost all other references (like john in the code above), then it is to be garbage-collected automatically. But technically it's not exactly specified when the cleanup happens.

The JavaScript engine decides that. It may choose to perform the memory cleanup immediately or to wait and do the cleaning later when more deletions happen. So, technically, the current element count of WeakMap is not known. The engine may have cleaned it up or not, or did ti partially. For that reason, methods that access all keys/values are not supported.

now, where do we need such a data structure?

<><> USE CASE: additional data

The main arae of application for WeakMap is an additional data storage. IF we're working with an object that belongs to another code, maybe even a third-party library, and would like to store some data associated with it, that should only exist while the object is alive - then WeakMap is exactly what's needed.

We put the data to a WeakMap, using the object as the key, and when the object is garbage collected, that data will automatically disappear as well.

#
weakMap.set(john, 'secret documents');
// if john dies, secret documents will be destroyed automatically
#

let's look at an example - for instance, we have code that keeps a visit count for users. the information is stored in a map: a user object is the key and the visit count is the value, when a user leaves (its object gets garbage collected) we don't want to store their visit count anymore.

Here's an example of a counting function with Map:

#
// visitsCount.js

let visitsCountMap = new Map(); // map: user => visits count

// increase the visits coutn
function countUser(user) {
	let count = visitsCountMap.get(user) || 0;
	visitsCountMap.set(user, count + 1 );
}

// and here 's another part of the code, maybe another file usint it:

// main.js

let john = {name: 'john'};
countUser(john); // count his visits

// later john leaves us
john = null;
#

Now, john object should be garbage collectd, but remains in memory, as it's a key in visitsCountMap. We need to clean visitsCountMap when we remove users, otherwise it will grow in memory indefinitely, such cleaning can become a tedious task in complex architectures.

we can avoid it by switching to WeakMap instead:

// visitsCount.js

let visitsCountMap = new WeakMap(); // weakmap: user => visits coutn

// increase the visits count

function countUser(user) {
	let count = visitsCountMap.get(user)|| 0;
	visitsCountMap.set(user, count + 1);
}

Now we don't have to clean visitsCountMap. After john object becomes unreachable, by all means except as a key of WeakMap, it gets removed from memory, along with the information by that key from WeaKMap.

<><> USE CASE: CACHING

Another common example is caching. We can store ("cache") results from a function, so that future calls on the same object can reuse it.

To achieve that, we can se Map (not optimal scenario):

// cache.js

#
let cache = new Map();

// calculate and remember the result
function process(obj) {
	if(!cache.has(obj)) {
		let result = /* calculations of the result for */ obj;

		cache.set(obj, result);
	}

	return cache.get(obj);
}

// Now we use process() in another file:

// main.js
let obj = {/* let's say we have an object */};

let result1 = process(obj); // calculated

// ...later, from another place of the code...
let result2 = process(obj); // remembered result taken from cache

// ...later, when the object is not needed any more:
obj = null;

alert(cache.size); // 1 (Ouch! The object is still in cache, taking memory!)
#

For multiple calls of process(obj) with the same object, it only calculates the result the first time, and then just takes it from cache. The downside is that we need to clean cache when the object is not needed any more. If we replace Map with WeakMap, then this problem disappears. The cached result will be removed from memory automatically after the object gets garbage collected.

// cache.js
let cache = new WeakMap();

// calculate and remember the result
function process(obj) {
	if (!cache.has(obj)) {
		let result = /* calculate the result for */ obj;

		cache.set(obj, result);
	}

	return cache.get(obj);
}

// main.js
let obj = {/* some object */};

let result1 = process(obj);
let result2 = process(obj);

// ...later, when the object is not needed any more:
obj = null;

// can't get cache.size, as it's a WeakMap,
// but it's 0 or soon be 0
// when obj gets garbage collected, cached data will be removed as well

<><> WeakSet

WeakSet behaves similarly:

* it is analogous to Set, but we may only add objects to WeakSet (not primitives).
* an object exists in the set while it is reachable from somewhere else.
* like Set, it supports add, has and delete, but not size, keys() and no iterations.

Being 'weak', it also serves as additional storage. But not for arbitrary data, rather for 'yes/no' facts. a memberbership in WeakSet may mean something about the object.

For instance, we can add users to WeakSet to keep track of those who visited our site:

#
let visitedSet = new WeakSet();

let john = { name: 'John' };
let pete = { name: 'Pete' };
let mary = { name: 'Mary' };

visitedSet.add(john); // John visited us
visitedSet.add(pete); // Then Pete
visitedSet.add(john); // John again

// visitedSet has 2 users now

// check if John visited?

alert(visitedSet.has(john)); // true

// chec if Mary visited?

alert(visitedSet.has(mary)); // false

john = null;

// visitedSet will be cleaned automatically
#

The most notable limitation of WeakMap and WeakSet is the absence of iterations, and the inability to get all current content. That may appear inconvenient, but does not prevent WeakMap/WeakSet from doing their main job - be an 'additional' storage of data for objects which are stored/managed at another place.

SUMMARY!

WeakMap is Map-like collection that allows only objects as keys and removes them together with associated value once they become inaccessible by other means.

WeakSet is Set-like collection that stores only objects and removes them once they become inaccessible by other means. Their main advantaves are that they have weak reference to objects, so they can easily be removed by garbage collector.

That comes at the cost of not having support for clear, size, keys, values ...

WeakMap and WeakSet are used as 'secondary' data structures in addition to the 'primary' object storage. Once the object is removed from the primary storage, if it is only found as the key of WeakMap or in a WeakSet, it will be cleaned up automatically.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Object.keys, values, entries

Let's step away from the individual data structures and talk about the iterations over them.

In the previous chapter we saw methods map.keys(), map.values(), map.entries()

These methods are generic, there is a common agreement to use them for data structures. If we
ever create a data structure of our own, we should implement them too.

They are supported for:

* Map
* Set
* Array

Plain objects also support similar methods, but the syntax is a bit different.

Object.keys, values, entries

For plain objects, the following methods are available:

* Object.keys(obj) - returns an array of keys.
* Object.values(obj) - returns an array of values.
* Object.entries(obj) - returns an array of [key, value] pairs.

Please note that the distinctions (compared to map for example):

	             Map	             Object
Call syntax	map.keys()	Object.keys(obj), but not obj.keys()
Returns	        iterable	      “real” Array

The first differente is that we have to call Object.keys(obj), and not obj.keys().

Why so? The main reason is flexibility. Remember, objects are a base of all complex structures in JavaScript. So we may have an object of our own like data that implements its own data.values() method. And we still can call Object.values(data) on it.

The second difference is that Object.* methods return 'real' array objects, not just an 
iterable. That's mainly for historical reasons.

For Instance:

let user = {
	name: "John",
	age: 30,
};

* Objecy.keys(user) = ['name', 'age'];
* Object.values(user) = ['John', 30];
* Object.entries(user) = [ ['name', 'John'], ['age', 30]]

Here's an example of using Object.values to loop over property values:

let user = {
	name: "John",
	age: 30
};

// loop over values
for (let value of Object.values(user)) {
	alert(value); // John, then 30
}

(w) Object.keys/values/entries ignore symbolic properties - Just like a for...in loop, these methods ignore properties that use Symbol(...) as keys.

Usually that's convenient. But if we want symbolic keys too, then there's a separate method Object.getOwnPropertySymbols that returns an array of only symbolic keys. Also, there exist a method Reflect.ownKeys(obj) that returns ALL keys.

<><> Transforming Objects

Objects lack many methods that exist for arrays. e.g map, filter and others.

If we'd like to apply them, then we can use Object.entries followed by Object.fromEntries:

1 - Use Object.entries(obj) to get an array of key/value pairs from obj.
2 - Use array methods on that array e.g. map
3 - Use Object.fromEntries(array) on the resulting array to turn it back into an object.

For example, we have an object with prices and would like to double them:

let prices = {
	banana: 1, 
	orange: 2,
	meat: 4,
};

let doublePrices = Object.fromEntries(
	// convert to array, map, and then fromEntries gives back the object
	Object.entries(prices).map(([key, value]) => [key, value*2])
);

alert(doublePrices.meat); // 8

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

DESTRUCTURING ASSIGNMENT

The two most used data structures in JavaScript are Object and Array.

* Objects allow us to create a single entity that stores data items by key.
* Arrays allow us to gather data items into an ordered list.

Although, when we pass those to a function, it may need not an object/array as a whole. It may need only individual pieces.

Destructuring Assignment is a special syntax that allow us to 'unpack' arrays or objects into a bunch of variables, as sometimes that's more convenient. Destructuring also works great with complex functions that have a lot of parameters, default values, and so on. Soon we'll see that.

<><> Array Destructuring

Here's an example of how an array is destructured into variables:

#
// we have an array with the name and username
let arr = ["John", "Smith"]

// destructuring assignment
// sets firstName = arr[0]
// and surname = arr[1]

let [firstName, surname] = arr;

alert(firstName); // John
alert(surname); // Smith
#

now we can work with variables instead of array members.
It looks great when combined with split or other array-returning methods.

#
let [firstName, surname] = 'John Smith'.split(' ');
alert(firstName); // John
alert(surname); // Smith
#

As you can see, the syntax is simple. There are several peculiar details though. Let's see more examples to better understand it.

(i) 'Destructuring' does not mean 'destructive'. It's called 'destructuring assignment', because it 'destructurizes' by copying items into variables. But the array itself is not modified. It's just a shorter way to write:

#
// let [firstName, surname] = arr;
let firstName = arr[0];
let surname = arr[1];
#

(i) ignore elements using commas - unwanted elements of the array can also be thrown away via an extra comma:

// second element is not needed
let [firstName, , title] = ['Julius', 'Caesar', 'Consul', 'of The Roman Republic'];

alert( title ); // Consul

In the code above, the second element of the array is skipped, the third one is assigned to title, and the rest of the array items is also skipped (as there are no variables for them)

(i) Works with any iterable on the right-side = ...actually, we can use it with any iterable

#
let [a, b, c] = 'abc'; // ['a', 'b', 'c']
let [one, two, three] = new Set([1, 2, 3]);
#

That works, because internally a desctructuring assignment works by iterating over the right value. It's kind of syntax sugar for calling for..of over the value to the right of = and assigning the values

(i) Assign to anything at the left-side - we can use any 'assignables' at the left side. For instance, an object property:

#
let user = {};
[user.name, user.surname] = "John Smith".split(' ');

alert(user.name); // John
alert(user.surname); // Smith
#

(i) Looping with .entries()

In the previous chapter we saw that the Object.entries(obj) method. We can use it with destructuring to loop over keys-and-values of an object:

#
let user = {
	name: "John",
	age: 30
};

// loop over keys-and-values
for (let [key, value] of Object.entries(user)) {
	alert(`${key}:${value}`); // name:John, then age:30
}
#

the similar code for a Map is simpler, as it's iterable:

#
let user = new Map();
user.set("name", 'John');
user.set("age", '30');

// Map iterables as [key, value] pairs, very convenient for destructuring
for (let [key, value] of user) {
	alert(`${key}:${value}`); // name: John, then age:30
}

(i) Swap variables trick - There's a well-known trick for swapping values of two variables using a destructuring assignment.

#
let guest = 'jane';
let admin = 'pete';

// let's swap the values: make guest = Pete, admin = Jane
[guest, admin] = [admin, guest];

alert(`${guest} ${admin}`); // Pete Jane (successfully swapped!)
#

Here we create a temporary array of two variables and immediately destructure it in swapped order. We can swap more than two variables this way.

<><> The rest '...'

Usually, if the array is longer than the list at the left, the 'extra' items are ommited. For example, here only two items are taken and the rest is just ignored.

#
let [name1, name2] = ['Julius', 'Caesar', 'Consul', 'Of the Roman Republic'];

alert(name1); // Julius
alert(name2); // Caesar

// Further items aren't assigned anywhere
#

If we'd like also to gather all that follows - we can add one more parameter that gets the
rest using three dots. '...':

#
let [name1, name2, ...rest] = ['Julius', 'Caesar', 'Consul', 'of the Roman Republic'];

// rest is array of items, starting from the 3rd one
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
#

the value of rest is the array of remaining elements. We can use any other variable name in place of rest, just make sure it has three dots before it and goes last in the destructuring assignment.

#
let [name1, name2, ...titles] = ['Julius', 'Caesar', 'Consul', 'of the Roman Republic'];
// now titles = ['Consul', 'of the Roman Republic'];

<><> Default Values

If the array is shorter than the list of variables at the left, there'll be no errors. Absent values are considered undefined:

#
let [firstName, surname] = [];

alert(firstName); //undefined
alert(surname);   //undefined
#

If we want a 'default' value to replace the missing one, we can provide it using =:

#
let [name = 'guest', surname = 'anonymous'] = ['julius'];

alert(name); // julius (from array)
alert(surname); // anonymous (default used)

Default values can be more complex expressions or even function calls. They are evaluated only if the value is not provided. For instance, here we use the prompt function for two defaults:

#
// runs only prompt for surname
let [name = prompt('name?'), surname = prompt('surname?')] = ['julius'];

alert(name); // julius (from array)
alert(surname); // whatever prompt gets
#

Please note: the prompt will run only for the missing value (surname).

<><> Object Destructuring

The destructuring assignment also works with objects. The basic syntax is:

let {var1, var2} = {var1:..., var2:...}

We should have an existing object at the right side, that we want to split into variables. The left side contains an object-like 'pattern' for corresponding properties. In the simplest case, that's a list of variable names in {...}

For instance:

#
let options = {
	title: 'menu',
	width: 100,
	height: 200
};

let {title, width, height} = options;

alert(title); // Menu
alert(width); // 100
alert(height); // 200
#

Properties options.title, options.width and options.height are assigned to the corresponding variables. The order does not matter. This works too:

// changed the order in let {...}
let {height, width, title} = {title:'menu', height:200, width:100}

The pattern on the left side may be more complex and specify the mapping between properties and variables. If we want to assign a property to a variable with another name, for instance, make options.width go into the variable named w, then we can set the variable name using a colon:

#
let options = {
	title: 'menu',
	width: 100,
	height: 200
};

// { sourceProverty: targetVariable }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

alert(title); // Menu
alert(w);     // 100
alert(h);     // 200
#

The colon shows 'what : goes where'. In the example above the property width goes to w, property height goes to h, and title is assigned to the same name.

For potentially missing properties we can set default values using '=', like this:

let options = {
	title: 'menu'
};

let {width = 100, height = 200, title} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200

Just like with arrays or function parameters, default values can be any expressions or even function calls. They will be evaluated if the value is not provided. In the code below prompt asks for width, but not for title:

#
let options = {
	title: 'menu'
};

let {width = prompt('width?'), title = prompt('title?')} = options;

alert(title); // Menu
alert(width); // (whatever the result of prompt is)
#

We also can combine both the colon and equality:

#
let options = {
	title: 'menu'
};

let {width: w = 100, height: h = 200, title} = options;

alert(title); // Menu
alert(w);     // 100
alert(h);     // 200
#

If we have a complex object with many properties, we can extract only what we need:

#
let options = {
	title: 'Menu',
	width: 100,
	height: 200
};

// only extract title as a variable
let { title } = options;

alert(title); // Menu
#

<><> The rest pattern "..."

what if the object has more properties than we have variables? can we take some and then assign the 'rest' somewhere? We can use the rest pattern, just like we did with arrays. It's not supported by some older browser (IE, use Babel to polyfill it), but works in modern ones.

It looks like this:

#
let options = {
	title: 'menu',
	height: 200,
	width: 100
};

// title = property named title
// rest = object with the rest of properties
let {title, ...rest} = options;

// now title="menu", rest={height: 200, width: 100}
alert(rest.height); // 200
alert(rest.width);  // 100
#

(i) gotcha if there's no let - in the examples above variables were declared right in the assignment: let {...} = {...}. Of course, we could use existing variables too, without let. But there's a catch. This won't work:

let title, width, height;

// error in this line
{title, width, height} = {title: 'menu', width: 200, height: 100};

The problem is that JavaScript treats {...} in the main code flow (not inside another expression) as a code block. Such code blocks can be used to group statements like this:

{
	// a code block
	let message = 'hello';
	// ...
	alert( message );
}

So here JavaScript assumes that we have a code block, that's why there's an error. We want destructuring instead. To show JavaScript that it's not a code block, we can wrap the expressions in parentheses (...):

#
let title, width, height;

// okay now
({title, width, height} = {title: 'menu', width: 200, height: 100});

alert( title ); // Menu
#

<><> Nested destructuring - if an object or an array contain other nested objects and arrays, we can use more complex left-side patterns to extract deeper portions. In the code below options has another object in the property size and an array in the property items. The pattern at the left side of the assignment has the same structure to extract values from them:

#
let options = {
	size: {
		width: 100,
		height: 200
	},
	items: ['cake', 'donut'],
	extra: true
};

// destructuring assignment split in multiple lines for clarity
let {
	size: { // put size here
		width,
		height
	},
	items: [item1, item2], // assign items here
	title = 'menu' // not present in the object (default value is used)
} = options;

alert(title); // Menu
alert(width); // 100
alert(height); // 200
alert(item1); // Cake
alert(item2); // Donut
#

All properties of options object except extra that is absent in the left part, are assigned to corresponding variables. Finally, we have width, height, item1, item2 and title from the default value. Note that there are no Variables for size and items, as we take their content instead.

<><> SMART FUNCTION PARAMETERS

There are times when a function has many parameters, most of which are optional. That's especially true for user interfaces. Imagine a function that creates a menu. It may have a width, a height, a title, items list and so on. Here's a bad way to write such function:

function showMenu(title = 'untitled', width = 200, height = 100, items = []){
	// ...
}

In real-life, the problem is how to remember the order of arguments. Usually IDEs try to help us, especially if the code is well-documented, but still... Another problem is how to call a function when most parameters are ok by default. Like this?

#
// undefined where default values are fine
showMenu('My Menu', undefined, undefined, ['item1', 'item2'])
#

that's ugly. and becomes unreadable when we deal with more parameters. Destructuring comes to the rescue. We can pass parameters as an object, and the function immediately destructurizes them into variables:

#
// we pass object to function
let options = {
	title: 'my menu',
	items: ['item1', 'item2']
};

// ...and it immediately expands it to variables
function showMenu({title = 'untitled', width = 200, height = 100, items = []}) {
	// title, items - taken from options,
	// width, height - defaults used
	alert(`${title} ${width} ${height}`); // My Menu 200 100
	alert(items); // Item1, Item2
}

showMenu(options);
#

We can also use more complex destructuring with nested objects and colon mappings:

#
let options = {
	title: 'My menu',
	items: ['Item1', 'Item2']
};

function showMenu({
	title = 'untitled'
	width: w = 100, // width goes to w
	height: h = 200, // height goes to h
	items: [item1, item2] // items first element goes to item1, second to item2
}) {
	alert(`${title} ${w} ${h}`); // My Menu 100 200
	alert( item1 ); // Item1
	alert( item2 ); // Item2
}

showMenu(options);
#

The full syntax is the same as for a destructuring assignment:

#
function({
	incomingProperty: varName = defaultValue
	...
})
#

Then, for an object of parameters, there will be a variable varName for property incomingProperty, with defaultValue by default. Please note that such destructuring assumes that showMenu() does have an argument. if we want all values by default, then we should specify an empty object.

#
showMenu({}); // ok, all values are default
showMenu(); // this would give an error
#

We can fix this by making {} the default value for the whole object of parameters:

#
function showMenu({title = 'menu', width = 100, height = 200} = {}) {
	alert(`${title} ${width} ${height}`);
}

showMenu(); // Menu 100 200
#

In the code above, the whole arguments object is {} by default, so there's always something to destructurize.

SUMMARY

* Destructuring assignment allows for instantly mapping an object or array onto many variables.
* The full object syntax:
	let {prop : varName = default, ... rest} = object

	this means that property prop should go into the variable varName and, if no such property exists, then the default value should be used.

	Object properties that have no mapping are copied to the rest object.

* The full array syntax:

	let [item1 = default, item2, ...rest] = array

	The first item goes to item1; the second goes into item2, all the rest makes the array rest.

* It's possible to extract data from nested arrays/objects, for that the left side must have the same structure as the right one.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><> 

Date and Time

Let's meet a new built-in object: Date. It stores the date, time and provides methods for date/time management. For instance, we can use it to store creation/modification times, to measure time, or just to print out the current date.

<><> Creation

To create a new Date object call new Date() with one of the following argumetns:

new Date()

Without arguments - create a Date object for the current date and time:

let now = new Date();
alert( now ); // shows current date/time

new Date(milliseconds)

Create a Date object with the time equal to number of milliseconds (1/1000 of a second) passed after the Jan 1st of 1970 UTC+0.

// 0 means 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
alert( Jan01_1970 );

// now add 24 hours, get 02.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert( Jan02_1970 );

An integer number representing the number of miliseconds that has passed since the beginning of 1970 is called a timestamp. It's a lightweight numeric representation of a date. We can always create a date from a timestamp using new Date(timestamp) and convert the existing Date object to a timestamp using the date.getTime() method (see below).

Dates before 01.01.1970 have negative timestamps, e.g:

// 31 Dev 1969
let Dec31_1969 = new Date(-24 * 3600 * 1000);
alert( Dec31_1969);

new Date(datestring)

If there is a single argument, and it's a string, then it is parsed automatically. The algorithm is the same as Date.parse uses, we'll cover it later.

let date = new Date("2017-01-26");
alert(date);

// the time is not set, so it's assumed to be midnight GMT and
// is adjusted according to the timezone the code is run in
// so the result could be
// Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)
// or
// We Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)

new Date(year, month, date, hours, minutes, seconds, ms)

Create the date with the given components in the local time zonze. Only the first two arguments are obligatory.

* The year must have 4 digits.
* the month count starts with 0 to 11
* the date parameter is actually the day of month, if absent then 1 is assumed.
* if hours/minutes/seconds/ms is absent, they are assumed to be equal 0.

For instance

new Date(2011, 0, 1, 0, 0, 0, 0); // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // 1 Jan 2011, 00:00:00

The maximal precision is 1ms (1/1000 sec):

let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert(date); // 1.01.2011, 02:03:04.567

<><> Access date components - there are methods to access the year, month and so on from the Date object;

* getFullYear() - get the yaer 4 digits
* getMonth() - get the month, from 0 to 11
* getDate() - get the day of month, from 1 to 31, the name of the method does look a little bit strange
* getHours(), getMinutes(), getSeconds(), getMilliseconds() - get the corresponding time components

(w) not getYear(), but getFullYear()

Additionally we can get a day of the week:

* getDay() - get the day of the week, from 0 (sunday) to 6 (saturday). The first day is always Sunday, in some countries that's not so, but can't be changed.

<> All the methods above return the componentes relative ot the local time zone.

There are also their UTC-counterparts, that return day, month, yaer and so on for the time zone UTC+0: getUTCFullYear(), getUTCMonth(), getUTCDay(). Just insert the 'utc' right after 'get'.

If your local time zone is shifted relative to UTC, then the code below shows different hours:

// current date
let date = new Date();

// the hour in your current time zone
alert( date.getHours() );

// the hour in UTC+0 time zone (London time without daylight savings)
alert( date.getUTCHours() );

Besides the given methods, there are two special ones that do not have a UTC-variant:

getTime() - Returns the timestamp for the date - a number of miliseconds passed from January 1st of 1970 UTC+0.

getTimezoneOffset() - Returns the difference between UTC and the local time zone, in minutes:

// if you are in timezone UTC-1, outputs 60
// if you are in timezone UTC+3, outputs -180
alert( new Date().getTimezoneOffset() );

<><> Setting date componentes

The following methods allow to set date/time components:

* setFullYear(year, [month], [date])
* setMonth(month, [date])
* setDate(date)
* setHours(hour, [min], [sec], [ms])
* setMinutes(min, [sec], [ms])
* setSeconds(sec, [ms])
* setMilliseconds(ms)
* setTime(milliseconds) (sets the whole date by milliseconds since 01.01.1970 UTC)

Every one of them except setTime() has a UTC-variant for instance: setUTCHours().

As we can see, some methods can set multiple components at once, for example setHours. The componentes that are not mentioned are not modified. For instance:

let today = new Date();

today.setHours(0);
alert(today); // still today, but the hour is changed to 0

today.setHours(0,0,0,0);
alert(today); // still today, but now it is 00:00:00 sharp.

<><> Autocorrection

The autocorretion is a very handy feature of Date objects. We can se out-of-range values, and it will auto-adjust itself. For instance:

let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ... is 1st feb 2013!

Out-of-range date componentes are distributed automatically.
Let's say we need to increase the date "28 Feb 2016" by 2 days.It may be "2 Mar" or "1 Mar" in case of a leap-year. We don't need to think about it. Just add 2 days. The Date object will do the rest:

let date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);

alert( date ); // 1 Mar 2016

That feature is often used to get the adte after the given period of time. For instance, let's get the date for '70 seconds after now':

let date = new Date();
date.setSeconds(date.getSeconds() + 70);

alert(date); //shows the correct date

we can also set zero or even negative values. For example:

let date = new Date(2016, 0, 2); // 2 Jan 2016

date.setDate(1); // set day 1 of month
alert(date);

date.setDate(0); // min day is 1, so the last day of previous month is assumed
alert(date); // 23 Dec 2015

Date to Number, date Diff

when a date object is converted to number, it becomes the timestamp same as date.getTime():

let date = new Date();
alert(+date); // the number of milliseconds, same as date.getTime();

The important side effect : dates can be subtracted, the result is their difference in ms. That can be used for time measurements:

let start = new Date(); // start measuring time

// do the job
for (let i = 0 ; i < 100000; i++) {
	let doSomething = i*i*i;
}

let end = new Date(); // end measuring time

alert(`the loop took ${end - start} ms`);

<><> Date.now() - if we only want to measure time, we don't need the Date object. there's a special method Date.now() that returns the current timestamp. It is semantically equivalent to new Date().getTime(), but it doesn't create an intermediate Date object. SO it's faster and doesn't put pressure on garbage collection.

It is used mostly for convenience or when performance matters, like in games in JavaScript or other specialized applications. So this is probably better:

let start = Date.now(); // milliseconds count from 1 Jan1970

// do the job
for (let i = 0; i < 100000; i++) {
	let doSomething = i*i*i;
}

let end = Date.now(); // done

alert( `The loop took ${end - start} ms`); // subtract numbers, not dates

<><> Benchmarking - If we want a reliable benchmark of CPU-hungry function, we should be careful. For instance, let's measure two functions that calculate the difference between two dates: which one is faster? Such performance measurements are often called 'benchmarks'.

// we have date1 and date2, which function faster returns their difference in ms?

function diffSubtract(date1, date2) {
	return date2 - date1;
}

// or

function diffGetTime(date1, date2) {
	return date2.getTime() - date1.getTime();
}

these two do exactly the same thing, but one of them uses an explicit date.getTime() to get the date in ms and the other one relies on a date-to-number transform. Their result is always the same. So which one is faster?

The first idea may be run them many times in a row and measure the time difference. For our case, functions are very simpe, so we have to do it at least 100000 times.

let's measure:

function diffSubtract(date1, date2) {
	return date2 - date1;
}

function diffGetTime(date1, date2) {
	return date2.getTime() - date1.getTime()
}

function bench(f) {
	let date1 = new Date(0);
	let date2 = new Date();

	let start = Date.now();
	for (let i = 0; i < 100000; i++) f(date1, date2);
	return Date.now() - start;
}

alert( 'Time of diffSubtract: ' + bench(diffSubtract) + 'ms' );
alert( 'Time of diffGetTime: ' + bench(diffGetTime) + 'ms');

Wow! Using getTime() is so much faster! That's because there's no type conversion, it is much easier for engines to optimize. Okay, we have something, but that's not a good benchmark yet. Imagine that at the time of running bench(diffSubtract) CPU was doing something in parallel, and it was taking resources. And by the time of running bench(diffGetTime) that work was finished.

A pretty real scenario for a modern multi-process OS. As a result, the first benchmark will have less CPU resources than the second. That may lead to wrong results. For more reliable benchmarking, the whole paco of benchmarks should be rerun multiple times.

For example, like this:

function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

let time1 = 0;
let time2 = 0;

// run bench(diffSubtract) and bench(diffGetTime) each 10 times alternating
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}

alert( 'Total time for diffSubtract: ' + time1 );
alert( 'Total time for diffGetTime: ' + time2 );

Modern JavaScript engines start applying advanced optimizations only to 'hot code' that executes many times (no need to optimize rarely executed things). So, in the example above, first executions are not well-optimized. We may want to add a 'heat-up' run:

// adder for 'heating up' prior to the main loop
bench(diffSubtract);
bench(diffGetTime);

// now benchmark
for (let i = 0; i < 10; i ++) {
	time1 += bench(diffSubtract);
	time2 += bench(diffGetTime); 
}

(w) be careful doing microbenchmarking - modern JavaScript engines perform many optimizations. They may tweak results of 'artificial tests' compared to 'normal usage', especially when we benchmark something very small, such as how an operator works, or a built-in function. So if you seriously want to understand performance, then pelase study how the JavaScript engine works. And then you probably won't need microbenchmarks at all.

the great pack of articles about V8 can be found at http://mrale.ph.

Date.parse from a string

The method Date.parse(str) can read a date from a string. The string format should be: YYYY-MM-DDTHH:mm:ss:sssZ, where:

* YYYY-MM-DD - is the date: year-month-day.
* The character "T" is used as the delimiter.
* HH:mm:ss.sss - is the time: hours, minutes, seconds and milliseconds
* The optional 'Z' part denotes the time zone in the format +-hh:mm. A single letter Z would mean UTC+0

Shorter variants are also possible, like YYYY-MM-DD or YYYY-MM or even YYYY.

The call to Date.parse(str) parses the string in the given format and returns the timestamp (number of milliseconds from 1 Jan 1970 UTC+0). If the format is invalid, returns NaN.

For instance:

let ms = Date.parse('2012-01-26T13:51:50.417-07:00');
alert(ms); // 1327611110417 (timestamp)

we can instantly create a new Date object from the timestamp:

let date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00'));
alert(date);

SUMMARY

* Date and time in JavaScript are represented with the Date object. We can't create 'only date' or 'only time': Date objects always carry both.
* Months are counted from zero (yes, January is a zero month).
* Days of week in getDay() are also counted from zero (that's Sunday).
* Date auto-corrects itself when out-of-range components are set. Good for adding / subtracting / days / months / hours.
* Dates can be subtracted, giving their difference in milliseconds. That's because a Date becomes the timestamp when converted to a number.
* Use Date.now() to get the current timestamp fast.

Note that unlike many other systems, timestamps in JavaScript are in miliseconds, not in seconds. Sometimes we need more precise time measurements. JavaScript itself does not have a way to measure time in microseconds (1 millionth of a second), but most environments provide it. For instance, browser has performance.now() that gives the number of miliseconds from the start of a page loading with microsecond precision (3digits after the point):

alert(`Loadint Started ${performance.now()} ms ago`);
// something like: 'loading started 34731.26000000001ms ago'
// .26 is microseconds (260 microseconds)
// more than 3 digits after the decimal point are precision errors, only the first 3 count

Node.js has microtime module and other ways. Technically, almost any device and environment allows to get more precision, it's just not in Date.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

JSON methods, toJSON
Let’s say we have a complex object, and we’d like to convert it into a string, to send it over a network, or just to output it for logging purposes.

Naturally, such a string should include all important properties.

We could implement the conversion like this:

let user = {
	name: 'John',
	age: 30,

	toString() {
		return `{name: "${this.name}", age: ${this.age}}`;
	}
};

alert(user); // {name: 'John', age: 30}

...But in the process of development, new properties are added, old properties are renamed and removed. Updating such toString every time can become a pain. We could try to loop over properties in it, but what if the object is complex and has nested objects in properties? We'd need to implement their conversion as well.

Luckily, there's no need to write the code to handle all this. The task has been solved already.

<><> JSON.stringify

The JSON (JavaScript Object Notation) is a general format to represent values and objects. It is described as in RFC 4627 standard. Initially it was made for JavaScript, but many other languages have libraries to handle it as well. So it's easy to use JSON for data exchange when the client uses JavaScript and the server is written on RUBY/PHP/JAVA/WHATEVER.

JavaScript provides methods:

* JSON.stringify to convert objects into JSON.
* JSON.parse to convert JSON back into an object.

For instance, here we JSON.stringify a student:

let student = {
	name: "John",
	age: 30,
	isAdmin: false,
	courses: ['html', 'css', 'js'],
	wife: null
};

let json = JSON.stringify(student);

alert(typeof json); // we've got a string!

alert(json);

/* JSON-encoded object:
{
  "name": "John",
  "age": 30,
  "isAdmin": false,
  "courses": ["html", "css", "js"],
  "wife": null
}
*/

The method JSON.stringify(student) takes the object and converts it into a string.

The resulting json string is called a JSON-encoded or serialized or stringified or marshalled object. We are ready to send it over the wire or put into a plain data store.

Please note that a JSON-encoded object has several important differences from the object literal:

* Strings use double quotes. No single quotes or backticks in JSON. So 'John' becomes "John".
* Object property names are double-quoted also. That's obligatory. So age:30 becomes "age":30

JSON.stringify can be applied to primitives as well. Json Supports following data types:

* Objects {...}
* Arrays [...]
* Primitives:
	* strings,
	* numbers,
	* boolean values true/false,
	* null

For instance:

// a number in JSON is just a number
alert( JSON.stringify(1) ) // 1

// a string in JSON is still a string, but double-quoted
alert( JSON.stringify('test') ) // "test"

alert( JSON.stringify(true) ); // true

alert( JSON.stringify([1, 2, 3]) ); // [1,2,3]

JSON is data-only language-independent specification, so some JavaScript-specific object properties are skipped by JSON.stringify.

Namely:

* function properties (methods)
* symbolic keys and values.
* properties that store undefined.

let user = {
	sayHi() { // ignored
		alert('Hello');
	},
	[Symbol('id')]: 123, // ignored
	something: undefined // ignored
};

alert( JSON.stringify(user) ); // {} (empty object)

Usually that's fine. If that's not what we want, then soon we'll see how to customize 
the process. The great thing is that nested objects are supported and converted automatically.

For instance:

let meetup = {
	title: 'Conference',
	room: {
		number: 23,
		participants: ['john', 'ann']
	}
};

alert( JSON.stringify(meetup) );

/* The whole structure is stringified:
{
  "title":"Conference",
  "room":{"number":23,"participants":["john","ann"]},
}
*/

The important limitation: there must be no circular references. For instance:

let room = {
	number: 23
};

let meetup = {
	title: 'conference',
	participants: ['john', 'ann']
};

meetup.place = room; // meetup references room
room.occupiedBy = meetup; // room references meetup

JSON.stringify(meetup); // Error: converting circular structure to JSON

Here, the conversion fails, because of circular reference: room.occupiedBy references meetup and meetup.place references room.

<><> Excluding and Transforming: replacer

the full syntax of JSON.stringify is:

let json = JSON.stringify(value[, replacer, space]);

value - a value to encode
replacer - array of properties to encode or a mapping function function(key, value).
space - amount of space to use for formatting

Most of the time, JSON.stringify is used with the first argument only. But if we need to fine-tune the replacement process, like to filter out circular references, we can use the second argument of JSON.stringify.

If we pass an array of properties to it, only these properties will be encoded.

for instance:

let room = {
	number: 223
};

let meetup = {
	title: 'Conference',
	participants: [{name: 'John'}, {name: 'Alice'}],
	place: room // meetup references room
};

room.occupiedBy = meetup; // room references meetup

alert( JSON.stringify(meetup, ['title', 'participants']) );
// {"title":"Conference","participants":[{},{}]}

Here we are probably too strict. The property list is applied to the whole object structure. So the objects in participants are empty, because name is not in the list.

Let's include in the list every property except room.occupiedBy that would cause the circular reference:

let room = {
	number: 23
};

let meetup = {
	title: 'Conference',
	participants: [{name:'John'},{name:'Alice'}],
	place: room // meetup references room
};

room.occupiedBy = meetup; // room references meetup

alert( JSON.stringify(meetup, ['title', 'participants', 'place', 'name', 'number']) );

/*
{
  "title":"Conference",
  "participants":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/

Now everything except occupiedBy is serialized. But the list of properties is quite long. Fortunately, we can use a function instead of an array as the replacer. The function will be called for every (key, value) pair and should return the 'replaced' value, which will be used instead of the original one. Or undefined if the value is to be skipped.

In our case, we can return 'value' 'as is' for everything except occupiedBy. To ignore occupiedBy, the code below returns undefined:

let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup references room
};

room.occupiedBy = meetup; // room references meetup

alert( JSON.stringify(meetup, function replacer(key, value) {
  alert(`${key}: ${value}`);
  return (key == 'occupiedBy') ? undefined : value;
}));

/* key:value pairs that come to replacer:
:             [object Object]
title:        Conference
participants: [object Object],[object Object]
0:            [object Object]
name:         John
1:            [object Object]
name:         Alice
place:        [object Object]
number:       23
occupiedBy: [object Object]
*/

Please note that replacer function gets every key/value pair including nested objects and array items. It is applied recursively. The value of 'this' inside 'replacer' is the object that contains the current property.

the first call is special. It is made using a special 'wrapper object': {"":meetup}. IN other words, the first (key, value) pair has an empty key, and the value is the target object as a whole. That's why the first line is ":[object Object]" in the example above.

The idea is to provide as much power for replacer as possible: it has a chanve to analyze and replace/skip even the whole object if necessary.

<><> FORMATTING: SPACE

The third argument of JSON.stringify(value, replacer, space) is the number of spaces to use for pretty formatting. Previously, all stringified objects had no indents and extra spaces. That's fine if we want to send an object over a network. The space argument is used exclusively for a nice output.

Here space = 2 tells JavaSCript to show nested objects on multiple lines, with indentation of 2 spaces inside an object:

let user = {
  name: "John",
  age: 25,
  roles: {
    isAdmin: false,
    isEditor: true
  }
};

alert(JSON.stringify(user, null, 2));
/* two-space indents:
{
  "name": "John",
  "age": 25,
  "roles": {
    "isAdmin": false,
    "isEditor": true
  }
}
*/

/* for JSON.stringify(user, null, 4) the result would be more indented:
{
    "name": "John",
    "age": 25,
    "roles": {
        "isAdmin": false,
        "isEditor": true
    }
}
*/

The third argument can also be a string. In this case, the string is used for indentation instead of a number of spaces. The space parameter is used solely for logging and nice-output purposes.

<><> Custom "toJSON" - like toString for string conversion, an object may provide method toJSON for to-JSON conversion. JSON.stringify automatically calls it if available.

For instance:

let room = {
	number: 23
};

let meetup = {
	title: "Conference",
	date: new Date(Date.UTC(2017, 0 , 1)),
	room
};

alert( JSON.stringify(meetup) );
/*
	{
		"title":"Conference",
		"date":"2017-01-01T00:00:00.000Z", //(1)
		"room": {"number":23}			   //(2)	
	}
*/


here we can see that date (1) became a string. That's ebcause all dates have a built-in toJSON method which returns such kind of string. Now let's add a custom toJSON for our object room (2):

let room = {
	number: 23,
	toJSON() {
		return this.number;
	}
};

let meetup = {
	title: 'Conference',
	room
};

alert( JSON.stringify(room) ); // 23

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",
    "room": 23
  }
*/

as we can see, toJSON is used both for the direct call JSON.stringify(room) and when room is nested in another encoded object.

JSON.parse = to decode a JSON-string, we need another method named JSON.parse.
The syntax: let value = JSON.parse(str, [reviver]);

str JSON-string to parse.
reviver optional function (key, value) that will be called for each (key, value) pair and can transform the value.

for instance:

// stringified array
let numbers = "[0,1,2,3]";

numbers = JSON.parse(numbers);
alert(numbers[1]); // 1

or for nested objects:

let userData = '{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';

let user = JSON.parse(userData);

alert( user.friends[1] ); // 1

The JSON may be as complex as necessary, objects and arrays can include other objects and arrays. But they must obey the same JSON format. Here are typical mistakes in hand-written JSON (sometimes we have to write it for debugging purposes):

let json = `{
  name: "John",                     // mistake: property name without quotes
  "surname": 'Smith',               // mistake: single quotes in value (must be double)
  'isAdmin': false                  // mistake: single quotes in key (must be double)
  "birthday": new Date(2000, 2, 3), // mistake: no "new" is allowed, only bare values
  "friends": [0,1,2,3]              // here all fine
}`;

Besides, JSON does not support comments. Adding a comment to JSON makes it invalid.
There's another format named for JSON5, which allows unquoted keys, comments etc. But this standalone library, not in the specification of the language. The regular JSON is that strict not because its developers are lazy, but to allow easy, reliable and very fast implementations of the parsing algoh.

Using Reviver

Imagine, we got a stringified meetup object from the server. It looks like this:

// title: (meetup title), date: (meetup date)
let str = '{"title":"Conferemce", "date":"2017-11-30T12:0000.000Z"}';

... and now we need to deserialize it, to turn back into JavaScript object.
Let's do it by calling JSON.parse:

let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str);

alert( meetup.date.getDate() ); // Error!

Whooops! An error! The value of meetup.date is a string, not a Sate object. How could JSON.parse know that it should transform that string into a Date?

Let's pass to JSON.parse the reviving function as the second argument, that returns all values 'as is', but date will become a Date:

let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str, function(key, value) {
	if (key == 'date') return new Date(value);
});

alert( meetup.date.getDate()); now works!

By the way, that works for nested objects as well:

let schedule = `{
  "meetups": [
    {"title":"Conference","date":"2017-11-30T12:00:00.000Z"},
    {"title":"Birthday","date":"2017-04-18T12:00:00.000Z"}
  ]
}`;

schedule = JSON.parse(schedule, function(key, value) {
	if(key == 'date') return new Date(value);
	return value;
});

alert(schedule.meetups[1].date.getDate()); // 18 - it works!

<><> SUMMARY!

* JSON is a data format that has its own independent standard and libraries for most programming languages.
* JSON supports plain objects, arrays, strings, numbers, booleans and null.
* JavaSCript provides methods JSON.stringify to serialize into JSON and JSON.parse to read from JSON.
* Both methods support transformer functions for smart reading/writing.
* IF an object has toJSON, then it is called by JSON.stringify.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

RECURSION AND STACK

Let's return to functions and study them more in-depth. Our first topic will be recursion. If you are not new to programming, then it is probably familiar and you could skip this chapter. Recursion is a programming pattern that is useful in situations when a task can be naturally split into several tasks of the same kind, but simpler. Or when a task can be simplified into an easy action plus a simpler variant of the same task. Or, as we'll see soon, to deal with certain data structures. When a function solves a task, in the process it can call many other functnios. A partial case of this is when a function calls ITSELF. that's called recursion.

<><> TWO WAYS OF THINKING

For something simple to start with, let's write a function pow(x, n) that raises x to a natural power of N. In other words, multiplies x by itself, n times.

pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16

there are two ways to implement it. 

1. Iterative thinking: the for loop:

function pow(x, n) {
	let result = 1;

	// multiply result by x n times in the loop
	for (let i = 0; i < n; i++) {
		result *= x;
	}

	return result;
}

alert( pow(2, 3) ); // 8

2. recursive thinking: simplify the task and call self:

function pow(x, n) {
	if (n == 1) {
		return x;
	} else {
		return x * pow*(x, n-1);
	}
}

alert( pow(2, 3) ); //8

Please note how the recursive variant is fundamentally different. When pow(x, n) is called, 
the execution splits into two branches:

				if n==1 = x
			/
pow(x, n) = 
			\
				else = x * pow(x, n - 1)

1. if n == 1, then everything is trivial. It is called the base of recursion, because it immediately produces the obvious result: pow(x, 1) equals x.

2. otherwise, we can represent pow(x, n) as x * pow(x, n-1). In maths, one would write xn = x * xn-1. This is called a recursive step: we transform the task into a simpler action (multiplication by x) and a simpler call of the same task (pwoe with lower n). Next steps simplify it further and further until n reaches 1.

we can also say that pow recursively calls itself till n == 1.

for example, to calculate pow(2, 4) the recursive variant does these steps:

1. pow(2, 4) = 2 * pow(2, 3)
2. pow(2, 3) = 2 * pow(2, 2)
3. pow(2, 2) = 2 * pow(2, 1)
4. pow(2, 1) = 2

so, the recurssion reduces a function call to a simpler one, and then - to even more simpler and so on, until the result becomes obvious.

(i) Recursion is usually shorter

A recursive solution usually shorter than an iterative one.
Here we can rewrite the same using the condition operator ? instead of if to make pow(x, n) more terse and still very readable.

function pow(x, n) {
	return (n == 1) ? x : (x * pow(x, n-1));
}

the maximal number of nested calls (including the first one) is called a 'recursion depth'. In our case it will be exactly n. The maximal recursion depth is limited by JavaScript engine. We can rely on it being 10000, some engines allow more, but 100000 is probably our of limit for the majority of them. There are automatic optimizations that help alleviate this ("tail calls optimizations"), but they are not yet supported everywhere and work only in simple cases.

that limits the application of recursion, but it still remains very wide. There are many tasks where recursive way of thinking gives simpler code, easier to maintain.

<><> THE EXECUTION CONTEXT AND STACK

Now let's examine how recursive calls work. For that we'll look under the hood of cuntions. The information about the process of execution of a running function is stored in its execution context.

The execution context is an internal data structure that contains details abuot the execution of a function: where the control flow is now, the current variables, the value of 'this' (we don't use it here) and fe other internal details.

One function call has exactly one execution context associated with it.

When a function makes a neted call, the following happens:

* The current function is paused.
* The execution context associated with it is remembered in a special data structure called 'execution context stack'.
* the nested call executes
* after it ends, the old execution context is retrieved from the stack, and the outer function is resumed from where it stopped.

let's see what happens during pow(2, 3) call.

In the beginning of the call pow(2, 3) the execution context will store variables: x = 2 and n = 3, the execution flow is at line 1 of the function. We can sketch it as:

* context: {x:2, n:3, at line 1} call: pow(2, 3)

that's when the function starts to execute. The condition n == 1 is falsy, so the flow continues into the second branch of if:

function pow(x, n) {
	if (n == 1) {
		return x;
	} else {
		return x * pow(x, n-1);
	}
}

alert( pow(2, 3) );

the variables are the same, but the line changes, so the context is now:

* context: {x:2, n:3, at line 5} call: pow(2, 3)

To calculate x* pow(x, n-1), we need to make a subcall of pow, with new arguments:

* pow(2, 2);

To do a nested call, JavaScript remembers the current execution context in the execution context stack. Here we call the same function pow, but it absolutely doesn't matter. The process is the same for all functions:

1. the current context is 'remembered' on top of the stack.
2. the new context is created for the subcall.
3. when the subcall is finished - the previous context is popped from the stack, and its execution continues.

Here's the context stack when we entered the subcall pow(2, 2):

* context: {x:2, n:2, at line 1} call: pow(2, 2)
* context: {x:2, n:3, at line 5} call: pow(2, 3)

The new current execution context is on top (and bold), and previous remembered contexts are below. When we finish the subcall - it is easy to resume the previous context, because it keeps both variables and the exact place of the code where it stopped;

(i) please note: here in the picture we use the word 'line', as in our example there's only one subcall in line, but generally a single line of code may contain multiple subcalls, like pow(...) + pow(...) + somethingElse(...). - So it would be more precise to say that the execution resumes 'immediately after the subcall'.

<><> pow(2, 1)

The process repeats: a new subcall is made at line 5, now with arguments x = 2 and n = 1.

A new execution context is created, the previous one is pushed on top of the stack:

* context: { x:2, n:1, at line 1} call: pow(2, 1)
* context: { x:2, n:2, at line 5} call: pow(2, 2)
* context: { x:2, n:3, at line 5} call: pow(2, 3)

there are 2 old contextx now and 1 currently running for pow(2, 1);

<><> The exit

During the execution of pow(2, 1), unlike before, the condition n == 1 is truthy, so the first branch of if works:

function pow(x, n) {
	if (n == 1) {
		return x;
	} else {
		return x * pow(x, n-1);
	}
}

there are no more nested calls, so the function finishes, returning 2.

as the function finishes, its execution context is not needed anymore, so it's removed from the memory. The previous one is restored off the top of the stack:

* Context: { x:2, n:2, at line 5 } call: pow(2, 2)
* Context: { x:2, n:3, at line 5 } call: pow(2, 3)

The execution of pow(2, 2) is resumed. It has the result of the subcall pow(2, 1), so it also can finish the evaluation of x * pow(x, n-1), returning 4.

Then the previous context is restored:

* Context: {x:2, n:3, at line 5} call:pow(2, 3)

When it finishes, we have a result of pow(2, 3) = 8. The recursion depth in this case was: 3; As we can see from the illustrations above, recursion depth equals the maximal number of context in the stack. Note the memory requirements. Contexts take memory. In our case, raising to the power of n actually requires the memory for n contexts, for all lower values of n:

a loop-based algorithm is more memory-saving.

#
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
#

the iterative pow uses a single context changing i and result in the process. Its memory requirements are small, fixed and do not depend on n.

ANY RECURSION CAN BE REWRITTEN AS A LOOP. THE LOOP VARIANT USUALLY CAN BE MADE MORE EFFECTIVE.

... But sometimes the rewrite is non-trivial, especially when function uses different recursive subcalls depending on conditions and merges their results or when the branching is more intricate. And the optimization may be unneeded and totally not worth the efforts.

Recursion can give a shorter code, easier to understand and support. Optimizations are not required in every place, mostly we need a good code, that's why it is used.

<><> RECURSIVE TRAVERSALS

Another great application of the recurssion is a recursive traversal. Imagine, we have a company; The staff structure can be presented as an object:

#
let company = {
	sales: [{
		name:'John',
		salary: 1000
	}, {
		name:'Alice',
		salary: 1600
	}],

	development: {
		sites: [{
			name:'Peter',
			salary: 2000
		}, {
			name: 'Alex',
			salary: 1800
		}],

		internals: [{
			name: 'Jack',
			salary: 1300
		}]
	}
};
#

In other words, a company has departments.

* a department may have an array of staff. For instance, sales department has 2 employees: John and Alice

* Or a department may aplit into subdepartments, like development has two branches: sites and internals. Each of them has their own staff.

* it is also possible that when a subdepartment grows, it divides into subsubdepartments (or teams)

For instance, the sites department in the future may be split into teams for siteA and siteB. And they, potentially, can split even more. That's not on the picture, just something to have in mind.

Now let's say we want a function to get the sum of all salaries. How can we do that?

An iterative approach is not easy, because the structure is not simple. The first idea may be to make a for loop over company with nested subloop over 1st level departments. But then we need more nested subloops to iterate over the staff in 2nd level departments like sites ... And then another subloop inside those 3rd level departments that might appear in the future? If we put 3-4 nested subloops in the code to traverse a single object, it becomes rather ugly.

LEt's try recursion.

As we can see, when our function gets a department to sum, there are two possible cases:

1. Either it's a 'simple' department with an array of people - then we can sum the salaries in a simple loop.
2. Or it's an object with N subdepartments - then we can make N recursive calls to get the sum for each of the subdeps and combine the results.

The 1st case is the base of recursion, the trivial case, when we get an array.
The 2nd case when we get an object is the recursive step. A complex task is split into subtracks for smaller departments. They may in turn split again, but sooner or later the split will finish at (1).

The algorithm is probably even easier to read from the code:

#
let company = { // the same object, compressed for brevity
  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 1600 }],
  development: {
    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
    internals: [{name: 'Jack', salary: 1300}]
  }
};

// the function to do the job
function sumSalaries(department) {
	if (Array.isArray(department)) { // case (1)
		return department.reduce((prev, current) => prev + current.salary, 0); // sum the array
	} else { // case (2)
		let sum = 0;
		for (let subdep of Object.values(department)) {
			sum += sumSalaries(subdep); // recursively call for subdepartments, sum the results
		}
		return sum;
	}			
}

alert(sumSalaries(company)); // 7700
#

The code is short and easy to understand (hopefully?). That's the power of recursion. It also works for any level of subdepartment nesting. WE can easily see the principle: for an object {...} subcalls are made, while arrays [...] are the 'leaves' if the recursion tree, they give immediate result.

Note that the code uses smart features that we've covered before:

* Method arr.reduce explained in the chapter Array methods to get the sum of the array.
* Loop for(val of Object.values(obj)) to iterate over object values: Object.values returns an array of them.

<><> RECURSIVE STRUCTURES

A recursive (recursively-defined) data structure is a structure that replicates itself in parts. We've just seen it in the example of a company structure above.

A company department is:

* either an array of people
* or an object with departments

For web-developers there are much better-known examples: HTML and XML documents. IN the HTML documents, an HTML-tag may contain a list of:

* text pieces
* html-comments
* other html-tags (that in turn may contain text pieces/ comments or other tags etc)

THAT's once again a recursive definition. For better understanding, we'll cover one more recursive structure named 'linked list' that might be a better alternative for arays in some cases.

<><> LINKED LIST

imagine, we want to store an ordered list of objects. The natural choice would be an array:

let arr = [obj1, obj2, obj3];

... But there's a problem with arrays. The 'delete element' and 'insert element' operations are expensive. For instance, arr.unshift(obj) operation has to renumber all elements to make room for a new obj, and if the array is big, it takes time. Same with arr.shift().

The only structural modifications that do not require mass-renumbering are those that operate with the end of array: arr.push/pop. So an array can be quite slow for big queues, when we have to work with the beginning.

Alternatively, if we really need fast insertion/deletion, we can choose another data structure called a 'linked list'. The linked list element is recursively defined as an object with:

* value
* next - property referencing the next linked list element or null if that's the end.

for instance:

#
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
#

or

#
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };
list.next.next.next.next = null;
#

Here we can even more clearly see that there are multiple objects, each one has the value and next pointing to the neighbour. The list variable is the first object in the chain, so folowing next pointers from it we can reach any element.

The list can be easily split into multiple parts and later joined back:

let secondList = list.next.next;
list.next.next = null;

To join:

list.next.next = secondList;

And surely we can insert or remove items in any place.

For instance, to prepend a new value, we need to update the head of the list.

#
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };

// prepend the new value to the list
list = { value: "new item", next: list };
#

To remove a value from the middle, change next of the previous one.

list.next = list.next.next;

we made list.next jump over 1 to value 2. The value 1 is now excluded from the chain. If it's not stored anywhere else, it will be automatically removed from the memory.

Unlike arrays, there's no mass-renumbering, we can easily rearrange elements. Naturally, list are not always better than arrays. Otherwise, everyone would use only lists.

The main drawback is that we can't easily access an element by its number. In an array that's easy: arr[n] is a direct reference. But in the list we need to start from the first item and go next N times to get the Nth element.

...but we don't always need such operations. For instance, when we need a queue or even a deque - the ordered structure that must allow very fast adding/removing elements from both ends, but access to its middle is not needed.

Lists can be enhanced:

* we can add property prev in addition to next to reference the previous element, to move back easily
* we can also add a variable named tail referencing the last element of the list (and update it when addming/removing elements from the end).
* ... the data structure may vary according to our needs.

SUMMARY

TERMS:

* recursion is a programming term that means calling a function from itself. Recursive functions can be used to solve task in elegant ways. When a function calls itself, that's called a recursion step. The basis of recursion is function arguments that make the task so simple that the function does not make further calls

* a recursively-defined data structure is a data structure that can be defined using itself.
For instance, the linked list can be defined as a data structure consisting of an object referencing a list (or null).

list = { value, next -> list }

Trees like HTML elements tree or the department tree from this chapter are also naturally recursive. They branch and every branch can have other branches. Recursive functions can be used to walk them as we've seen in the sumSalary example.

Any recursive function can be rewritten into an iterative one. And that's sometimes required t optimize stuff. But for many tasks a recursive solution is fast enough and easier to write AND support.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

REST PARAMETERS AND SPREAD SYNTAX

Many JavaScript built-in functions support an arbitrary number of arguments.

For instance:

* Math.max(arg1, arg2, ..., argN) - returns the greatest of the arguments.
* Object.assign(dest, src1, ..., srcN) - copies properties from src1..N into dest.
* ... and so on.

In this chapter we'll learn how to do the same. And also, how to pass arrays to such functions as parameters.

<><> REST PARAMETERS ...

A function can be called with any number of arguments, no matter how it is defined.

like here:

#
function sum(a, b) {
	return a + b
}

alert( sum(1, 2, 3, 4, 5) );
#

there will be noerror because of 'excessive' arguments. But of course in the result only the first two will be counted. THe rest of the parameters can be included in the function definition by using three dots ... followed by the name of the array that will contain them. The dots literally mean 'gather the remaining parameters into an array'.

For instance, to gather all arguments into array args:

function sumAll(...args) { // args is the name of the array
	let sum = 0;
	for (let arg of args) sum += arg;

	return sum;	
}

alert( sumAll(1) ); // 1
alert( sumAll(1, 2) ); // 3
alert( sumAll(1, 2, 3) ); // 6

We can choose to get the first parameters as variables, and gather only the rest. Here the first two arguments go into variables and the rest go into titles array:

function showName(firstName, lastName, ...titles) {
	alert( firstName + ' ' + lastName ); // Julius Caesar

	// the rest go into titles array
	// i.e. titles = ['Consul', 'Imperator']

	alert( titles[0] ); // Consul
	alert( titles[1] ); // Imperator
	alert( titles.length ); // 2
}

showName("Julius", "Caesar", "Consul", "Imperator");

(w) The rest parameters must be at the end - The rest parameters gather all remaining arguments, so the following does not make sense and causes an error:

function f(arg1, ...rest, arg2) { // arg2 after ...rest?
	// error
}

The ...rest must always be last.

<><> The 'arguments' variable

There is also a special array-like object named arguments that contains all arguments by their index.

for instace:

function showName() {
	alert( arguments.length );
	alert( arguments[0] );
	alert( arguments[1] );

	// it is iterable
	// for (let arg of arguments) alert(arg);
}

// shows: 2, Julius, Caesar
showName('Julius', 'Caesar')

// shows: 1, Ilya, undefined (no second argument)
showName("Ilya");

In old times, rest parameters did not exist in the language, and using arguments was the only way to get all arguments of the function. And it still works, we can find it in the old code.

But the downside is that although arguments is both array-like and iterable, it's not an array. It does not support array methods, so we can't call arguments.map(...) for example.

Also, it always contains all arguments. We can't capture them partially, like we did with rest parameeters.
So when we need these features, rest parameteres are preferred.

(i) Arrow functions do not have 'arguments' - If we access the arguments object from an arrow function, it takes them from the outer' normal' function.

Here's an example:

function f() {
	let showArg = () => alert(arguments[0]);
	showArg();
}

f(1); // 1

As we remember, arrow functions don't have their own this. Now we know they don't have the special arguments object either.

<><> Spread Syntax 

we've just seen how to get an array from the list of parameters. But sometimes we need to do exactly the reverse. For instance, there's a built in function Math.max that returns the greatest number from a list:

alert( Math.max(3, 5, 1) ); // 5

Now let's say we have an array [3, 5, 1]. How do we call Math.max with it?
Passing it 'as is ' won't work, because Math.max expects a list of numeric arguments, not a single array.

let arr = [3, 5, 1];
alert( Math.max(arr) ); // NaN

And surely we can't manually list items in the code Math.max(arr[0], arr[1], arr[2]), because we may be unsure how many there are. As our script executes, there could be a lot, or there could be none. And that would get ugly.

Spread syntax to the rescue! It looks similar to rest parameters, also using ..., but does quite the opposite. when ...arr is used in the function call, it 'expands' an iterable object arr into the list of arguments. For Math.max:

let arr = [3, 5, 1];
alert( Math.max( ...arr) ); // 5 (spread turns array into a list of arguments)

We also can pass multiple iterables this way:

#
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(...arr1, ...arr2) ); // 8
#

we can also combine the spread syntax with normal values:

#
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
#

Also, the spread syntax can be used to merge arrays:

#
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];

let merged = [0, ...arr, 2, arr2];
alert(merged);
#

In the examples above, we used an array to demonstrate the spread syntax, but any iterable will do.
For instance, here we use the spread syntax to turn the string into array of characters:

let str = "Hello";

alert( [...str] ); // H,e,l,l,o

The spread syntax internally uses iterators to gather elements, the same way as for..of does.

So, for a string, for..of returns characters and ...str becomes "H","e","l","l","o". The list
of character is passed to array initializer [...str].

For this particular task we could also use Array.from, because it converts an iterable (like a string)
into an array:

let str = "Hello";

// Array.from converts an iterable into an array
alert( Array.from(str) ); // H,e,l,l,o

The result is the same as [...str].
But there's a subtle difference between Array.from(obj) and [...obj]:

* array.from operates on both array-likes and iterables.
* the spread syntax works only with iterables.

So, for the task of turning something into an array, Array.from tends to be more universal.

<><> COPY AN ARRAY/OBJECT

Remember when we talked about Object.assign() in the past?
It is possible to do the same thing with the spread syntax.

#
let arr = [1, 2, 3];

let arrCopy = [...arr]; // spread the array into a list of parameters
						// then put the result into a new array

// do the arrays have the same contents?
alert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true

// are the arrays equal?
alert(arr === arrCopy); // false (not same reference)

// modifying our initial array does not modify the copy:
arr.push(4);
alert(arr); // 1, 2, 4
alert(arrCopy); // 1, 2, 3
#

Note that it is possible to do the same thing to make a copy of an object:

#
let obj = { a:1, b:2, c:3 };
let objCopy = { ...obj }; // spread the object into a list of parameters
						  // then return the result in a new object

// do the objects have the same contents?
alert(JSON.stringify(obj) === JSON.stringify(objCopy)); // true

// are the objects equal?
alert(obj === objCopy); // false (not same reference)

// modifying our initial object does not modify the copy:
obj.d = 4;
alert(JSON.stringify(obj)); // {"a":1,"b":2,"c":3,"d":4}
alert(JSON.stringify(objCopy)); // {"a":1,"b":2,"c":3}
#

this way of copying an object is much shorter than let objCopy = object.assign({}, obj) or for an
array let arrCopy = Object.assign([], arr) so we prefer to use it whenever we can.

<><> SUMMARY

When we see "..." in the code, it is either rest parameters or the spread syntax.

There's an easy way to distinguish between them:

* when ... is at the end of function parameteres, it is 'rest parameteres' and gathers the rest of the list of arguments.

* when ... occurs in a function call or alike, it's called 'spread syntax' and expands an array into a list.

Use Patters:

* rest parameters are used to create functions that accept any number of arguments.
* the spread syntax is used to pass an array to functions that normally require a list of many arguments.

Together they help to travel between a list and an array of parameters with ease.
All arguments of a function call are also available in 'old-style' arguments: array-like iterable object.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

<><> VARIABLE SCOPE, CLOSURE

JavaScript is a very function-oriented language. It gives us a lot of freedom. A function can be created at any moment, passed as an argument to another function, and then called from a totally different place of code later.

We already know that a function can access variables outside of it ('outer' variables).

But what happens if outer variables change since a function is created? Will the function get newer values or the old ones?

And what if a function is passed along as a parameter and called from another palce of code, will it get access to outer variables at the new place?

Let's expand our knowledge to understand these scenarios and more complex ones.

(i) we'll tak abuot let/const variables here - in JavaScript there are 3 ways to declare a variable: let, const and var.

* in this article we'll use let variables in examples.
* variables declated with const, behave the same, so this article is about const too.
* the old var has some notable differences, they will be covered in the article 'the old var'

<><> CODE BLOCKS

If a variable is declared inside a code block {...}, it's only visible inside that block. For example:

#
{
	// do some job with local variables that should not be seen outside

	let message = 'Hello'; // only visible in this blocl

	alert(message); // Hello
}

alert(message); // Error: message is not defined
#

We can use this to isolate a piece of code that does its own task, with variables that only belong to it:

#
{
	// show message
	let message = 'Hello';
	alert(message);
}

{
	// show another message
	let message = 'Goodbye';
	alert(message);
}
#


(i) there'd be an error without blocks - please note, without separate blocks there would be an error, if we use let with the existing variable name:

#
// show message

let message = 'Hello';
alert(message);

// show another message
let message = 'Goodbye'; // error: variable name already declared
alert(message);
#

For if, for while and so on, variables declared in {...} are only visible inside:

if (true) {
	let phrase = 'Hello!';

	alert(phrase); // Hello!
}

alert(phrase); // Error, no such variable!

Here, after if finishes, the alert below won't see the phrase, hence the error. That's great, as it allows us to create block-local variables, specific to an if branch.

The similar thing holds true for for and while loops;

for (let i = 0; i < 3; i++) {
	// the variable i is only visible inside this for
	alert(i); // 0, then 1, then 2
}

alert(i); // Error, no such variable;

Visially, let i is outside of {...}. but the for construct is special here: the variable, declared inside it, is considered a part of the block.

<><> NESTED FUNCTIONS

A function is called 'nested' when it is created inside another function. It is easily possible to do this with JavaScript. We can use it to organize our code, like this:

function sayHiBye(firstName, lastName) {
	
	// helper nested function to use below
	function getFullName() {
		return firstName + ' ' + lastName;
	}

	alert( 'Hello, ' + getFullName());
	alert( 'Bye, ' + getFullName());

}

Here the nested function getFullName() is made for convenience. It can access the outer variables and so can return the full name. Nested functions are quite common in JS.

What's much more interesting, a nested function can be returned: either as a property of a new object or as a result by itself. It can then be used somewhere else. No matter where, it still has access to the same outer variables.

Below, makeCounter creates the 'counter' function that returns the next number on each invocation:

#
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1
alert( counter() ); // 2
#

Despite being simple, slightly modified variants of that code have practical uses, for instance, as a random number generator to generate random values for automated tests.

How does this work? If we create multiple counters, will they be independent? What's going on with the variables here?

Understanding such things is great for the overall knowçedge of JS and beneficial for more complex scenarios. So let's go a bit in-depth.

<><> LEXICAL ENVIRONMENT

(w) Here be dragons! - The in-depth technical explanation lies ahead. As far as i'd like to avoid low-level language details, any understanding without them would be lacking and incomplete, so get ready.

For clarity, the explanation is split into multiple steps.

<><> STEP 1. VARIABLES

In JS, every running function, code block {...}, and the script as a whole have an internal (hidden) associated object known as the Lexical Environment.

The lexical Environment Object consists of two parts:

1. Environment Record = an object that stores all local variables as its properties (and some other information like the value of 'this').

2. a Reference to the outer lexical environment, the one associated with the outer code.

A 'variable' is just a property of the special internal object, Environment Record. "To get or change a variable" means "to get or change a property of that object".

In this simple code without functions, there is only one lexical environment:

let phrase = 'Hello'; ------- phrase: 'Hello' -> null
									L.E.	 outer
alert(phrase);

This is the so-called global lexical environment, associated with the whole script.
On the picture above, the rectangle means environment record (variable store) and the arrow means the outer reference. The global lexical environment has no outer reference, that's why the arrow points to null.

As the code starts executing and goes on, the lexical environment changes.

here's a little bit longer code:

execution start ------------- phrase: <uninitialized> -> null
                                                     outer
let phrase;     ------------- phrase: undefined
phrase = 'Hello'; ----------- phrase: 'Hello'
phrase = 'Bye';   ----------- phrase: 'Bye'

Rectangles on the right-hand side demonstrate how the GLE changes during the execution:

1. When the script starts, the lexical environment is pre-populates with all declared variables.
	Initially, they are in the 'uninnitialized' state. That's special internal state, it means that the
	engine knows about the variable, but it cannot be referenced until it has been declared with let. It's
	almost the same as if the variable didnt exist.

2. Then let phrase definition appears. There's no assignment yet, so its value is undefined. We can use the variable from this point forward.
3. phrase is assigned a value.
4. phrase changes the value.

Everything looks simple for now, right?

* a variable is a property of a special internal object, associated with the currently executing block/function/script.
* working with variables is actually working with the properties of that object.

(i) lexical environment is a specification object - 'lexical environment' is a specification object: it only exists 'theoretically' in the language specification to describe how things work. we can't get this object in our code and manipulate directly. JavaScript engines also may optimize it, discard variables that are unused to save memory and perform other internal tricks, as long as the visible behavior remains as described.

<><> STEP 2. FUNCTION DECLARATIONS

A function is also a value, like a variable. THE DIFFERENCE IS THAT A FUNCTION DECLARATION IS ISTANTLY FULLY INITIALIZED. When a lexical environment is created, a function declaration immediately becomes a ready-to-use function (unlike let, that is unusable till declaration). That's why we can use a function, declared as function declaration, even before the declaration itself. For example, here's the initial state of global lexical environment when we add a function:

execution start             -------------- phrase: <uninitialized> say: function --(outer)--> null

let phrase = 'Hello'        -------------- ...

function say(name) {
	alert( `${phrase}, ${name}`);
}

Naturally, this behavior only applies to function declarations, not function expressions where e assign a function to a variable such as let say = function(name)....

<><> STEP 3. Inner and Outer Lexical Environment

When a function runs, at the beginning of the call, a new Lexical Environment is created automatically to store local variables and parameters of the call. For instance, for say('john'), it looks like this (the execution is at the line, labelled with an arrow):

let phrase = 'Hello';

function say(name) {
	alert(`${phrase}, ${name}`);  ---------------- name: 'john' -(outer)-> say: function  -(outer)-> null
																		   phrase: 'Hello'
}

say('john'); // Hello, John

During the function call we have two lexical environments: the inner one (for the function call) and the outer one (global):

* the inner lexical environment corresponds to the current execution of say. It has a single property: name, the function argument. We called say('john'), so the value of the name is 'john'.
* the outer lexical environment is the global lexical environment. It has the phrase variable and the function itself.

The inner lexical environment has a reference to the outer one.

WHEN THE CODE WANTS TO ACESS A VARIABLE - THE INNER LEXICAL ENVIRONMENT IS SEARCHED FIRST, THEN THE OUTER ONE, THEN THE MORE OUTER ONE AND SO UNTIL THE GLOBAL ONE.

If a variable is not found anywhere, that's an error in strict mode (without use strict, an assignment to a non-existing variable creates a new global variable, for compatibility with old code).

In this example the search proceeds as follows:

* for the name variable, the alert inside say finds it immediately in the inner lexical environment.
* when it wants to access phrase, then there is no phrase locally, so it follows the reference to the outer Lexical Environment and fits it there.

<><> STEP 4 - RETURNING A FUNCTION

let's return to the makeCounter example.

#
function makeCounter() {
	let count = 0;

	return function() {
		return count++;
	};
}

let counter = makeCounter();
#

At the beginning of each makeCounter() call, a new Lexical Environment object is created, to store variables for this makeCounter run. So we have two nested lexical environments, just like in the example above.

What's different in that, during the execution of makeCounter(), a tiny nested function is created of only one line: return count++, we don't run it yet, only create.

All functions remember the lexical environment in which they were made. Technically, there's no magic here: All functions have the hidden property named [[Environment]], that keeps the reference to the lexical environment where the function was created:

So, counter.[[Environment]] has the reference to {count:0} Lexical Environment. That's how the function remembers where it was created, no matter where it's called. The [[Environment]] reference is set once and forever at function creation time.

Later, when counter() is called, a new Lexical Environment is created for the call, and its outer Lexical Environment reference is taken from counter.´[[Environment]]:

Now when the code inside counter() looks for count variable, it first searches its own Lexical Environment (empty, as there are no local variables there), then the Lexical Environment of the outer makeCounter() call, where it finds and changes it.

A VARIABLE IS UPDATED IN THE LEXICAL ENVIRONMENT WHERE IT LIVES.

Here's the state after the execution. If we call counter() multiple times, the count variable will be increased to 2, 3 and so on, at the same place.

(i) Closure - there is a general programming term 'closure' that developers generally should know. A closure is a function that remembers its outer variables and can access them. In some languages, that's not possible, or a function should be written in a special way to make it happen. But as explained above, in JS, all functions are naturally closures (there is only one exception, to be covered in the 'new function' syntax).

That is: they automatically remember where they were created using a hidden [[Environment]] property, and then their code can access outer variables. When on an interview, a frontend developer gets a question about 'what's a closure?', a valid answer would be:

* definition of the closure and an explanation that all functions in JS are closures, and maybe a few more words about technical details: the [[Environment]] property and how Lexical Environments Work.

<><> GARBAGE COLLECTION

Usually, a lexical environment is removed from memory with all the variables after the function call finishes. That's because there are no references to it. As any JS object, it's only kept in memory while it's reachable.

However, if there's a nested function that is still reachable after the end of a function, then it has [[Environment]] property that references the lexical environment. IN that case the lexical environment is still reachable even after the completion of the function, so it stays alive.

#
function f() {
	let value = 123;

	return function() {
		alert(value);
	}
}

let g = f(); // g.[[Environment]] stores a reference to the lexical environment // of the corresponding f() call.
#

Please note that if f() is called many times, and resulting functions are saved, then all corresponding lexical environment objects will also be retained in memory. In the code below, all 3 of them:

#
function f() {
	let value = Math.random();

	return function() {alert(value)};
}

// 3 functions in array, every one of them links to Lexical Environment
// from the corresponding f() run

let arr = [f(), f(), f()];
#

A lexical environment object dies when it becomes unreachable (just like any other object). In other words, it exists only while there's at least one nested function referencing it.

In the code below, after the nested function is removed, its enclosing lexical environment (and hence the value) is cleaned from memory:

#
function f() {
	let value = 123;

	return function() {
		alert(value);
	}
}

let g = f(); // while g function exists, the value stays in memory
g = null; // ... and now the memory is cleaned up
#

<><> REAL-LIFE OPTIMIZATIONS

AS we've seen, in theory while a function is alive, all outer variables are also retained.
But in practice, JS engines try to optimize that. They analyze variable usage and if it's obvious from the code that an outer variable is not used - it is removed.

AN IMPORTANT SIDE EFFECT IN V8 (chrome, edge, Opera) is that such variable will become unavailable in debugging.

Try running the example below in chrome with the developer tools open. When it bauses, in the console type alert(value);

#
function f() {
	let value = Math.random();

	function g() {
		debugger; // in console: type alert(value); no such variable!
	}

	return g;
}

let g = f();
g();
#

As you could see - there is no such variable! In theory, it should be acessible, but the engine optimized it out. That may lead to funny (if not such time-consuming) debugging issues. One of them - we can see a same-named outer variable instead of the expected one:

let value = "Surprise!";

function f() {
	let value = 'the closes value';

	function g() {
		debugger; // in console: type alert(value); Surprise!
	}

	return g;
}

let g = f();
g();

This feature of V8 is good to know. If you are debugging with chrome/edge/opera, sooner or later you will meet it. That is not a bug in the debugger, but rather a special feature of v8. Perhaps it will be changed sometime. YOu can always check for it by running the examples on this page.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

THE OLD VAR

(i) This article is for understanding old scripts. The information in this article is useful dor understanding
old scripts. That't not how we write new code.

In the very first chapter about variables, we mentioned three ways of variable declaration:

1. let
2. const
3. var

The var declaration is similar to let. Most of the time we can replace let by var or vice-versa and expect things to work:

#
var message = 'Hi';
alert(message); // Hi
#

But internally var is a very different beast, that originates from very old times. It's generally not used in modern scripts, but still lurks in the old ones.

If you don't plan on meething such scripts you may even skip this chapter or postpone it. On the other hand, it is important to understand differences when migrating old scripts from var to let, to avoid odd errors.

<><> 'var' HAS NO BLOCK SCOPE

Variables, declared with var, are either function-scoped or global-scoped. They are visible through blocks.
For instance:

#
if (true) {
	var test = true; // use 'var' instead of 'let'
}

alert(test); // true, the variable lives after if
#

the same thing for loops: var cannot be block or loop-local:

#
for (var i = 0; i < 10; i++) {
	var one = 1;
	// ...
}

alert(i); // 10, 'i' is visible after loop, it's a global variable
alert(one); // 1, 'one' is visible after loop, it's a global variable
#

IF a code block is inside a function, then var becomes a function-level variable:

function sayHi(){
	if(true) {
		var phrase = 'Hello';
	}

	alert(phrase); // works
}

sayHi();
alert(phrase); // reference error, phrase is not defined

As we can see, var pierces through if, for or other code blocks. That's because a long time ago in JS, blocks nad no lexical environments, and var is a remnant of that.

<><> 'var' TOLERATES REDECLARATIONS

if we declare the same variable with let twice in the same scope, that's an error:

let user;
let user; // SyntaxError: 'user' has already been declared

with 'var', we can redeclare a variable any number of times. If we use 'var' with an already-declared variable, it's just ignored:

var user = 'Pete';
var user = "John"; // this 'var' does nothing (already declared)
// ...it doesn't trigger an error

alert(user); // John

<><> 'var' variables can be declared below their use

var declarations are processed when the function starts (or script starts for globals). In other words, var variables are defined from the beginning of the function, no matter where the definition is (assuming that the definition is not in the nested function).

So this code:

#
function sayHi() {
	phrase = 'Hello';

	alert(phrase);

	var phrase;
}

sayHi();
#

... is technically the same as this (moved var phrase above):

function sayHi() {
	var phrase;

	phrase = 'Hello';

	alert(phrase);
}
sayHi();

... or even as this (remember, code blocks are ignored):

function sayHi() {
	phrase = 'Hello'; // (*)

	if (false) {
		var phrase;
	}

	alert(phrase);
}
sayHi();
#

People also call such behavior 'hoisting' (raising), because all var are 'hoisted' (raised) to the top
of the function. So in the example above, if (false) branch never executes, but that doesn't matter. The var inside it is processed in the beginning of the function, so at the moment of (*) the variable exists.

DECLARATIONS ARE HOISTED, BUT ASSIGNMENTS ARE NOT

That's best demonstrated with an example:

#
function sayHi() {
	alert(phrase);

	var phrase = 'Hello';
}

sayHi();
#

the line var phrase = 'Hello' has two actions in it:

1. variable declaration var
2. variable assignment =.

The declaration is processed at the start of function execution (hoisted), but the assignment always works at the place where it appears. So the code works essentially like this:

#
function sayHi() {
  var phrase; // declaration works at the start...

  alert(phrase); // undefined

  phrase = "Hello"; // ...assignment - when the execution reaches it.
}

sayHi();
#

Because all var declarations are processed at the function start, we can reference them at any place. But variables are undefined until the assignments. In both examples above, alert runs without an error, because the variable phrase exists. but its value is not yer assigned, so it shows undefined.

<><> IIFE

In the past, as there was only 'var', and it has no block-level visibility, programmers invented a way to emulate it. What they did was called 'immediately-invoked function expressions' (aka IIFE).

That's not something we should use nowadays, but you can find it in older scripts. An IIFE looks like this:

# 
(function() {
	
	var message = 'Hello';

	alert(message); // Hello

})();
#

here a function expression is created and immediately called. So the code executes right away and has its own private variables. The function expression is wrapped with parenthesis (function {...}), because when JS engine encounters 'function' in the main code, it understands it as the start of a function declaration. But a function declaration must have a name, so this kind of code will give an error.

#
// Tries to declare and immediately call a function
function() { // <-- SyntaxError: Function statements require a function name

  var message = "Hello";

  alert(message); // Hello

}();
#

Even if we say 'okay, let's add a name', that won't work, as JS does not allow function declarations to be called immediately:

#
// syntax error because of parentheses below
function go() {

}(); // <-- can't call Function Declaration immediately
#

So the parentheses around the function is a trick to show JS that the function is created in the context of another expression, and hence it's a function expression: it needs no name and can be called immediately.

there exist other ways besides parentheses to thell JS that we mwan a function expression:

#
// Ways to create IIFE

(function() {
  alert("Parentheses around the function");
})();

(function() {
  alert("Parentheses around the whole thing");
}());

!function() {
  alert("Bitwise NOT operator starts the expression");
}();

+function() {
  alert("Unary plus starts the expression");
}();
#

IN all the above cases we declare a function expression and run it immediately. Let's note again: nowadays there's no reason to write such code.

<><> SUMMARY!

there are two main differences of 'var' compared to 'let/const':

1. var variables have no block scope, their visibility is scoped to current function, or global, if declared outside function.
2. var declarations are processed at function start (script start for globals)

There's one more very minor difference related to the global object that we will cover in the next chapter.
These differences make var worse than let most of the time. Block-level variables is such a great thing. That's
why 'let' was introduced in the standard long ago, and is now a major way)along with const) to declare a variable.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

GLOBAL OBJECT

The global object provides variables and functions that are available anywhere. By default, those that are built into the language or the environment. In a browser it is named window, for Node.js it is global, for other environments it may have another name.

REcently, globalThis was added to the language, as a standardized name for a global object, that should be supported across all environments. It's supported in all major browsers.

WE'll use window here, assuming that our environment is a browser. If your script may run in other environments, it's better to use globalThis instead.

All properties of the global object can be accessed directly:

#
alert("Hello");
// is the same as
window.alert("Hello");
#

In a browser, global functions and variables declared with 'var' (not let/const!) become the property of the global object:

#
var gVar = 5;

alert(window.gVar); // 5 (became a property of the global object)
#

the same effect have function declarations (statements with function keyword in the main code flow, not function expressions). Please don't rely on that! this behavior exists for compatibility reasons. Modern scripts use JavaScript modules where such a thing doesn't happen.

IF we used let instead, such thing wouldn't happen:

#
let gLet = 5;
alert(window.gLet); // undefined (doesn't become a property of the global object)
#

If a value is so important that you'd like to make it available globally, write it directly as a property:


#
// make current user information global, to let all scripts access it
window.currentUser = {
	name: "John"
};

// somewhere else in code
alert(currentUser.name); // John

// or, if we have a local variable with the name 'currentUser'
// get it from window explicitly (safe!)
alert(window.currentUser.name); // John
#

that said, using global variables is generally discouraged. There should be as few global variables as possible. The code design where a function gets 'input' variables and produces certain 'outcome' is clearer, less prone to errors and easier to test than if it uses outer or global variables.

<><> USING FOR POLYFILLS

we use the global object to test for support of modern language features. For instance, test if a built-in Promise object exists (it doesn't in really old browsers):

#
if (!window.Promise) {
	alert("Your browser is really old!");
}
#

If there's none (say, we're in an old browser), we can create 'polyfills': add functions that are not supported by the environment, but exist in the modern standard.

if (!window.Promise) {
	window.Promise = ... // custom implementation of the modern language feature
}

SUMMARY!

* the global object holds variables that shuold be available everywhere - that includes JS built-ins, such as Array and environment-specific values, such as window.innerHeight - the window height in the browser.

* The global object has a universal name globalThis. ...But more often is referred by 'old-school' environment-specific names such as 'window' (browser) and 'global' (node.js).

* We should store values in the global object only ig they're truly global for our project. And keep their number at minimum.

* In-browser, unless we're using modules, global functions and variables declared with 'var' become a property of the global object.

* to make our code future-proof and easier to understand, we should access properties of the global object directly, as window.x.


<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

FUNCTION OBJECT, NFE

As we already know, a function in JavaScript is a value. Every value in JavaScript has a type. What type is a function? in JS, functions are objects. A good way to imagine functions is a callable "action objects". We can not only call them, but also treat them as objects: add/remove properties, pass by reference etc.

<><> The 'name' property

Function objects contain some useable properties. For instance, a function's name is accessible as the 'name' property:

#
function sayHi() {
	alert('Hi');
}

alert(sayHi.name); // sayHi
#

What's kind of funny, the name-assigning logic is smart. It also assigns the corrent name to a function even if it's created without one, and them immediately assigned:

#
let sayHi = function() {
	alert("Hi");
};

alert(sayHi.name); // sayHi (there's a name!)
#

it also works if the assignment is done via a default value:

#
function f(sayHi = function() {}) {
	alert(sayHi.name); //sayHi (works!)
}

f();
#

In the specification, this feature is called a 'contextual name'. If the function does not provide one, then in an assignment it is figured out from the context. Object methods have names too:

let user = {
	
	sayHi() {
		// ...
	},

	sayBye: function() {
		// ...
	}

}

alert(user.sayHi.name); // sayHi
alert(user.sayBye.name); // sayBye

There is no magic though. There are cases when there's no way to figure out the right name; In that case, the name property is empty, like here:

#
//function created inside array
let arr = [function() {}];

alert(arr[0].name); // <empty string>
// the engine has no way to set up the right name, so there is none
#

In practive, however, most functions do have a name.

<><> THE 'LENGTH' PROPERTY

there is another built-in property 'length' that returns the number of function parameters, for instance:

#
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2
#

Here we can see that rest parameters are not counted. The length property is sometimes used for introspection in a functions that operate or other functions. For instance, in the code below the ask function accepts a question to ask and an arbitrary number of handler functions to call.

Once a user provides their answer, the function calls the handlers. We can pass two kinds of handlers:

* a zero-argument function, which is only called when the user gives a positive answer.
* a function with arguments, which is called in either case and returns an answer.

To call handler the right way, we examine the handler.length property. The idea is that we have a simple, no-arguments handler syntax for positive cases (most frequent variant), but are able to suppoert universal handlers as well:

#
function ask(question, ...handlers) {
	let isYes = confirm(question);

	for(let handler of handlers) {
		if (handler.length == 0) {
			if (isYes) handler();
		} else {
			handler(isYes);
		}
	}
}

// for positive answer, both handlers are called
// for negative answer, only the second one
ask('Question?', () => alert('You said yes'), result => alert(result));
#

This is a particular case of so-called polymorphism - treating arguments differently depending on their type or, in our case depending on the length. The idea does have a use in JavaScript libraries.

<><> CUSTOM PROPERTIES

we can also add properties of our own. Here we add the counter property to track the total calls count:

#
function sayHi() {
	alert("Hi");

	// let's count how many times we run
	saiHy.counter++;
}

sayHi.counter = 0; // initial value

sayHi(); // Hi
sayHi(); // Hi

alert(`Called ${sayHi.counter} times`); // called 2 times
#

(w) a property is not a variable - a property assigned to a function like sayHi.counter = 0 does not DEFINE a local variable counter inside it. In other words, a property counter and a variable let counter are two unrelated things.

We can treat a function as an object, store properties in it, but that has no effect on its execution. variables are not function properties and vice versa. These are just parallel worlds.

Function properties can replace closures sometimes. For instance, we can rewrite the coutner function example from the chapter Variable scope, closure to use a function property:

#
function makeCounter() {
	// instead of:
	// let count = 0

	function counter() {
		return counter.count++;
	};

	counter.count = 0;

	return counter;
}

let counter = makeCounter();
alert(counter()); //0
alert(counter()); //1
#

The count is now stored in the function directly, not in its outer Lexical Environment. Is it better or worse than using a closure? The main difference is that if the value of count lives in an outer variable, the exernal codeis unable to access it. Only nested functions may modify it. And if it's bound to a function, then such a thing is possible:

#
function makeCounter() {
	
	function counter() {
		return counter.count++;
	}

	counter.count = 0;

	return counter;
}

let counter = makeCounter();

counter.count = 10;
alert(counter()); // 10
#

So the choice of implementation depends on our aims.

<><> NAMED FUNCTION EXPRESSION

Named function expression, or NFE is a term for function expressions that have a name. For instance, let's take an ordinary function expression:

#
let sayHi = function(who) {
	alert(`Hello, ${who}`);
};
#

and add a name to it:

let sayHi = function func(who) {
	alert(`Hello, ${who}`);
};

did we achieve anything here? what's the purpose of that additional 'func' name?
first let's note, that we still have a function expression. adding the name 'func' after 'function' did not make it a funcition declaration, because it is still created as a part of an assignment expression.

Adding such a name also did not break anything. the function is still available as sayHi()? Yes

let sayHi = function func(who) {
	alert(`Hello, ${who}`);
};

sayHi("John"); // Hello, John

There are two special things about the name func, that are the reasons for it:

1. It allows the function to reference itself internally.
2. It is not visible outside of the function.

For instance, the function sayHi below calls itself again with 'Guest' if no who is provided:

let sayHi = function func(who) {
	if(who) {
		alert(`Hello, ${who}`);
	} else {
		func('Guest'); //use func to re-call itself
	}
};

sayHi(); // Hello, Guest

// but this won't work:

func(); // error, func is not defined.

Why do we use func? Maybe just use sayHi for the nested call? Actually, in most cases we can:

let sayHi = function(who) {
	if(who) {
		alert(`Hello, ${who}`);
	} else {
		sayHi("Guest");
	}
};

The problem with that code is that sayHi may change in the outer code. If the function gets assigned to another variable instead, the code will start to give errors:

let sayHi = function(who) {
	if(who) {
		alert(`Hello, ${who}`);
	} else {
		sayHi('Guest'); // error, sayHi is not a function
	}
};

let welcome = sayHi;
sayHi = null;

welcome(); // Error, the nested sayHi call doesn't work any more!


That happens because the function takes sayHi from its outer lexical environment. There's no local sayHi, so the outer variable is used. And at the moment of the call that outer sayHi is null.

The optional name which we can put into the Function Expression is meant to solve exactly these kinds fo problems.
Let's use it to fix our code:

#
let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func("Guest"); // Now all fine
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // Hello, Guest (nested call works)
#

Now it works, because the name 'func' is function-local. It is not taken from outside (and not visible there). The specification guarantees that it will always reference the current function. The outer code still has its variable sayHi or welcome. And 'func' is an 'internal function name', how the function can call itself internally.

(i) there's no such thing for function declaration - the 'internal name' feature describer here is only available for function expressions, nor for function declarations. For function declarations there is no syntax for adding an 'internal' name. Sometimes, when we need a reliable internal name, it's the reason to rewrite a function declaration to named function expression form.

<><> SUMMARY!

functions are objects. Here we covered their properties: 

name - the function name. usually taken from the function definition, but if there's none, JS tries to guess it from the context.

length - the number of arguments in the function definition. rest parameters are not counted.

If the function is declared as a function expression (not in the main code flow), and it carries the name, then it is called a Named Function Expression. The name can be used inside to reference itself, for recursive calls or such.

Also, functions may carry additional properties. Many well-known JS libraries make great use of this feature.

They create a 'main' function and attach many other 'helper' functions to it. For instance, the jQuery library creates a function named $. The lodash library creates a function _, and then adds _.clone, _.keyBy and other properties to it (see the docs when you want to learn more about them). Actually, they do it to lessen their pollution of the global space, so that a single library gives only one global variable. That reduces the possibility of naming conflicts.

So, a function can do a useful job by itself and also carry a bunch of other functionality in properties.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

The 'new function' syntax.

There's one more wya to create a function. It's rarely used, but sometimes there's no alternative.

Syntax

The syntax for creatinf a function:

let func = new Function ([arg1, arg2, ...argN], functionBody);

the function is created with the arguments arg1, ...argN and the given functionBody.

It's easier to understand by looking at an example, here's a function with two arguments:

let sum = new Function('a', 'b', 'return a + b');

alert( sum(1, 2) ); // 3

And here there's a function without arguments, with only the function body:

let sayHi = new Function('alert("Hello")');
sayHi(); // Hello

The major difference from other ways we've seen is that the function is created literally from a string, that is passed at run time. All previous declarations required us, programmers, to write the function code in the script. But 'new Function' allos to turn any string into a function. For example, we can receive a new function from a server and then execute it:

let str = ... receive the code from a ser dynamically ...

let func = new Function(str);
func();

it is used in very specific cases, like when we receive code from a server, or to dynamically complie a function from a template, in complex web-apps.

<><> Closure

Usually, a function remembers where it was born in the special property [[Environment]]. It references the 
lexical environment from where it's created (we covered that in the chapter Variable Scope, Closure). But when a function is created using new Function, its [[Environment]] is set to reference not the current Lexical Environment, but the global one.

So, such functions do not have access to outer variables, only to the global ones. So, in short, NEW sets the LE to global.

function getFunc() {
	let value = 'test';

	let func = new Function('alert(value)');

	return func;
}

getFunc()();

// compare it with regular behavior:

function getFunc() {
	let value = 'test';

	let func = function() { alert(value); };

	return func;
}

getFunc()(); // 'test' - from the lexical environment of getFunc

This special feature of new Function looks strange, but appears very useful in practice. Imagine that we must create a function from a string. The code of that function is not known at the time of writing the script (that's why we don't use regular functions), but will be known in the process of execution. We may receive it from the server or from another source.

Our new function needs to interact with the main script. What if it could access the ouver variables? The problem is that before JS is published to production, it's compressed unsing a minifier - a special program that shrinks code by removing extra comments, spaces and - what's important, renames local variables into shorter ones.

For instance, if a function has let userName, minifier replaces it with let a (or another letter if this one is occupied), and does it everywhere. That's usually a safe thing to do, because the variable is local, nothing outside the function can access it. And inside the function, minifier replaces every mention of it. Minifiers are smart, they abalyze the code structure so they don't break anything. They're not just a dumb find-and-replace.

So if new Function had acess to outer variables, it would be unable to find renamed 'userName'.

IF 'NEW FUNCTION' had access to outer variables, it would have problems with minifiers.

Besides, such dode would be architecturally bad and prone to errors. To pass something to a function, created as 'new Function', we should use its arguments.

SUMMARY

The syntax:

let func = new Function ([arg1, arg2, ...argN], functionBody);

for historical reasons, arguments can also be given as a comma-separated list. These three declarations mean the same:

new Function('a', 'b', 'return a + b'); // basic syntax
new Function('a,b', 'return a + b'); // comma-separated
new Function('a , b', 'return a + b'); // comma-separated with spaces

Functions created with 'new Function', have[[Environment]] referencing the global Lexical Enfironment, not the outer one. Hence, they cannot use outer variables. But that's actually good, because it insures us from errors. Passing parameters explicitly is a much better method architecturally and causes no problems with minifiers.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

SCHEDULING: setTimeout and setInterval

We may decide to execute a function not right now, but at a certain time later. That's called 'scheduling a call'.

There are two methods for it:

* setTimeout allows us to run a function once after the interval of time
* setInterval allows us to run a function repeatedly, starting after the interval of time, then repeating continuously at that interval.

These methods are not a part of JavaScript speficication. But most environments have the internal scheduler and provide these methods. In particular, they are supported in all browsers and Node.js.

<><> setTimeout

the syntax:

let timerId = setTimeout(funcZcode, [delay], [arg1], [arg2], ...)

Parameters:

<><> func|code

Function or a string of code to execute. Usually, that's a function. For historical reasons, a string of code can be passed, but that's not recommended.

<><> delay

the delay before nun, in milliseconds (1000 ms = 1 second), by default 0.

arg1, arg2...

Arguments for the function (not supported in IE9-)

for instance, this code calls sayHi() after one second:

function sayHi() {
	alert('Hello');
}

setTimeout(sayHi, 1000);

With arguments

function sayHi(phrase, who) {
	alert( phrase + ', ' + who);
}

setTimeout(sayHi, 1000, 'Hello', 'John'); // Hello, John

if the first argument is a string, then JavaScript creates a function from it. So, this will also work:

setTimeout("alert('Hello')", 1000);

but using strings is not recommended, use arrow functions instead of them, like this:

setTimeout(() => alert('Hello'), 1000);

(i) Pass a function, but don't run it

Novice developers sometimes make a mistake by adding brackets () after the function:

#
// wrong!
setTimeout(sayHi(), 1000);
#

That doesn't work, because setTimeout expects a reference to a function, and here sayHi() runs the function, and the result of its execution is passed to setTimeout. In our case, the result of sayHi() is undefined (the function returns nothing), so nothing is scheduled.

<><> CANCELING WITH clearTimeout

A call to setTimeout returns 'timer identifier' timerId that we can use to cancel the execution.
The syntax to cancel:

#
let timerId = setTimeout(...);
clearTimeout(timerId);
#

In the code below, we schedule the function and then cancel it (changed our mind). As a result, nothing happens:

#
let timerId = setTimeout(() => alert('never happens'), 1000);
alert(timerId); // timer identifier

clearTimeout(timerId);
alert(timerId); // same identifier (doesn't become null after canceling)
#

as we can see from 'alert' output, in a browser the timer identifier is a number. In other environments, this can be something else. For instance, Node.js returns a timer object with additional methods.

Again, there is no universal specification for these methods, so that's fine. For browsers, timers are described in the timers section of HTML5 standard.

<><> setInterval

the setInterval method has the same syntax as setTimeout:

let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)

All arguments have the same meaning. But unlike setTimeout it runs the function not only once, but regularly after the given interval of time. To stop further calls, we should call clearInterval(timerId). The following example will show the message every 2 seconds. After 5 seconds, the output is stopped:

// repeat with the interval of 2 seconds
let timerId = setInterval(() => alert('tick'), 2000);

// after 5 seconds stop
setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);

(i) Time goes on while alert is shown - In most browsers, including Chrome and Firefox the internal timer continues 'ticking' while showing alert/confirm/prompt. So if you run the code above and don't dismiss the 'alert' window for some time, then the next alert will be shown immediately as you do it. The actual interval between alerts will be shorter than 2 seconds.

<><> NESTED setTimeout

there are two ways of running something regularly. One is setInterval. The other one is a nested setTimeout, like this:

/** instead of:
let timerId = setInterval(() => alert('tick'), 2000);
*/

let timerId = setTimeout(function tick() {
	alert('tick');
	timerId = setTimeout(tick, 2000); // (*)
}, 2000);

The setTimeout above schedules the next call right at the end of the current one (*).
The nested setTimeout is a more flexible method than setInterval. This way the next call may be scheduled differently, depending on the results of the current one.

For instance, we need to write a service that sends a request to the server every 5 seconds asking for data, but in case the server is overloaded, it should increase the interval to 10, 20, 40 seconds.

Here's the pseudocode:

#
let delay = 5000;

let timerId = setTimeout(function request() {
	... send request...

	if (request failed due to server overload) {
		// increase the interval to the next run
		delay *= 2;
	}

	timerId = setTimeout(request, delay);

}, delay);
#

And if the functions that we're scheduling are CPU-hungry, then we can measure the time taken by the execution and plan the next call sooner or later.

NESTED setTimeout ALLOWS TO SET THE DELAY BETWEEN THE EXECUTIONS MORE PRECISELY THAN setInterval

Let's compare two code fragments. The fisrt one uses setInterval.

#
let i = 1;
setInterval(function() {
	func(i++);
}, 100);
#

The second one uses nested setTimeout:

#
let i = 1;
setTimeout(function run() {
	func(i++);
	setTimeout(run, 100);
}, 100);
#

For setInterval the internal scheduler will run func(i++) every 100ms:

func(1) - 100
func(2) - 200
func(3) - 300

Did you notice?

THE REAL DELAY BETWEEN FUNC CALLS FOR SETINTERVAL IS LESS THAN IN THE CODE!

That's normal, because the time taken by func's execution 'consumes' a part of the interval. It is possible that 'func's execution turns out to be longer than we expected and takes more than 100ms. In this case the engine waits for 'func' to complete, then checks the scheduler and if the time is up, runs it again immediately.

In the edge case, if the function always executes longer than delay ms, then the calls will happen without a pause at all. And here is the picture for the nested setTimeout:

func(1) -
100 
func(2) - 
100
func(3) - 

THE NESTED setTimeout GUARANTEES THE FIXED DELAY (here 100ms).
That's because a new call is planned at the end of the previous one.

(i) Garbage collection and setInterval/setTimeout callback - when a function is passed in setInterval/setTimeout, an internal reference is created to it and saved in the scheduler. It prevents the function from being garbage collected, even if there are no other references to it.

// the function stays in memory until the scheduler calls it
setTimeout(function() {...}, 100);

for setInterval the function stays in memory until clearInterval is called. There's a side-effect. A function references the outer lexical environment, so, while it lives, outer variables live too. They may take much more memory than the function itself. So when don't need the scheduled function anymore, it's better to cancel it, even if it's very small.

<><> ZERO DELAY setTimeout

There's a special use case: setTimeout(func, 0), or just setTimeout(func).
This schedules the execution of func as soon as possible. But the scheduler will invoke it only after the currently executing script is complete.

So the function is scheduled to run 'right after' the current script. For instance, this outputs 'Hello', then immediately "World":

#
setTimeout(() => alert('World'));
alert('Hello');
#

the first line 'puts the call into calendar after 0ms'. But the scheduler will only 'check the calendar' after the current script is complete, so 'Hello' is first and 'World' - after it.

there are also advanced browser-related use cases of zero-delay timeout, that we'll discuss in the chapter Event loop: microtasks and macrotasks

(i) Zero delay is in fact not zero (in a browser) - in the browser, there's a limitation of how often nested timers can run. The HTML5 standard says: 'after five nested timers, the interval is forced to be at least 4 miliseconds'. Let's demonstrate what it means with the example below. The setTimeout call in it re-schedules itself with zero delay. Each call remembers the real time from the previous one in the times array. What do the real delays look like? Let's see:

let start = Date.now();
let times = [];

setTimeout(function run() {
	times.push(Date.now() - start); // remember delay from the previous call

	if (start + 100 < Date.now()) alert(times); // show the delays after 100ms
	else setTimeout(run); // else re-schedule
});

// an example of the output:
// 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100

First timers run immediately (just as written in the spec), and then we see 9, 15, 20, 24.... The 4+ ms obligatory delay between invocations comes into play.

The similar thing happens if we use setInterval instead of setTimeout: setInterval(f) runs f few times with zero-delay, and afterwards with 4+ ms delay.

That limitation comes from ancient times and many scripts rely on it, so it exists for historical reasons.

For server-side JavaScript, that limitation does not exist, and there exist other ways to schedule an immediate asynchronous job, like setImmediate for Node.js. So this note is browser-specific.

<><> SUMMARY 

* Methods setTimeout(func, delay, ...args) and setInterval(func, delay, ...args) allow us to run the func once/regularly after delay miliseconds.

* To cancel the execution, we should call clearTimeout / clearInterval with the value returned by setTimeout / setInterval.

* Nested setTiemout calls are a more flexible alternative to setInterval, allowing us to set the time between executions more precisely.

* Zero delay scheduling with setTimeout(func, 0) (the same as setTimeout(func)) is used to schedule the call 'as soon as possible, but after the current script is complete'.

* The browser limits the minimal delay for five or more nested calls of 'setTimeout' or for 'setInterval' (after 5th call) to 4ms. That's for historical reasons.

Please note that all scheduling methods do not guarantee the exact delay. For example, the in-browser timer may slow down for a lot of reasons:

* the cpu is overloaded.
* the browser tab is in the background mode.
* the laptop is on battery.

All that may increase the minimal timer resolution (the minimal delay) to 300ms or even 1000ms depending on the browser and OS-level performance settings.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Decorator - a special function that takes another function and alters its behaviror. Usually, the function is a wrapper around the original func, that catches it into logic; can be used for cacheing results for slow funcs.

* it is reusable, can be used to catch any other functions
* the catching logic is separate, it did not increase the complexity of slow itself
* we can combine multiple decorators if needed (other decorators will follow)

Sometimes we want to use the context (the 'this' keyword) to call the function from the wrapper.

we can use the method: func.call(context, arg1, arg2, ...) for that to work.

1. after the decoration worker.slow is now the wrapper function (x) {...}
2. So when worker.slow(2) is executed, the wrapper gets 2 as an argument and this=worker (it's the object before dot)
3. Inside the wrapper, assuming the result is not yet cached, func.call(this, x) passes the current 'this' (=worker) and the current argument (=2) to the original method.


what if we want to use not only one argument but several? there are several options to this:

1. implement a new (or use a third-party) map-like data structure that is more versatile and allows multi-keys.
2. use nested maps: cache.set(min) will be a Map that stores the pair (max, result). So we can get result as cache.get(min).get(max).
3. join two values into one. In our particular case we can just use a string 'min, max' as the 'map key'. for flexibility, we can allow to provide a hashing function for the decorator, that knows how to make one value from many.

Third variant is usually good enough.

instead of calling func.call(this, x) we do func.call(this, ...arguments) (rest operator).

Now we can apply a more general decorator:

let worker = {
  slow(min, max) {
    alert(`Called with ${min},${max}`);
    return min + max;
  }
};

function cachingDecorator(func, hash) {
  let cache = new Map();
  return function() {
    let key = hash(arguments); // (*)
    if (cache.has(key)) {
      return cache.get(key);
    }

    let result = func.call(this, ...arguments); // (**)

    cache.set(key, result);
    return result;
  };
}

function hash(args) {
  return args[0] + ',' + args[1];
}

worker.slow = cachingDecorator(worker.slow, hash);

alert( worker.slow(3, 5) ); // works
alert( "Again " + worker.slow(3, 5) ); // same (cached)

Now it works with any number of arguments (though the has to be adjusted to allow any number of arguments).

* in the line (*) it calls 'hash' to create a single key from 'arguments'. hwere we use a simple joining function that turns arguments (3, 5) into the key '3, 5'. More complex cases may require other hashing functions.

* then (**) uses func.call(this, ...arguments) to pass both the context and all arguments the wrapper got (not just the first one) to the original function.

Sometimes it is interesting to use func.apply instead of func.call. The main difference is that call expects a list of arguments while apply takes an 'array-like' object with them.

meaning these calls are equivalent:

func.call(context, ...args);
func.apply(context, args);

passing all arguments along with the context to another function is called 'CALL FORWARDING'.

a subtle difference:

* the spread syntax ... allows to pass iterable args as the list to call.
* the apply accepts ONLY array-like args.

Sometimes we think the has is done with join() but we gotta remember that it only works with real array.
However, there's a trick here:

function hash() {
	alert([].join.call(arguments)); // 1, 2
}

hash(1, 2);

This trick is called METHOD BORROWING. We borrow a join method from a regular array and use [].join.call to run it in the context of arguments.

It works because arr.join(glue) is very simple and intentionally created in a way that it allows array-like 'this'. That's why it also works with this = arguments.

<><> decorators and function properties

If the original function has properties on it, the decorated function will not provide them, because it is a wrapper.

Some decorators provide their own properties. With proxy and reflect it is possible to access function properties in a decorator.

<><> SUMMARY

Decorator is a wrapper around a function that alters its behavior. The main job is still carried out by the function. Decorators can be seen as 'features' or 'aspects' that can be added to a function. We can add one or add many. And all this without changing its code!

To implement cachingDecorator, we studied methods:

* func.call(context, arg1, arg2...) - calls func with given context and arguments.
* func.apply(context, args) - calls func passing context as this and array-like args into list of arguments.

The generic call forwarding is usually done with apply:

let wrapper = function() {
	return original.apply(this, arguments);
};

We also saw an example of method borrowing when we take a method from an object and call it in the context of another object. It is quite common to take array methods and apply them to arguments. The alternative is to use rest parameters object that is a real array.

There are many decorators there in the wild. Check how well you got them by solving the tasks of this chapter.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

